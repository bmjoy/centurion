<html>
<head>
<style type="text/css">
body { font-family: Arial, Helvetica, sans-serif; }
h1 { color:#0005C8; }
h2 { color:#0005C8; }
h3 { color:#0005C8; }
h4 { color:#0005C8; }
code { color:#800000; }
pre.cmd { color:#0000c0; }
pre.code { color:#600000; }
pre.proto { color:#800000; }
pre.anot { color:#0000c0; }
pre.conf { color:#0000c0; }
pre.schema { color:#0000ff; }
pre.xml { color:#0000ff; }
span.xtag { color:#800000; }
span.xattr { color:#ff0000; }
span.ckw { color:#0000ff; }
span.ccom { color:#008000; }
p.nav-links { text-align:right; margin-top: 0px; margin-bottom: 0px; }
p.content-link { margin-top: 2px; margin-bottom: 4px; border: 2px 0; padding: 2px 0; }
p.collapsable-content-link { margin-top: 4px; margin-bottom: 2px; border: 2px 0; padding: 2px 0; }
div.collapsable-div { margin-left: 40px; margin-bottom: 20px; }
.desc { background-color:#99DAFF; width:100%; padding: 5px; border-width: thin;    border-style: solid; border-color: #99DAFF; }
.synop { color:#0000ff; background-color:#B7E5FF; padding: 5px; }
.flist { background-color:#FFF; padding: 5px; }
.ret { color: #FF9900; text-align: right; }
.fname { color: #800000; }
.args { color: #00f; }
.comment { color: #008000; }
</style>
<script type="text/javascript">
var last_close = '';
function open(what)
{
	document.getElementById('div-'+what).style.display = 'block';
	document.getElementById('contents-'+what).style.display = 'none';
}
function close(what)
{
	document.getElementById('div-'+what).style.display = 'none';
	document.getElementById('contents-'+what).style.display = 'block';
	if( last_close != '' )
		document.getElementById('contents-'+last_close).style.fontWeight='normal';
	document.getElementById('contents-'+what).style.fontWeight='bold';
	last_close = what;
}
function bottom_close(what)
{
	document.location.hash = what;
	close(what);
}
function far_link(what)
{
	open(what);
	document.location.hash = '';	// Browser won't move if hash is already specified (but moved from) target location
	document.location.hash = what;
}
</script>
<title>Codalogic LMX - W3C XML Schema to C++ Binding Code Generator</title>
</head>
<body>
<!-- HEADER CENTER "" -->
<!-- FOOTER LEFT "" -->
<!-- FOOTER RIGHT "" -->

<a name='top'></a>
<!--TITLESTART-->
<center>
<font size=+3 color='#0005C8'><b>Codalogic LMX</b></font><font size=+3 color='#0005C8'><b><br>W3C XML Schema to C++ Code Generator</b></font><br>
<font size=-1>Version 7.4<br>Document Revision 1<br>
Copyright &copy; 2003-2019 Codalogic Ltd.</font>
</center>
<!--TITLEEND-->
				
<!-- HEADER CENTER "$TITLE" -->
<!-- FOOTER LEFT "$HEADING" -->
<!-- FOOTER RIGHT "$PAGE" -->

<!--NoNum--><!--Preamble--><h1>Introduction</h1>
<p>
This is the main documentation for the LMX<sup>&trade;</sup> XML Schema to C++ code generator.  It is available as a single <a href='http://codalogic.com/lmx/lmx-start.html' target='_blank'>HTML file</a> for easy on-line viewing and viewing on Linux, as a Windows<sup>&reg;</sup> <a href='http://codalogic.com/lmx/lmx-start.chm' target='_blank'>HTML Help file (.chm)</a> for viewing on Windows, and as a <a href='http://codalogic.com/lmx/lmx-start.pdf' target='_blank'>PDF file</a> for printing.  A printed version of this manual can also be purchased.
<p>
If the LMX code generator seems like the tool you need (see <a href=''>What is LMX?</a> to help you with that), the first thing to do is <a href='#Download_Installation'>download and install</a> a copy.  You can evaluate a limited functionality version of LMX without a license.  Having decided that LMX is what you need, you need to <a href='#Licensing'>acquire a license</a> file and store it on your PC.  You will then be able to generate code by following the <a href='#Quick_Start'>Quick Start</a> instructions.  Later you may wish to adapt LMX to better meet your requirements.  Information on how to do this is covered in section <a href='#InMoreDepth'>3&nbsp;-&nbsp;In More Depth</a>.

<!--Will be converted to h2 for book.  Leave as h1 for other PDF so Quick Index is a top-level link in the PDF navigation pane-->
<!--NoNum--><!--Preamble--><h1>Quick Index</h1>
Quick links to popular topics:
<ul>
<p class='content-link'><a href='#VersionHistory'>1.7&nbsp;-&nbsp;Version History</a></p>
<p class='content-link'><a href='#QuickStart'>2&nbsp;-&nbsp;Quick Start</a></p>
<p class='content-link'><a href='#CodeGeneration'>2.1&nbsp;-&nbsp;Code Generation</a></p>
<p class='content-link'><a href='#CommandlineFlags'>3.8&nbsp;-&nbsp;Command-line Flags</a></p>
<p class='content-link'><a href='#ErrorCodes'>3.9&nbsp;-&nbsp;Error Codes</a></p>
<p class='content-link'><a href='#CCompilingandLinking'>2.2&nbsp;-&nbsp;C++ Compiling and Linking</a></p>
<p class='content-link'><a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a></p>
<p class='content-link'><a href='#Marshalingsimpleform'>2.4&nbsp;-&nbsp;Marshaling (simple form)</a></p>
<p class='content-link'><a href='#AccesingtheDataintheGeneratedClasses'>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</a></p>
<!--<p class='content-link'><a href='#ModifyingSchemaTypetoCTypeMapping'>3.13.1&nbsp;-&nbsp;Modifying Schema Type to C++ Type Mapping</a></p>-->
<p class='content-link'><a href='#AugmentingGeneratedClassesWithYourOwnCode'>3.14&nbsp;-&nbsp;Augmenting Generated Classes With Your Own Code</a></p>
<p class='content-link'><a href='#UsewithWebServices'>3.11&nbsp;-&nbsp;Use with Web Services</a></p>

</ul>

<a name='contents'></a>
<!--NoNum--><h1>Contents</h1>
<ul>
<p class="content-link"><a href='#Orientation'>1&nbsp;-&nbsp;Orientation</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#WhatisLMX'>1.1&nbsp;-&nbsp;What is LMX?</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#BenefitsofUsingLMX'>1.2&nbsp;-&nbsp;Benefits of Using LMX</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#DownloadInstallation'>1.3&nbsp;-&nbsp;Download & Installation</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#EvaluatingLMX'>1.4&nbsp;-&nbsp;Evaluating LMX</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#ASimpleExample'>1.5&nbsp;-&nbsp;A Simple Example</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#LicensingPurchase'>1.6&nbsp;-&nbsp;Licensing & Purchase</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#VersionHistory'>1.7&nbsp;-&nbsp;Version History</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#SupportedXMLSchemaFeatures'>1.8&nbsp;-&nbsp;Supported XML Schema Features</a></p>
<p class="content-link"><a href='#QuickStart'>2&nbsp;-&nbsp;Quick Start</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#CodeGeneration'>2.1&nbsp;-&nbsp;Code Generation</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CodeGenerationUsingtheWindowsInterface'>2.1.1&nbsp;-&nbsp;Code Generation Using the Windows Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CodeGenerationUsingtheWindowsDOSCommandLineVersion'>2.1.2&nbsp;-&nbsp;Code Generation Using the Windows (DOS) Command Line Version</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CodeGenerationUsingtheLinuxCommandLineVersion'>2.1.3&nbsp;-&nbsp;Code Generation Using the Linux Command Line Version</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#CCompilingandLinking'>2.2&nbsp;-&nbsp;C++ Compiling and Linking</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CompilingtheRuntimeSupportingSoftwareSourceCode'>2.2.1&nbsp;-&nbsp;Compiling the Runtime Supporting Software Source Code</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CompilingtheGeneratedCode'>2.2.2&nbsp;-&nbsp;Compiling the Generated Code</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CompilingYourCodetoUseLMXCode'>2.2.3&nbsp;-&nbsp;Compiling Your Code to Use LMX Code</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#Marshalingsimpleform'>2.4&nbsp;-&nbsp;Marshaling (simple form)</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AccesingtheDataintheGeneratedClasses'>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SingularEmptyTypeCInterface'>2.5.1&nbsp;-&nbsp;Singular Empty Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#OptionalEmptyTypeCInterface'>2.5.2&nbsp;-&nbsp;Optional Empty Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SingularSimpleTypeCInterface'>2.5.3&nbsp;-&nbsp;Singular Simple Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#OptionalSimpleTypeCInterface'>2.5.4&nbsp;-&nbsp;Optional Simple Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultipleSimpleTypeandListSimpleTypeCInterface'>2.5.5&nbsp;-&nbsp;Multiple Simple Type and List Simple Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultipleSimpleTypeUsageExamples'>2.5.5.1&nbsp;-&nbsp;Multiple Simple Type Usage Examples</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SingularComplexTypeCInterface'>2.5.6&nbsp;-&nbsp;Singular Complex Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SingularComplexTypeUsageExamples'>2.5.6.1&nbsp;-&nbsp;Singular Complex Type Usage Examples</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#OptionalComplexTypeCInterface'>2.5.7&nbsp;-&nbsp;Optional Complex Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#OptionalComplexTypeUsageExamples'>2.5.7.1&nbsp;-&nbsp;Optional Complex Type Usage Examples</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultipleComplexTypeCInterface'>2.5.8&nbsp;-&nbsp;Multiple Complex Type C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultipleComplexTypeUsageExamples'>2.5.8.1&nbsp;-&nbsp;Multiple Complex Type Usage Examples</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultiplexsanyAttributeCInterface'>2.5.9&nbsp;-&nbsp;Multiple xs:anyAttribute C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SingularxsanyCInterface'>2.5.10&nbsp;-&nbsp;Singular xs:any C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#OptionalxsanyCInterface'>2.5.11&nbsp;-&nbsp;Optional xs:any C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultiplexsanyCInterface'>2.5.12&nbsp;-&nbsp;Multiple xs:any C++ Interface</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#AdditionalPolymorphicMethods'>2.5.13&nbsp;-&nbsp;Additional Polymorphic Methods</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#FindingtheIdentityofaPolymorphicClass'>2.5.13.1&nbsp;-&nbsp;Finding the Identity of a Polymorphic Class</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#PolymorphicCloning'>2.5.13.2&nbsp;-&nbsp;Polymorphic Cloning</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ResettingtheClass'>2.5.14&nbsp;-&nbsp;Resetting the Class</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#RuntimeChecking'>2.5.15&nbsp;-&nbsp;Run-time Checking</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#TheAbbreviatedTypeNotation'>2.6&nbsp;-&nbsp;The Abbreviated Type Notation</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#AbbreviatedTypeNotationExamples'>2.6.1&nbsp;-&nbsp;Abbreviated Type Notation Examples</a></p>
<p class="content-link"><a href='#InMoreDepth'>3&nbsp;-&nbsp;In More Depth</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#Configurationusinglmxuserh'>3.1&nbsp;-&nbsp;Configuration using lmxuser.h</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#Unmarshalingadvancedforms'>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#UnmarshalingwithAdditionalControlwhenReadingXMLInput'>3.2.1&nbsp;-&nbsp;Unmarshaling with Additional Control when Reading XML Input</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#UnmarshallingMultipleXMLInstancesfromtheSameSource'>3.2.2&nbsp;-&nbsp;Unmarshalling Multiple XML Instances from the Same Source</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CheckingfortrailingnonXMLmaterial'>3.2.3&nbsp;-&nbsp;Checking for trailing non-XML material</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#UnmarshallingSchemaFragments'>3.2.4&nbsp;-&nbsp;Unmarshalling Schema Fragments</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#UnmarshallingaSubelementwithinanXMLInstance'>3.3&nbsp;-&nbsp;Unmarshalling a Sub-element within an XML Instance</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#UnmarshallingMultipleSubelementswithinanXMLInstance'>3.4&nbsp;-&nbsp;Unmarshalling Multiple Sub-elements within an XML Instance</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MarshallingMultipleXMLInstancestotheSameDestination'>3.5.1&nbsp;-&nbsp;Marshalling Multiple XML Instances to the Same Destination</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#SelectingtheInputFileTypeXSDWSDLDTD'>3.6&nbsp;-&nbsp;Selecting the Input File Type (XSD, WSDL, DTD)</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#TheCommandlineandConfigurationFileFormat'>3.7&nbsp;-&nbsp;The Command-line and Configuration File Format</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#CommandlineFlags'>3.8&nbsp;-&nbsp;Command-line Flags</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#ErrorCodes'>3.9&nbsp;-&nbsp;Error Codes</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#Generatingmakefiles'>3.10&nbsp;-&nbsp;Generating makefiles</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#UsewithWebServices'>3.11&nbsp;-&nbsp;Use with Web Services</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#HandlingSOAPMessages'>3.11.1&nbsp;-&nbsp;Handling SOAP Messages</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#HTTPOperationsforWebServices'>3.11.2&nbsp;-&nbsp;HTTP Operations for Web Services</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SOAPMessagetoMessageOperations'>3.11.2.1&nbsp;-&nbsp;SOAP Message to Message Operations</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SOAPObjecttoObjectOperations'>3.11.2.2&nbsp;-&nbsp;SOAP Object to Object Operations</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#SimpleSOAPOperations'>3.11.2.3&nbsp;-&nbsp;Simple SOAP Operations</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#RESTfulOperations'>3.11.2.4&nbsp;-&nbsp;RESTful Operations</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#NamingofMethodsandVariables'>3.12&nbsp;-&nbsp;Naming of Methods and Variables</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AdaptingLMXtoYourEnvironment'>3.13&nbsp;-&nbsp;Adapting LMX to Your Environment</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ModifyingSchemaTypetoCTypeMapping'>3.13.1&nbsp;-&nbsp;Modifying Schema Type to C++ Type Mapping</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ChoosingBetweenWideandNarrowUnicodeStrings'>3.13.1.1&nbsp;-&nbsp;Choosing Between Wide and Narrow Unicode Strings</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#InputOutputConverters'>3.13.1.2&nbsp;-&nbsp;Input/Output Converters</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AugmentingGeneratedClassesWithYourOwnCode'>3.14&nbsp;-&nbsp;Augmenting Generated Classes With Your Own Code</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#DTDsandNamespaces'>3.15&nbsp;-&nbsp;DTDs and Namespaces</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#DebuggingandHandlingErrors'>3.16&nbsp;-&nbsp;Debugging and Handling Errors</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ReportingErrors'>3.16.1&nbsp;-&nbsp;Reporting Errors</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ChangingtheErrorHandlingBehavior'>3.16.2&nbsp;-&nbsp;Changing the Error Handling Behavior</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ConditionalErrorHandling'>3.16.3&nbsp;-&nbsp;Conditional Error Handling</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CollectingDebugErrorInformationwhenusingConvenienceMethods'>3.16.4&nbsp;-&nbsp;Collecting Debug Error Information when using Convenience Methods</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#DebuggingSupport'>3.16.5&nbsp;-&nbsp;Debugging Support</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AddingExternalCharacterSetTranscoders'>3.17&nbsp;-&nbsp;Adding External Character Set Transcoders</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AddingExtraNamespaceInformation'>3.18&nbsp;-&nbsp;Adding Extra Namespace Information</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AddingSchemaLocationInformation'>3.19&nbsp;-&nbsp;Adding Schema Location Information</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#DisablingOutputofXMLNamespaces'>3.20&nbsp;-&nbsp;Disabling Output of XML Namespaces</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AddinganXMLDecltotheXMLoutput'>3.21&nbsp;-&nbsp;Adding an XMLDecl to the XML output</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#HandlingMultipleSchemas'>3.22&nbsp;-&nbsp;Handling Multiple Schemas</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#HandlingMultipleIndependentSchemas'>3.22.1&nbsp;-&nbsp;Handling Multiple Independent Schemas</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultipleSchemasthatShareCommonSchemas'>3.22.2&nbsp;-&nbsp;Multiple Schemas that Share Common Schemas</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#PatternFacetHandlingCustomization'>3.23&nbsp;-&nbsp;Pattern Facet Handling Customization</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#CustomPatternFacetOutputFormatting'>3.24&nbsp;-&nbsp;Custom Pattern Facet Output Formatting</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#XMLOutputFormatCustomization'>3.25&nbsp;-&nbsp;XML Output Format Customization</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#SpecifyingMicroFormats'>3.26&nbsp;-&nbsp;Specifying Micro Formats</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#AllowingUnknownItemsinanXMLInstance'>3.27&nbsp;-&nbsp;Allowing Unknown Items in an XML Instance</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#mustUnderstandComprehensionRequired'>3.28&nbsp;-&nbsp;mustUnderstand / Comprehension Required</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#FindinganXMLInstancesNamespace'>3.29&nbsp;-&nbsp;Finding an XML Instance's Namespace</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#SettingaDecimalValueWithaFloat'>3.30&nbsp;-&nbsp;Setting a Decimal Value With a Float</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#TestFrameworkGeneration'>3.31&nbsp;-&nbsp;Test Framework Generation</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#StrategiesforIncreasingCodeFlexibility'>3.32&nbsp;-&nbsp;Strategies for Increasing Code Flexibility</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#LMXExtensions'>3.33&nbsp;-&nbsp;LMX Extensions</a></p>
<p class="content-link"><a href='#Reference'>4&nbsp;-&nbsp;Reference</a></p>
<p class="content-link">&nbsp;&nbsp;&nbsp;<a href='#LMXCompoundTypes'>4.1&nbsp;-&nbsp;LMX Compound Types</a></p>
</ul>

<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Orientation'></a>
<h1>1&nbsp;-&nbsp;Orientation</h1>
<p>
This section will give you an overview of what LMX does, and describes how to get ready to use LMX, including how to install and license LMX.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='WhatisLMX'></a>
<h2>1.1&nbsp;-&nbsp;What is LMX?</h2>
<p>
LMX is a W3C XML Schema to C++ code generator.  It takes a W3C XML Schema and generates C++ code that allows you to read and write XML conforming to the Schema by interacting with the C++ classes/objects generated by the tool.
<p>
It is primarily intended to be used in data oriented applications, but can also be used in document oriented applications.
<p>
The code generator runs on a Windows or Linux PC, but the output is generated in C++ source code that is portable to most platforms that support C++ templates and basic STL containers.  (<a href='mailto:support@xml2cpp.com'>Contact us</a> if the generated code does not run on your platform.)
<p>
The code generator comes with its own lightweight XML pull parser and uses C++ ostreams for output.  Thus it is a complete XML solution that does not require additional components in order to interact with XML data.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='BenefitsofUsingLMX'></a>
<h2>1.2&nbsp;-&nbsp;Benefits of Using LMX</h2>
<ul>
<li>Quick and easy to manipulate XML data.
<p>
<li>Knowledge of XML and XML Schema not required - You can simply use the documentation in the generated header file.
<p>
<li>The names of variables are checked at compile time - Simple typos in names are detected automatically and early.
<p>
<li>No programming of tedious state code as required with SAX (and StAX) - LMX does all that in a couple of seconds (or less!)
<p>
<li>Beneficial for both small and large schema.
<p>
<li>Easy to implement web services.
<p>
<li>Can read and generate XML fragments.
<p>
<li>Simple to use - A minimal number of source files so that you don't need to spend time managing code.
<p>
<li>Data types can be customized using C++ language syntax - No need to learn complex code generator configuration options, and less chance of introducing accidental differences between builds by using the wrong configuration.  (See table below.)
<p>
<li>Support for SOAP 'mustUnderstand' attribute detection.
<p>
<li>Easy to switch between wide character strings and 'narrow' character strings.
<p>
<li>Exception safe design.
<p>
<li>Portable code - Run on different platforms.  Even build and test on one platform and run on another.
<p> 
</ul>

<a name='Download_Installation'></a>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='DownloadInstallation'></a>
<h2>1.3&nbsp;-&nbsp;Download & Installation</h2>
<p>
You can download the LMX code generator via <a href='http://www.codalogic.com/lmx/download.php#licensed'>http://www.codalogic.com/lmx/download.php#licensed</a>.
<p>
To install on Windows simply run the installation program in the usual way.
<p>
On Linux, after extracting the file from the tarball you can either manually copy the files to appropriate locations or use the <code>install.pl</code> script to install LMX.  The latter can be used in interactive and non-interactive mode.  For an interactive install, simply execute the script in a terminal window, for example:
</p>
<ul>
	<code>./install.pl</code>
</ul>
<p>
To enable a non-interactive install you can save the settings you want to use in a configuration file, an example of which is:
<pre>
    # This is a comment
    bin=/usr/local/bin
    include=/usr/local/include/lmx-$version
    lib32_static=/usr/local/lib/lmx-$version
    lib32_shared=/usr/lib
    lib64_static=/usr/local/lib64/lmx-$version
    lib64_shared=/usr/lib64
    doc=~/lmx/lmx-$version/doc
    src=~/lmx/lmx-$version/src
    examples=
    license_ok=yes
</pre>
<p>
Each specification has the form:
</p>
<ul>
&lt;category>=&lt;install path>
</ul>
<p>
There should be no leading white-space on a line.  Comments may be preceded by a <code>#</code> character.  Blank lines and lines that contain all white-space are ignored.
<p> 
Any occurrence of the string <code>$version</code> will be replaced with the value of the LMX version you are installing.  If an installation variable is set to the empty string (such as <code>examples</code> shown above) then that category of items will not be installed.  The script will ask you for any values that are not specified.
<p>
If the configuration settings are stored in a file such as <code>my-install-info.txt</code>, then installation using those settings can be invoked using the command:
</p>
<ul>
	<code>./install.pl -f my-install-info.txt</code>
</ul>
<p>
A simple way to create a configuration file is to do an interactive install and tell the script to save the results.  This can be done by doing:
</p>
<ul>
	<code>./install.pl -o my-install-info.txt</code>
</ul>
<p>
You can operate the code generator with limited functionality for evaluation purposes without obtaining a license.
</p>
</pre>

<a name='Evaluation'></a>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='EvaluatingLMX'></a>
<h2>1.4&nbsp;-&nbsp;Evaluating LMX</h2>
<p>
To help with evaluation, LMX comes with a Windows based Evaluation Support Suite.  This is a separate installation packaged as part of the main installation.  The Evaluation Support Suite can be installed during the main LMX installation, or it can be installed at a later time by executing the Evaluation Support Suite installation from the LMX folder on the Windows Start menu.
<p>
Additional information about the Evaluation Support Suite can be found in the LMX folder on the Windows Start menu.
<p>
If you have your own schema and example XML instances, LMX can generate a simple test framework.  This consists of an additionally generated C++ file that exercises the main generated code.  The test framework code unmarshals an XML instance from a file, does a deep copy to a new set of objects, and then marshals the result out as XML to a new file.  You can then visually compare the original and generated files.  To use this feature, check the "Generate Test Framework File" box on the "Options" tab of WinLMX (or specify the <code>-tframework</code> flag on the command-line versions).
<p>
If you would like to see examples of how to use the generated code, then the generated copy constructors (of the form <code>c_myClass::c_myClass( const c_myClass & rhs )</code>) provide convenient examples.
<p>
A worked example is also available at <a href='http://www.codalogic.com/lmx/examples.php'>http://www.codalogic.com/lmx/examples.php</a> to further help with the evaluation process.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ASimpleExample'></a>
<h2>1.5&nbsp;-&nbsp;A Simple Example</h2>
<p>
We present here a simple example of the sort of code you'll write to use the LMX generated C++ code.  While short, the example does illustrate the majority of the aspects of using LMX generated code.  We first present the schema used by LMX to generate the code.  In this case the generated code is stored in the files <code>po.h</code> and <code>po.cpp</code>.  This is followed by an example XML instance for the schema.  Finally, the code used to interface to the LMX generated classes is shown.  
<p>
We have not included a description of this example, other than the comments that appear in the code.  (Full documentation on how to interface with LMX generated code appears in <a href='#AccesingtheDataintheGeneratedClasses'>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</a>.)  You should find however that this example is straightforward and intuitive to understand, demonstrating that it is easy to learn how to use LMX.  This makes your code faster to develop and easier to understand.
<p>
Example code similar to this can be found in the <code>examples</code> sub-directory of the installation or at <a href='http://www.codalogic.com/lmx/lmx-example.zip'>http://www.codalogic.com/lmx/lmx-example.zip</a>.
<p>
The schema:
<pre class='xml'>
    &lt;<span class='xtag'>xsd:schema</span> <span class='xattr'>xmlns:xsd</span>="http://www.w3.org/2001/XMLSchema">

    &lt;<span class='xtag'>xsd:annotation</span>>
    &lt;<span class='xtag'>xsd:documentation</span> <span class='xattr'>xml:lang</span>="en">
    Purchase order schema for Example.com.
    Copyright 2000 Example.com. All rights reserved.
    &lt;/<span class='xtag'>xsd:documentation</span>>
    &lt;/<span class='xtag'>xsd:annotation</span>>

    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="purchaseOrder" <span class='xattr'>type</span>="PurchaseOrderType"/>

    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="comment" <span class='xattr'>type</span>="xsd:string"/>

    &lt;<span class='xtag'>xsd:complexType</span> <span class='xattr'>name</span>="PurchaseOrderType">
    &lt;<span class='xtag'>xsd:sequence</span>>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="shipTo" <span class='xattr'>type</span>="USAddress"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="billTo" <span class='xattr'>type</span>="USAddress"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>ref</span>="comment" <span class='xattr'>minOccurs</span>="0"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="items"  <span class='xattr'>type</span>="Items"/>
    &lt;/<span class='xtag'>xsd:sequence</span>>
    &lt;<span class='xtag'>xsd:attribute</span> <span class='xattr'>name</span>="orderDate" <span class='xattr'>type</span>="xsd:date"/>
    &lt;/<span class='xtag'>xsd:complexType</span>>

    &lt;<span class='xtag'>xsd:complexType</span> <span class='xattr'>name</span>="USAddress">
    &lt;<span class='xtag'>xsd:sequence</span>>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="name"   <span class='xattr'>type</span>="xsd:string"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="street" <span class='xattr'>type</span>="xsd:string"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="city"   <span class='xattr'>type</span>="xsd:string"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="state"  <span class='xattr'>type</span>="xsd:string"/>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="zip"    <span class='xattr'>type</span>="xsd:decimal"/>
    &lt;/<span class='xtag'>xsd:sequence</span>>
    &lt;<span class='xtag'>xsd:attribute</span> <span class='xattr'>name</span>="country" <span class='xattr'>type</span>="xsd:NMTOKEN"
        <span class='xattr'>fixed</span>="US"/>
    &lt;/<span class='xtag'>xsd:complexType</span>>

    &lt;<span class='xtag'>xsd:complexType</span> <span class='xattr'>name</span>="Items">
    &lt;<span class='xtag'>xsd:sequence</span>>
    &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="item" <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded">
        &lt;<span class='xtag'>xsd:complexType</span>>
        &lt;<span class='xtag'>xsd:sequence</span>>
        &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="productName" <span class='xattr'>type</span>="xsd:string"/>
        &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="quantity">
        &lt;<span class='xtag'>xsd:simpleType</span>>
            &lt;<span class='xtag'>xsd:restriction</span> <span class='xattr'>base</span>="xsd:positiveInteger">
            &lt;<span class='xtag'>xsd:maxExclusive</span> <span class='xattr'>value</span>="100"/>
            &lt;/<span class='xtag'>xsd:restriction</span>>
        &lt;/<span class='xtag'>xsd:simpleType</span>>
        &lt;/<span class='xtag'>xsd:element</span>>
        &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="USPrice"  <span class='xattr'>type</span>="xsd:decimal"/>
        &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>ref</span>="comment"   <span class='xattr'>minOccurs</span>="0"/>
        &lt;<span class='xtag'>xsd:element</span> <span class='xattr'>name</span>="shipDate" <span class='xattr'>type</span>="xsd:date" <span class='xattr'>minOccurs</span>="0"/>
        &lt;/<span class='xtag'>xsd:sequence</span>>
        &lt;<span class='xtag'>xsd:attribute</span> <span class='xattr'>name</span>="partNum" <span class='xattr'>type</span>="SKU" <span class='xattr'>use</span>="required"/>
        &lt;/<span class='xtag'>xsd:complexType</span>>
    &lt;/<span class='xtag'>xsd:element</span>>
    &lt;/<span class='xtag'>xsd:sequence</span>>
    &lt;/<span class='xtag'>xsd:complexType</span>>

    &lt;!-- Stock Keeping Unit, a code for identifying products -->
    &lt;<span class='xtag'>xsd:simpleType</span> <span class='xattr'>name</span>="SKU">
    &lt;<span class='xtag'>xsd:restriction</span> <span class='xattr'>base</span>="xsd:string">
    &lt;<span class='xtag'>xsd:pattern</span> <span class='xattr'>value</span>="\d{3}-[A-Z]{2}"/>
    &lt;/<span class='xtag'>xsd:restriction</span>>
    &lt;/<span class='xtag'>xsd:simpleType</span>>

    &lt;/<span class='xtag'>xsd:schema</span>>
</pre>

<p>
An XML Instance:
<pre class='xml'>
    &lt;?<span class='xtag'>xml</span> <span class='xattr'>version</span>='1.0'?>
    &lt;<span class='xtag'>purchaseOrder</span> <span class='xattr'>orderDate</span>='1999-10-20'>
        &lt;<span class='xtag'>shipTo</span> <span class='xattr'>country</span>='US'>
            &lt;<span class='xtag'>name</span>>Alice Smith&lt;/<span class='xtag'>name</span>>
            &lt;<span class='xtag'>street</span>>123 Maple Street&lt;/<span class='xtag'>street</span>>
            &lt;<span class='xtag'>city</span>>Mill Valley&lt;/<span class='xtag'>city</span>>
            &lt;<span class='xtag'>state</span>>CA&lt;/<span class='xtag'>state</span>>
            &lt;<span class='xtag'>zip</span>>90952&lt;/<span class='xtag'>zip</span>>
        &lt;/<span class='xtag'>shipTo</span>>
        &lt;<span class='xtag'>billTo</span> <span class='xattr'>country</span>='US'>
            &lt;<span class='xtag'>name</span>>Robert Smith&lt;/<span class='xtag'>name</span>>
            &lt;<span class='xtag'>street</span>>8 Oak Avenue&lt;/<span class='xtag'>street</span>>
            &lt;<span class='xtag'>city</span>>Old Town&lt;/<span class='xtag'>city</span>>
            &lt;<span class='xtag'>state</span>>PA&lt;/<span class='xtag'>state</span>>
            &lt;<span class='xtag'>zip</span>>95819&lt;/<span class='xtag'>zip</span>>
        &lt;/<span class='xtag'>billTo</span>>
        &lt;<span class='xtag'>comment</span>>Hurry, my lawn is going wild!&lt;/<span class='xtag'>comment</span>>
        &lt;<span class='xtag'>items</span>>
            &lt;<span class='xtag'>item</span> <span class='xattr'>partNum</span>='872-AA'>
                &lt;<span class='xtag'>productName</span>>Lawnmower&lt;/<span class='xtag'>productName</span>>
                &lt;<span class='xtag'>quantity</span>>1&lt;/<span class='xtag'>quantity</span>>
                &lt;<span class='xtag'>USPrice</span>>148.95&lt;/<span class='xtag'>USPrice</span>>
                &lt;<span class='xtag'>comment</span>>Confirm this is electric&lt;/<span class='xtag'>comment</span>>
            &lt;/<span class='xtag'>item</span>>
            &lt;<span class='xtag'>item</span> <span class='xattr'>partNum</span>='926-AA'>
                &lt;<span class='xtag'>productName</span>>Baby Monitor&lt;/<span class='xtag'>productName</span>>
                &lt;<span class='xtag'>quantity</span>>1&lt;/<span class='xtag'>quantity</span>>
                &lt;<span class='xtag'>USPrice</span>>39.98&lt;/<span class='xtag'>USPrice</span>>
                &lt;<span class='xtag'>shipDate</span>>1999-05-21&lt;/<span class='xtag'>shipDate</span>>
            &lt;/<span class='xtag'>item</span>>
        &lt;/<span class='xtag'>items</span>>
    &lt;/<span class='xtag'>purchaseOrder</span>>
</pre>
<p>
And the example code to read the instance:
<pre class='code'>
    #include &lt;iostream>      <span class='ccom'>// For std::cout etc.</span>
    #include "po.h"          <span class='ccom'>// Generated by LMX</span>
    #include "lmxparse.h"    <span class='ccom'>// For the LMX parser</span>

    <span class='ckw'>int</span> main()
    {
        <span class='ccom'>// Allocate a place to store the an error code returned by</span>
        <span class='ccom'>// the unmarshaling operation.</span>
        lmx::elmx_error l_error;

        <span class='ccom'>// c_root is the class generated by LMX that will store the </span>
        <span class='ccom'>// unmarshalled XML.  This constructor unmarshals the data</span>
        <span class='ccom'>// stored in the file "po.xml" and places any error code in</span>
        <span class='ccom'>// l_error.</span>
        c_root l_po( "po.xml", &l_error );

        <span class='ckw'>if</span>( l_error != lmx::ELMX_OK )
        {
            std::cout &lt;&lt; "An error occurred while reading XML\n";
            <span class='ckw'>return</span> 0;
        }

        <span class='ccom'>// Or we could have done:</span>
        <span class='ccom'>// c_root l_po;</span>
        <span class='ccom'>// lmx::elmx_error l_error = l_po.unmarshal( "po.xml" );</span>
        <span class='ccom'>// if( l_error ...</span>

        <span class='ccom'>// Interrogate the parsed XML</span>
        <span class='ccom'>//---------------------------</span>
        <span class='ckw'>if</span>( l_po.getchosen() == c_root::e_purchaseOrder )
        {
            <span class='ccom'>// Make some intermediate variables so that components are </span>
            <span class='ccom'>// easier to reference</span>
            <span class='ckw'>const</span> c_PurchaseOrderType *lp_pot = &amp;l_po.get_purchaseOrder();

            <span class='ckw'>if</span>( lp_pot->isset_orderDate() )    <span class='ccom'>// If the orderDate is set...</span>
            {
                std::cout &lt;&lt; "Ordered on: " &lt;&lt; 
                        lp_pot->get_orderDate() &lt;&lt; "\n";

                <span class='ckw'>if</span>( lp_pot->get_orderDate().get_year() &lt;= 2000 )
                    std::cout &lt;&lt; 
                        "This was ordered last century - It is now overdue!\n";
            }

            <span class='ccom'>// Reference another part of the data structure</span>
            <span class='ckw'>const</span> c_Items *lp_items = &amp;lp_pot->get_items();
            
            <span class='ckw'>float</span> l_total_cost = 0;

            <span class='ccom'>// Print the total number of items</span>
            std::cout &lt;&lt; "Number of items = " &lt;&lt; 
                    lp_items->size_item() &lt;&lt; "\n";

            <span class='ccom'>// Print out some information about each order item</span>
            <span class='ckw'>for</span>( size_t l_i=0; l_i&lt;lp_items->size_item(); ++l_i )
            {
                std::cout &lt;&lt; "Item " &lt;&lt; 
                    (l_i + 1) &lt;&lt; ": " &lt;&lt; 
                    lp_items->get_item( l_i ).get_quantity() &lt;&lt; 
                    " off - " &lt;&lt;
                    lmx::as_ascii( lp_items->get_item( l_i ).get_productName() ) &lt;&lt;
                    " (" &lt;&lt; 
                    lmx::as_ascii( lp_items->get_item( l_i ).get_partNum() ) &lt;&lt; ")";

                <span class='ccom'>// The comment is optional, so only print it out if it is present</span>
                <span class='ckw'>if</span>( lp_items->get_item( l_i ).isset_comment() )
                    std::cout &lt;&lt; " [" &lt;&lt; 
                    lmx::as_ascii( lp_items->get_item( l_i ).get_comment() ) &lt;&lt; "]";

                std::cout &lt;&lt; " - $" &lt;&lt; 
                    lp_items->get_item( l_i ).get_USPrice() &lt;&lt; "\n";
                
                l_total_cost +=
                    lp_items->get_item( l_i ).get_USPrice().get_scaled( 2 );
            }

            std::cout &lt;&lt; "Total Cost: $" &lt;&lt; l_total_cost/100 &lt;&lt; "\n";

            std::cout &lt;&lt; "Ship to: " &lt;&lt; 
                    lmx::as_ascii( lp_pot->get_shipTo().get_name() ) &lt;&lt; "\n";
            std::cout &lt;&lt; "Bill to: " &lt;&lt; 
                    lmx::as_ascii( lp_pot->get_billTo().get_name() ) &lt;&lt; "\n";
            std::cout &lt;&lt; "\n";


            <span class='ccom'>// Modify the XML</span>
            <span class='ccom'>//---------------</span>
            c_root l_alt_po( l_po );    <span class='ccom'>// We don't actually need to create </span>
                                        <span class='ccom'>// a new instance before modifying</span>

            l_alt_po.get_purchaseOrder().get_items().append_item();
            c_Items::c_item *lp_item =
                    &amp;l_alt_po.get_purchaseOrder().get_items().back_item();

            lp_item->set_productName( L"Fence" );
            lp_item->set_quantity( 2 );
            lp_item->set_partNum( L"100-AB" );
            lp_item->set_USPrice( lmx::c_decimal( 12.95, 2U ) );

            <span class='ccom'>// We can also do:</span>
            <span class='ccom'>// lp_item->set_USPrice( 12.95 );  // Although the schema needs to </span>
            <span class='ccom'>//                                 // specify the fraction digits</span>
            <span class='ccom'>//                                 // facet in order to get the number </span>
            <span class='ccom'>//                                 // of decimal places correct!</span>
            <span class='ccom'>// lp_item->set_USPrice( lmx::c_decimal( 1295, 2 ) );</span>
            <span class='ccom'>//                                 // e.g. 1295 / (10^2)</span>
            <span class='ccom'>// lp_item->set_USPrice( "12.95" );</span>

            lp_item->set_comment( L"Will this stop the baby getting on the lawn?" );
            
            assert( lp_item->is_occurs_ok() );  <span class='ccom'>// Check sufficient elements and </span>
                                                <span class='ccom'>// attributes added</span>


            <span class='ccom'>// Write the modified version of the XML to the file po-out.xml</span>
            <span class='ccom'>//-------------------------------------------------------------</span>
            <span class='ckw'>if</span>( l_alt_po.marshal( "po-out.xml" ) == lmx::ELMX_OK )
                std::cout &lt;&lt; "Modified XML written successfully\n";
            <span class='ckw'>else</span>
                std::cout &lt;&lt; "Error writing Modified XML\n";
        }

        <span class='ckw'>return</span> 0;
    }
</pre>


<a name='Licensing'></a>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='LicensingPurchase'></a>
<h2>1.6&nbsp;-&nbsp;Licensing & Purchase</h2>
<p>
For the purposes of evaluation, the LMX code generator can be used in a restricted mode without a license.  In the restricted mode, the code generator limits the number of XML objects that it will compile.
<p>
To fully use the product a license file must be acquired.  This will be e-mailed to you when you purchase a license.  
<p>
To purchase a license, follow the links and instructions for purchasing at: <a href='http://www.codalogic.com/lmx/' target=_blank>http://www.codalogic.com/lmx/</a>
<p>
When using a Windows version of LMX the license file can be placed in the same folder as the <code>lmx.exe</code>/<code>winlmx.exe</code> executable (by default, <code>C:\Program Files\LMX</code> on 32-bit systems and <code>C:\Program Files (x86)\LMX</code> on 64-bit systems), or in the folder specified by the <code>HKEY_CURRENT_USER\Software\Codalogic\LMX\dir</code> registry key.
<p>
On Linux (and other Unix versions) you can either place the license file in one of the following directories; <code>$HOME/.linmx</code>, <code>$HOME/.settings/codalogic/linmx</code>, <code>$HOME/.config/codalogic/linmx</code>, or <code>$HOME/.codalogic/linmx</code>; or in an alternate directory specified by setting and exporting the <code>LMXDIR</code> shell environment variable with the name of the directory containing the license file (possibly in your login script such as .bash_profile).  For example:-
<ul>
LMXDIR=$HOME/lmx<br>
export LMXDIR
</ul>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='VersionHistory'></a>
<h2>1.7&nbsp;-&nbsp;Version History</h2>

<u>7.4</u>
<ul>
<li>Tested on VS2019 and g++ 9.1.0.
<li>Support g++ -Wextra and -pedantic flags.
<li>Added <code>on_lmx_copy_construct()</code>, <code>on_lmx_swap()</code> and <code>on_lmx_eq()</code> snippet event handlers.  See <a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a>.
<li>Added <code>c_xml_reader_string</code> and <code>c_xml_reader_any_info</code> classes.
<li>Added <code>c_xml_reader::add_namespace_mappings( const c_any_info & )</code> and <code>c_xml_reader::add_namespace_mappings( const c_namespace_context & )</code>.
<li>Added <code>c_xml_reader::is_xml_end()</code> method. See <a href='#CheckingfortrailingnonXMLmaterial'>3.2.3&nbsp;-&nbsp;Checking for trailing non-XML material</a>.
<li>Updated regular expression code.
</ul>

<u>7.3</u>
<ul>
<li>Added support for C++11 range-based for loops, allowing code of the form: <code>for( auto & i : top.in_NAME() )</code>.  See <a href='#MultipleSimpleTypeandListSimpleTypeCInterface'>2.5.5&nbsp;-&nbsp;Multiple Simple Type and List Simple Type C++ Interface</a> and similar sections for more details.  Also added <code>-prefix-in</code> flag.
<li>Added <code>on_lmx_alt_unmarshal_xs_any()</code> snippet event handler.  See <a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a>.
<li>Various enums are given explicit values to make debugging easier.
<li>Introduced LMX_FLOAT_PRECISION, LMX_DOUBLE_PRECISION and LMX_FLOAT_HIGH_PRECISION defines to allow user to select precision when converting floating point values to text representation.
<li>Added c_xml_reader::extract_namespace_context() method.
<li>Modified relationship of operator<<( ..., c_as_xml<T>)
and output_convert_to_xml<T>(), so that providing specialisations of
operator<<( ..., c_as_xml<T>) can act as a customisation point.
<li>Added <code>-#define</code> flag.
<li>Added <code>-lmxuser-defs</code> and <code>-lmxuser-defs-end</code> flags.
</ul>

<u>7.2</u>
<ul>
<li>Added testing on VS 2015, VS 2017, g++ 5.4.0, g++ 6.3.0 and g++ 7.1.0</li>
<li>Added <code>c_xml_writer::set_convenience_options()</code> and <code>c_xml_writer::get_convenience_options()</code> to enable ability to configure whether XMLDecl and 'standalone' are output when marshalling using the convenience methods. See <a href='#AddinganXMLDecltotheXMLoutput'>3.21&nbsp;-&nbsp;Adding an XMLDecl to the XML output</a>.</li>
<li>Corrected default whitespace handling of xs:token and xs:normalizedString and their derived types.</li>
<li>On a list type, calling clear_NAME() now marks a list as present.</li>
<li>Added <code>-fname-sep</code> flag to specify separator character sequence for constructed file names.</li>
<li>Added better support for using command-line wildcards to specify input XSD files.</li>
<li>Added <code>-method-getid</code> and <code>-method-has_id</code> flags.</li>
<li>Implemented <code>on_lmx_unmarshal_outer_start()</code> and <code>on_lmx_unmarshal_outer_end()</code> snippet event hanlders.</li>
<li>Added operator << ( std::ostream &, const c_binary & ) to facilitate output of raw binary data.</li>
<li>Enhanced <code>s_debug_error</code> to allow customized descriptions for LMX error codes allocated for user defined purposes. See <a href='#CollectingDebugErrorInformationwhenusingConvenienceMethods'>3.16.4&nbsp;-&nbsp;Collecting Debug Error Information when using Convenience Methods</a>.</li>
</ul>

<u>7.1</u>
<ul>
<li>Virtual methods added to <code>c_xml_reader</code> to allow conditional acceptance / rejection of unknown attributes and elements in auto-versioning modes.  See <a href='#AllowingUnknownItemsinanXMLInstance'>3.27&nbsp;-&nbsp;Allowing Unknown Items in an XML Instance</a> for more details.</li>
<li>Modifications to allow for C++11 deprecation of <code>std::auto_ptr</code>.</li>
<li>Added methods <code>c_binary::get_as_hex_string()</code> and <code>c_binary::get_as_base64_string()</code>.</li>
<li>Enhanced support for non-C locales for converting strings to <code>xs:float</code> values.</li>
<li>Added <code>DECIMAL_INIT_MODE</code> section to <code>lmxuser.h</code> to allow choice between initialising <code>xs:decimal</code> values using C++ strings or doubles.</li>
<li>Added <code>lmx_assert_is_occurs_ok()</code> macro to allow user control of what happens if insufficient items are present for marshalling.</li>
<li>Fixed application of pattern facets to a whole <code>xs:list</code> construct as opposed to its individual members.</li>
<li>Use of <code>ptrdiff_t</code> fixed to <code>std::ptrdiff_t</code>.
</ul>

<u>7</u>
<ul>
<li>To accommodate the increasing number of versions of Visual Studio and GCC we have decided to only ship the source code for the Runtime Supporting Software and allow users to create their own binaries for this code.  This allows greater user flexibility and complete cross-platform solutions.
<li>Added ability to install external character transcoders. See <a href='#AddingExternalCharacterSetTranscoders'>3.17&nbsp;-&nbsp;Adding External Character Set Transcoders</a>.</li>
<li>Added the <a href='#flag-expose-storage'/><code>-expose-storage</code></a> option.  This allows writing of more generic code.
<li>Improved handling of serialisation of floating point numbers on non-Windows platforms.</li>
</ul>

<u>6.4</u>
<ul>
<li>Improved formatting of fractional seconds values in times and durations.</li>
<li>is_occurs_ok() method can now collect better debugging information.</li>
<li>Added generation of the check() method, effectively a deep version of the is_occurs_ok() method.</li>
<li>Added <code>-no-check-code</code> flag.</li>
</ul>

<u>6.3</u>
<ul>
<li>The Windows library naming convention has been changed from including the compiler version in the name (e.g. vc11) to the IDE version (e.g. vs2012).</li>
<li>Fixed HTML documentation of attribute cardinality.</li>
<li>Reduced rounding errors when round-tripping float values through c_decimal.</li>
<li>c_binary::operator [] const and at() const now return const unsigned char & to allow the return value to be used in functions like fwrite() etc.</li>
<li>Changed the internal variable naming convention.</li>
<li>Classes that contain binary members now have added a non-const method for accessing the binary member.</li>
</ul>

<u>6.2</u>
<ul>
<li>Added the <a href='#flag-enums-per-type'/><code>-enums-per-type</code></a> flag option to generate separate C++ enums for each schema type that has xs:enumeration facets defined.</li>
<li>Added <a href='#flag-narrow-strings'/><code>-narrow-strings</code></a> flag to generate <code>#define</code>s suitable for instructing C++ compiler to use narrow strings for Unicode strings.</li>
<li>Added <a href='#flag-prefix-enumeration'/><code>-prefix-enumeration</code></a> and <a href='#flag-prefix-enumeration-name'/><code>-prefix-enumeration-name</code></a> to improve control of naming of c++ enumerations associated with <code>xs:enumeration</code> facets.</li>
<li>Added generation of const version of getany_attributes() method.</li>
<li>Added facility to change whether seconds in types containing time are represented using C++ float or double.</li>
<li>Includes binaries for Microsoft VS 2012.</li>
</ul>
<p>

<u>6.1</u>
<ul>
<li>The generated operator == () methods now take into account polymorphism of types.
<li>The generated code has been modified so that try/catch blocks are not required.  Exception safety is maintained.
<li>Added the <code>-prefix-declash</code> flag.  See <a href='#HandlingMultipleIndependentSchemas'>3.22.1&nbsp;-&nbsp;Handling Multiple Independent Schemas</a> for more details.
<li>Fixed Micro Format handling (see <a href='#SpecifyingMicroFormats'>3.26&nbsp;-&nbsp;Specifying Micro Formats</a>) when schema specifies a type to be an <code>xs:list</code> type.
<li>If a project build environment defines <code>LMX_XML_ALWAYS_ESCAPE_GT</code> to be 1 when the <code>lmxtypes.cpp</code> source code is compiled then > will always be escaped to &amp;gt; (Professional Edition required).
</ul>
<p>

<u>6</u>
<ul>
<li>Refactored the interface between the generated objects and the XML parser/writer.
<li>Restored the ability to allow globally stored objects that have string-based default values.
<li>Improved conditional automatic inclusion of xml.xsd namespace attributes.
</ul>
<p>

<u>5.7</u>
<ul>
<li>Improved support for choice of CamelCase or underscore_separated C++ names.  See <code>-naming</code> flag.
</ul>
<p>

<u>5.6</u>
<ul>
<li>Convenience methods now take an optional pointer to an error object to allow capture of enhanced error information.  See <a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a> for more information.
<li>Enhancements have been made to enable better control of attribute layout when formatting.  See <a href='#XMLOutputFormatCustomization'>3.25&nbsp;-&nbsp;XML Output Format Customization</a> for more information.
<li>Some concrete implementations of key template methods have been placed in the binary libraries to reduce the size of binaries on some platforms.
</ul>
<p>

<u>5.5</u>
<ul>
<li>Enhancements to the Annotated XML Example (AXE) parser.
<li>Added <code>-release-switch</code> flag.
<li>Added <code>on_lmx_is_occurs_ok()</code> snippet event handler. (See <a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a>.)
<li>Added generation of <code>assign_XYZ( size_t index, T * p )</code> methods for complexTypes.
<li>Added <code>c_xml_reader::ignore_element(...)</code> method mainly to be used with the <code>on_lmx_alt_unmarshal_element_XYZ()</code> snippet event handler to enable ignoring the contents of elements the user is not interested in.
</ul>
<p>

<u>5.4</u>
<ul>
<li>Added support for specifying the XML data format using <a href='http://codalogic.com/axe'>Annotated XML Example (AXE&trade;)</a> format.
<li>Better support when using empty prefixes for C++ identifiers.
</ul>
<p>

<u>5.3</u>
<ul>
<li>Global setting of the XML output formatting is supported. (See <a href='#XMLOutputFormatCustomization'>3.25&nbsp;-&nbsp;XML Output Format Customization</a>.)
<li>Added <code>on_lmx_alt_unmarshal_attribute_XYZ()</code>, <code>on_lmx_alt_unmarshal_element_XYZ()</code>, <code>on_lmx_alt_marshal_attribute_XYZ()</code> and <code>on_lmx_alt_marshal_element_XYZ()</code> snippet event handlers. (See <a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a>.)
<li>Added the <code>c_xml_writer::disable_ns_map_output()</code> method to disable output of the <code>xmlns</code> namespace attributes.  See <a href='#DisablingOutputofXMLNamespaces'>3.20&nbsp;-&nbsp;Disabling Output of XML Namespaces</a> for more.
<li>Added additional variants of the <code>unmarshal_partial(...)</code> template method.  See <a href='#UnmarshallingSchemaFragments'>3.2.4&nbsp;-&nbsp;Unmarshalling Schema Fragments</a>.
<li>Documented the <code>unmarshal_find()</code> template functions.  See <a href='#UnmarshallingaSubelementwithinanXMLInstance'>3.3&nbsp;-&nbsp;Unmarshalling a Sub-element within an XML Instance</a>.
<li>Refactored internal marshalling and unmarshaling interface to <code>c_xml_writer</code> and <code>c_xml_reader</code>.
</ul>
<p>

<u>5.2</u>
<ul>
<li>Added the <code>-micro-format</code> flag to allow support of micro formats.  See <a href='#SpecifyingMicroFormats'>3.26&nbsp;-&nbsp;Specifying Micro Formats</a>.
<li>Added generation of <code>insert_XYZ( size_t index, T * p )</code> methods for complexTypes.
<li>Added generation of non-const <code>get_XYZ(???)</code> methods for compound simpleTypes such as xs:date and micro formats to enable easier access.
<li>Fixed code generation bug for complexTypes containing fixed simpleContent.
</ul>
<p>

<u>5.1</u>
<ul>
<li>Added the <code>-pattern-out</code> flag to allow specification of custom output converters for data types requiring xs:pattern specific output formatting.  See <a href='#CustomPatternFacetOutputFormatting'>3.24&nbsp;-&nbsp;Custom Pattern Facet Output Formatting</a>.
<li>Changed name of .isset() methods on classes to .is_value_set() to avoid problems when other code defines an isset() macro (e.g. HP aCC).
<li>Corrected handling of decimal number comparisons that contained 0s as final fractional digits.
<li>Add binaries for g++ 4.2.3.
<li>Includes support for Microsoft VS 2010.
<li>Enhanced Linux install.pl script to allow unattended install.
</ul>
<p>

<u>5</u>
<ul>
<li>Re-factored the inner workings of the generated code.  The generated API to use the generated code remains the same.
<li>Some short accessor methods can now be generated inline as part of the class definition rather than in the .cpp file.
<li>Added <code>-max-inline</code> flag.
<li>Added <code>-error-fast</code> flag.
<li>Added <code>-no-local-classes</code> flag.
<li>Updated regex code derived libxml2 2.7.7.
</ul>
<p>

<u>4.2</u>
<ul>
<li>Added improved support for handling and subsequently unmarshalling contents of <code>xs:any</code>.
<li>Added <code>on_lmx_unmarshal_attribute_XYZ()</code> and <code>on_lmx_unmarshal_element_XYZ()</code> snippet event handlers.
<li>Added option to specify the base class of a named class.  See <code>-class-base</code> flag.
<li>Add option to be able to specify C++ include guard string.  See <code>-include-guard</code> flag.
<li>Default C++ include guard text now includes the C++ namespace.
<li>Modified generated code to accommodate GCC version 4.3.3 and 4.4.1. warnings.
<li>Added a Perl based install script (install.pl) for Linux platforms.
</ul>
<p>

<u>4.1</u>
<ul>
<li>Added option to generate equality (and inequality) operators.  See <code>-eq</code> flag.
<li>Added <code>exec-pre-all</code>, <code>exec-post-all</code> and <code>exec-post-all-error</code> flags.
<li>Added option to create a makefile fragment.  See <code>-makefile</code> flag.
<li>Significantly sped up the compile time of some large schemas.
</ul>
<p>

<u>4.0</u>
<ul>
<li>GUI interface for Linux added, called glinmx.
<li><code>-expose-containers</code> flag added, allowing more direct access to the containers (e.g. std::vector) in the objects.
<li>Changed defaulting of <code>LMX_NARROW_URI_STRINGS</code> so that it is defaulted to the value of <code>LMX_NARROW_UNICODE_STRINGS</code> rather than 0.
</ul>
<p>

<u>3.10</u>
<ul>
<li>Enhancements made so that string classes that have different method names to std::basic_string can be used.
<li>Supporting Software and generated code changed so that GCC can be run with the -Wunused-parameter flag without causing warnings.
<li>Wide-string based path names supported in generated convenience methods.
</ul>
<p>

<u>3.9</u>
<ul>
<li>Added the <code>-naming YYY</code> flag which specifies the naming convention to be used for names in the generated code.  If <code>camel</code> is specified, LMX will attempt to convert names generated in the code to CamelCase.  If <code>underscore</code> is specified, LMX will attempt to make names underscore separated.
<li>Added <code>-file-ext-snippets YYY</code> flag.
<li>Reworked the output converters code so that alternative output converters can be more readily used with the Standard Edition of LMX.
<li>WinLMX now automatically checks to see if there are any new versions of LMX available.
</ul>
<p>

<u>3.8</u>
<ul>
<li>Added <code>c_soap</code> and <code>c_winhttp</code> classes to aid implementing web services.  See <a href='#UsewithWebServices'>3.11&nbsp;-&nbsp;Use with Web Services</a> for more information.
<li>Added the ability for users to customize the behavior of generated classes using snippet event handlers.  These call user defined methods during the marshal and unmarshal processes.  See <a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a> for more information.
<li>Added the <code>-alt-xml-reader</code> and <code>-alt-xml-writer</code> flags.  See the flags section for more information.
<li>To provide custom error feedback, primarily for snippet event handlers, the <code>lmx::elmx_error</code> enumeration has had added to it the enumeration values <code>ELMX_USER_DEFINED_1</code> to <code>ELMX_USER_DEFINED_9</code>.  
<li>Added <code>-lmx-include-path</code> flag to allow specifying the directory where the LMX header files are stored.
<li>Added the <code>-check-is-occurs-ok-on-marshal</code> flag.
<li>Added <code>tlmx_uri_string</code> typedef so that URI string can have an independent type to Unicode strings.
<li>Added #ifndef LMX_NO_WSTRING sections to the supporting software source code to allow conditional removal of std::wstring from a build.
</ul>
<p>

<u>3.7.1</u>
<ul>
<li>Fixed handling of hierarchies of substitution groups.
<li>Auto-versioning of substitution groups now has an explicit option.  Previously auto-versioning of substitution groups was the default (but non-standard) behavior.  See <code>-autover-subst-groups</code> flag.
</ul>
<p>

<u>3.7</u>
<ul>
<li>Added options to specify the file extensions of the generated files.  See <code>-file-ext-cpp</code> and <code>-file-ext-h</code> flags.
<li>Added option to specify that the C++ enums associated with schema enumeration facets should be local to a class.  See <code>-local-enums</code> flag.
<li>Added options to specify that documentation from the schema (included in <code>xs:documentation</code> elements) should be output in the .h and/or HTML file.  See <code>-doc-in-h</code> and <code>-doc-in-html</code> flags.
<li>A flag has been added to cause any warnings generated during code generation to return the same program error code returned by errors.  See the <code>-werror</code> flag.
<li>The Windows DLLs now have version information in them.
<li>A bug associated with determining the used XML namespaces has been fixed.
<li>Added option to suppress generation of root class.  See <code>-no-root-class</code> flag.
<li>Added option to not generate code for insert/delete/clear operations on items that can occur more than once.  See <code>-no-container-ops</code> flag.
</ul>
<p>

<u>3.6</u>
<ul>
<li>Added options to specify suffixes to be added to the code names of attributes, elements, types, and groups.  See <code>-suffix-attribute</code>, <code>-suffix-element</code>, <code>-suffix-type</code> and <code>-suffix-group</code> flags.
<li>Corrected handling of <code>xmlns=""</code> idiom according to XML Namespaces 1.1.
<li>Added static <code>debug_error</code> object to aid the debugging process.
<li>Added one .cpp per schema file generation mode.  See <code>-cpp-per-schema</code> flag.
<li>Added ability for developers to augment the generated classes with their own code.  See <code>-snippets</code> flag.
<li>More accurate HTML documentation generation.
</ul>
<p>
<u>3.5</u>
<ul>
<li>Added options to control whether only marshaling or only unmarshaling code is generated.  See flags <code>-no-marshal</code> and <code>-no-unmarshal</code>.
</ul>
<p>
<u>3.4</u>
<ul>
<li>Added polymorphic behavior for XSD extension and restriction types.  Use -no-polymorphic to switch off polymorphic behavior.
</ul>
<p>
<u>3.3</u>
<ul>
<li>Adopted the Windows XP look-and-feel for WinLMX.
<li>Corrected some issues with simpleContent types.
<li>Changed company name.
</ul>
<p>
<u>3.2.5</u>
<ul>
<li>Fixed a dependency issue in the generated C++ code between C++ declarations and definitions for attributes in restricted simple content.
</ul>
<p>
<u>3.2.4</u>
<ul>
<li>Improved support for QNames.
</ul>
<p>
<u>3.2.3</u>
<ul>
<li>Improved support for multiple instances of simple type lists.
<li>Fixed handling of fractional seconds less than 10.0 in time, datetime and duration types.
</ul>
<p>
<u>3.2</u>
<ul>
<li>Further enhancements to WinLMX's method prototype viewing feature made.
<li>Improvements in the way xs:include files are handled.
<li>Corrected handling of multiple occurrences of information items with fixed or default value constraints.
</ul>
<p>
<u>3.1</u>
<ul>
<li>Further enhancements to WinLMX's method prototype viewing feature made.
<li>Fixed an XML namespace handling issue.
<li>Modified c_read_file so that reading XML from files is faster in applications generated with Visual Studio 2005.
<li>Added the ability to set schema location attributes in generated XML.
<li>Formerly the validation of the length facets for xs:string types was only correct if they were mapped to std::wstring.  This has now been corrected so that the validation is correct irrespective of whether the xs:string types are mapped to std::wstring or std::string.
</ul>
<p>
<u>3.0</u>
<ul>
<li>WinLMX enhanced.  The base names of variables and methods can now be edited using the interface.
<li>Editing of a schema can be invoked from WinLMX.
<li>The generated HTML documentation can be displayed from WinLMX.
</ul>
<p>
<u>3.0 Beta</u>
<ul>
<li>XML Parser refactored.
<li>Additional marshal and unmarshal methods generated to make it more convenient to marshal and unmarshal to/from files and memory.
<li>Test framework output (-tframework) simplified.
<li>WinLMX enhanced.
<li>If multiple schemas are treated as global, each such schema has its own XML namespace URI to namespace prefix map.
</ul>
<p>
<u>2.11</u>
<ul>
<li>Nested C++ namespaces can be specified.
<li>Removed use of global_event_map in 'global' unmarshal functions.
<li>Added provision for extension from xs:anyType.
<li>Improved parser efficiency.
<li>User has control over XML namespace prefixes used via -ns-prefix-map command-line flag.
</ul>
<p>
<u>2.10</u>
<ul>
<li>Primarily an upgrade to support the Basic Edition license.
<li>Includes code for VS2005 libraries.
<li>Enforce the "C" locale for string to float conversions in locale aware implementations.
<li>Unicode handling extended beyond the Basic Multi-lingual Plane to full Unicode range (0x-0x10ffff).
<li>Moved position of generated braces!
</ul>
<p>
<u>2.9</u>
<ul>
<li>Improved 'One .h/.cpp file per class' handling.
<li>insert_NAME() methods generated for interfacing with collections.
<li>Mapping of namespace prefix flags supported (see -ns-prefix-map).
<li>Improved mapping of punctuation characters in enumeration identifiers to C++ names.
<li>Unions are no longer anonymous, leading to improved portability on compilers such as HP-UX aCC.
</ul>
<p>
<u>2.8</u>
<ul>
<li>Can specify wide-char file names when opening XML files for reading.
<li>Added string converters for std::string to std::string and std::wstring to std::wstring.  These non-converters make it easier to operate in a environment where _TCHAR type mechanisms are being used.
<li>Added features to help MS IntelliSense.
<li>Added work-arounds for IBM Visual Age Compiler.
</ul>
<p>
<u>2.7</u>
<ul>
<li>Code can be generated from an XML external DTD definition - see <a href='#SelectingtheInputFileTypeXSDWSDLDTD'>3.6&nbsp;-&nbsp;Selecting the Input File Type (XSD, WSDL, DTD)</a>.
<li>A W3C Schema embedded in a WSDL file can be automatically parsed - see <a href='#SelectingtheInputFileTypeXSDWSDLDTD'>3.6&nbsp;-&nbsp;Selecting the Input File Type (XSD, WSDL, DTD)</a>.
<li>Modified header file layout so that it is possible to switch between wide and narrow strings without requiring the supporting software source code.
<li>Fixed a bug in the generated code that did a double memory allocation when calling c_class &get_class( size_t index ), causing a memory leak.
<li>Fixed problem in the generated code when parsing XML instances from schemas that have multiple global elements and have multiple namespaces associated with them.
<li>Added lmx_assert() macro to allow customisation of how assertions are handled.  The macro is currently mapped directly to assert(), but could be modified to allow throwing exceptions in release code if desired.
<li>Character entities in entity definitions are now expanded immediately when first parsing, rather than when the entity text is used.
</ul>
<p>
<u>2.6</u>
<ul>
<li>Modified constructor initialisation order to remove GCC -Wall warnings.
<li>Added at() and get( unsigned char [], size_t ) methods to c_binary.
<li>Added functions to convert between wide and narrow strings (and vice versa).
<li>Added some defaults to switch statements to address compiling with GCC -Wall.
<li>Fixed problem with single quote appearing in attribute values when parsing xs:any elements.
<li>Fixed problem with comments that contained no space after the &lt;!-- sequence and contained a / character (e.g. &lt;!--My comment with / char -->).
</ul>
<p>
<u>2.5</u>
<ul>
<li>Customized naming of methods now supported - see <a href='#NamingofMethodsandVariables'>3.12&nbsp;-&nbsp;Naming of Methods and Variables</a>.
<li>Union simpleType as base of simpleContent now supported.
<li>Improve recording of code generator options in generated code when WinLMX used.
<li>c_xml_reader destructor made virtual and unused variable removed from c_big_int::operator &gt;.
</ul>
<p>
<u>2.4</u>
<ul>
<li>Added -multi-file flag to allow one class per file operation.
<li>WinLMX allows saving of default project settings for easier, more consistent project start up.
<li>Fixed issue with -output-defaults.</ul>
<p>
<u>2.3</u>
<ul>
<li>Added -no-nested-classes flag to allow specifying that nested classes should not be used.
</ul>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SupportedXMLSchemaFeatures'></a>
<h2>1.8&nbsp;-&nbsp;Supported XML Schema Features</h2>
LMX XML C++ Databinder offers industry leading schema feature support for C++ to XML data binding as shown 
in the following table:
<p>
<center>
<table border="1" ID="Table1">
<tr><th>XML Schema Feature</th><th>Supported?</th></tr>
<tr><th colspan="2">Schema Handling</th></tr>
<tr><td>Import</td><td align="center">Yes</td></tr>
<tr><td>Include</td><td align="center">Yes</td></tr>
<tr><td>Redefine</td><td align="center">Yes</td></tr>
<tr><td>Chameleon Design</td><td align="center">Yes</td></tr>
<tr><td>Qualified / Unqualified Elements</td><td align="center">Yes</td></tr>
<tr><td>Qualified / Unqualified Attributes</td><td align="center">Yes</td></tr>
<tr><th colspan="2">Types</th></tr>
<tr><td>Empty Types</td><td align="center">Yes</td></tr>
<tr><td>simpleType</td><td align="center">Yes</td></tr>
<tr><td>complexType / simpleContent</td><td align="center">Yes</td></tr>
<tr><td>complexType / complexContent</td><td align="center">Yes</td></tr>
<tr><td>Nillable</td><td align="center">Yes</td></tr>
<tr><th colspan="2">Simple Types & Facets</th></tr>
<tr><td>All Simple Types Supported</td><td align="center">Yes</td></tr>
<tr><td>Lists</td><td align="center">Yes</td></tr>
<tr><td>Unions</td><td align="center">Partial<sup>1</sup></td></tr>
<tr><td>enumeration</td><td align="center">Yes</td></tr>
<tr><td>Allow reading/writing using enumerated values</td><td align="center">Yes</td></tr>
<tr><td>fractionDigits</td><td align="center">Yes</td></tr>
<tr><td>length</td><td align="center">Yes</td></tr>
<tr><td>maxExclusive</td><td align="center">Yes</td></tr>
<tr><td>maxInclusive</td><td align="center">Yes</td></tr>
<tr><td>minExclusive</td><td align="center">Yes</td></tr>
<tr><td>minInclusive</td><td align="center">Yes</td></tr>
<tr><td>maxLength</td><td align="center">Yes</td></tr>
<tr><td>minLength</td><td align="center">Yes</td></tr>
<tr><td>pattern</td><td align="center">Yes</td></tr>
<tr><td>totalDigits</td><td align="center">Yes</td></tr>
<tr><td>whiteSpace</td><td align="center">Yes</td></tr>
<tr><td>List length facets</td><td align="center">Yes</td></tr>
<tr><td>default values</td><td align="center">Yes</td></tr>
<tr><td>fixed values</td><td align="center">Yes</td></tr>
<tr><td>xs:anyAttribute</td><td align="center">Yes</td></tr>
<tr><td>xs:anyAttribute namespace validation</td><td align="center">Yes</td></tr>
<tr><td>xs:anyType</td><td align="center">Yes</td></tr>
<tr><td>Automatic entity substitution (&amp;amp; etc)</td><td align="center">Yes</td></tr>
<tr><td>Expansion of DTD defined entities</td><td align="center">Yes</td></tr>
<tr><th colspan="2">complexType / complexContent</th></tr>
<tr><td>Sequence</td><td align="center">Yes</td></tr>
<tr><td>Choice</td><td align="center">Yes</td></tr>
<tr><td>All</td><td align="center">Yes</td></tr>
<tr><td>Capture / control order of xs:all</td><td align="center">Yes</td></tr>
<tr><td>Anonymous Compositors</td><td align="center">Yes</td></tr>
<tr><td>xs:any</td><td align="center">Yes</td></tr>
<tr><td>xs:any namespace validation</td><td align="center">Yes</td></tr>
<tr><td>Mixed</td><td align="center">Partial<sup>2</sup></td></tr>
<tr><td>Extension</td><td align="center">Yes</td></tr>
<tr><td>Restriction</td><td align="center">Mostly<sup>3</sup></td></tr>
<tr><td>Polymorphic Extension using xsi:type</td><td align="center">Yes</td></tr>
<tr><td>Polymorphic Restriction using xsi:type</td><td align="center">Yes</td></tr>
<tr><td>Groups</td><td align="center">Yes</td></tr>
<tr><td>Recursive Definitions</td><td align="center">Yes</td></tr>
<tr><th colspan="2">Cardinality</th></tr>
<tr><td>Optional</td><td align="center">Yes</td></tr>
<tr><td>Mandatory</td><td align="center">Yes</td></tr>
<tr><td>Multiple (0-n, 1-n, m-n, m-unbounded etc.)</td><td align="center">Yes</td></tr>
<tr><th colspan="2">Miscellaneous</th></tr>
<tr><td>Attribute Groups</td><td align="center">Yes</td></tr>
<tr><td>Substitution Groups</td><td align="center">Yes</td></tr>
<tr><td>Name clash prevention</td><td align="center">Yes</td></tr>
<tr><td>UTF-8, UTF-16 (BE & LE), UCS2 (BE & LE), ISO-8859-1</td><td align="center">Yes</td></tr>
<tr><td>Generate code from XML external DTDs</td><td align="center">Yes</td></tr>
<tr><td>Generate code from Schemas embedded in WSDL files</td><td align="center">Yes</td></tr>
<tr><td colspan="2"><b>Notes:</b><br>
				<sup>1</sup>All XML schema Union simpleTypes are stored as strings.<br>
				<sup>2</sup>The contents of an XML schema Mixed type is stored as a string, including any additional markup.<br>
				<sup>3</sup>Some corner cases that don't map cleanly to C++, such as an element that has a child element that is restricted by using a type that is a restriction of the original type, are not supported.<br>
				</td></tr>
</table>
</center>


<a name='Quick_Start'></a>
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='QuickStart'></a>
<h1>2&nbsp;-&nbsp;Quick Start</h1>
<p>
Having installed and licensed your LMX product, you will want to generate code.  This section gives a brief introduction to this and will probably be sufficient for the majority of your use of the tool.  For more detailed information, see  section <a href='#InMoreDepth'>3&nbsp;-&nbsp;In More Depth</a>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CodeGeneration'></a>
<h2>2.1&nbsp;-&nbsp;Code Generation</h2>
<p>
The LMX code generator can be run on Windows<sup>&reg;</sup> and Linux platforms.  On the Windows platform LMX is available as both a GUI and a command-line version.
<p>
The generated code is cross-platform.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CodeGenerationUsingtheWindowsInterface'></a>
<h3>2.1.1&nbsp;-&nbsp;Code Generation Using the Windows Interface</h3>
<p>
The Windows<sup>&reg;</sup> Interface version of LMX makes it easy to use the LMX tool.  The Windows version is called WinLMX.
<p>
When you start WinLMX, you will see a window displayed that contains a tabbed dialog.  You can specify what you want WinLMX to do by selecting the various tabs, and completing the dialog items that are displayed.  
<p>
The main aspect of configuration is selecting the files to be compiled, and the names of the output files.  This is configured using the left-most tab labelled 'Schema Files'.  Enter the base schema file in the top-most edit box, and the root of the output files (e.g. 'File' to generate 'File.h' and 'File.cpp') in the bottom-most edit box.  The files that the schema imports should be entered into the middle list box by pressing the associated 'Add...' button.
<p>
LMX can parse both W3C Schema (XSD) and XML (external) DTD files.  LMX can also locate and parse W3C Schema definitions embedded in WSDL files.  The parsing that LMX performs depends on the file extension of the base schema file.  See <a href='#SelectingtheInputFileTypeXSDWSDLDTD'>3.6&nbsp;-&nbsp;Selecting the Input File Type (XSD, WSDL, DTD)</a> for more information.
<p>
When you have completed configuring WinLMX you can save the configuration using the 'File' menu.  
<p>
To generate code for a configuration, press the 'Compile...' button at the bottom of the window.  This will automatically select the 'Compilation Results' tab and display the results of the compilation.
<p>
Note that when a configuration file is loaded into WinLMX, the current working directory is set to the path of the configuration file.  This allows you to specify relative file names for the schema and output files.
<p>
In addition to using the 'File' menu to open configuration files, WinLMX also supports drag and drop.
<p>
The configuration files created by WinLMX can be used by the command-line version of LMX.  This allows you to develop configuration files using the windows version, and use that configuration in your build strategy with the command-line version.  (If the command-line version of LMX is called with a single argument that ends in '.lmxprj' the tool assumes that it is a configuration file.  Alternatively, the '-f' command-line option can be used to specify a configuration file.)
<p>
If WinLMX's default project settings are not suitable for your development environment, configure the settings as you would like them and then select the 'File->Save Default New Project' menu item.  These settings will then be used when a new project is started, or a '.xsd' file is dragged over WinLMX.
<p>
When using a licensed version LMX needs to know the location of the license file.  See <a href='#LicensingPurchase'>1.6&nbsp;-&nbsp;Licensing & Purchase</a> for further information.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CodeGenerationUsingtheWindowsDOSCommandLineVersion'></a>
<h3>2.1.2&nbsp;-&nbsp;Code Generation Using the Windows (DOS) Command Line Version</h3>
<p>
The LMX code generator can be run from a (DOS) command line prompt.  This is useful when LMX is used as part of a batch build process such as a nightly build.
</skip>
The basic command line syntax is:
<pre class='cmd'>
    lmx [flags] primary-xsd-file *[++ additional-global-xsd-file] *[+ additional-library-xsd-file] output-files-root
</pre>
The flags are optional and are described in <a href='#CommandlineFlags'>3.8&nbsp;-&nbsp;Command-line Flags</a>.
<p>
The <code>primary-xsd-file</code> is the name of the file that contains the main schema definition.  See <a href='#SelectingtheInputFileTypeXSDWSDLDTD'>3.6&nbsp;-&nbsp;Selecting the Input File Type (XSD, WSDL, DTD)</a> for more information on selecting between W3C Schema files, WSDL files and XML external DTD files.
<p>
If the primary schema definition references other schemas, these additional schema files are specified on the command line by including the + character, a space, and then the name of the file.  Any number of additional schema files can be specified in this way.
<p>
If the additional schema files contain global elements that you would like to treat as possible XML instance document elements, then instead of using the <code>+</code> character in front of the schema name as above, use the <code>++</code> character sequence.  This can be useful when you are generating code for two or more schemas that share common imported schemas.
<p>
The last argument specifies the names of the C++ files into which the generated code is to be placed.  The LMX code generator will append .cpp to the name specified for the C++ source file, and append .h to the name for the header file.
<p>
For example, the command line:
<pre class='cmd'>
    lmx my_xsd.xsd my_xsd_code
</pre>
will compile the schema specified in my_xsd.xsd and generate the files my_xsd_code.h and my_xsd_code.cpp.
<p>
If my_xsd.xsd refers to other schemas, an example command line would be:
<pre class='cmd'>
    lmx my_xsd.xsd + my_xsd_lib_1.xsd + my_xsd_lib_2.xsd my_xsd_code
</pre>
This will combine the schemas specified in <code>my_xsd.xsd</code>, <code>my_xsd_lib_1.xsd</code> and <code>my_xsd_lib_2.xsd</code>, and generate the files <code>my_xsd_code.h</code> and <code>my_xsd_code.cpp</code>.
<p>
If two schemas refer to a common schema, one way to generate code is to use a command line similar to:
<pre class='cmd'>
    lmx my_xsd_1.xsd ++ my_xsd_2.xsd + my_xsd_lib.xsd my_xsd_code
</pre>
(N.B. notice the use of ++ rather than just +.)  In this case, in addition to allowing global elements in <code>my_xsd_1.xsd</code> to be document level elements in an XML instance, global elements in <code>my_xsd_2.xsd</code> will also be treated as candidate document level elements.
<p>
LMX has support for command-line shells that provide wildcard expansion (LMX itself does not perform wildcard expansion).  A command-line of the form below will treat all files matching <code>my_xsd_*.xsd</code> as <code>additional-library-xsd-file</code>s.  Only files not already mentioned on the command-line are treated as <code>additional-library-xsd-file</code>s.  Therefore, in the example below, <code>my_xsd_1.xsd</code> will not be treated as an <code>additional-library-xsd-file</code> even though it matches the wildcard, because it is explicitly named earlier on the command-line.
<pre class='cmd'>
    lmx my_xsd_1.xsd + my_xsd_*.xsd my_xsd_code
</pre>

<p>
When using a licensed version the LMX executable needs to know the location of the license file.  See <a href='#LicensingPurchase'>1.6&nbsp;-&nbsp;Licensing & Purchase</a> for further information.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CodeGenerationUsingtheLinuxCommandLineVersion'></a>
<h3>2.1.3&nbsp;-&nbsp;Code Generation Using the Linux Command Line Version</h3>
<p>
The operation of the Linux command-line version is the same as the Windows (DOS) command-line version as described in <a href='#CodeGenerationUsingtheWindowsDOSCommandLineVersion'>2.1.2&nbsp;-&nbsp;Code Generation Using the Windows (DOS) Command Line Version</a>, except that the executable is called '<code>linmx</code>'.  Hence the basic command-line syntax becomes:
<pre class='cmd'>
    linmx [flags] primary-xsd-file *[++ additional-global-xsd-file] *[+ additional-library-xsd-file] output-files-root
</pre>
For example:
<pre class='cmd'>
    linmx my_xsd.xsd my_xsd_code
</pre>
<p>
When using a licensed version the LMX executable needs to know the location of the license file.  See <a href='#LicensingPurchase'>1.6&nbsp;-&nbsp;Licensing & Purchase</a> for further information.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CCompilingandLinking'></a>
<h2>2.2&nbsp;-&nbsp;C++ Compiling and Linking</h2>
<p>
An LMX project consists of three different types of source code.
<ul>
<li>Code generated by the LMX code generator.
<p>
<li>The LMX Runtime Supporting Software.  This is code common to all LMX projects and consists of the low level XML parser and type classes.  The <code>.cpp</code> source files for this code are located in the <code>supporting-software/src</code> sub-directory of the installation, and the <code>.h</code> header files are located in the <code>supporting-software/include</code> sub-directory.
<p>
<li>The code written by you that interfaces to the LMX generated code.
</ul>
<p>
The simplest solution is to include the source code of all three types of code directly into your project.  This is the quickest and easiest solution for the evaluation phase.  However, you may choose to compile the different types of code separately into libraries or Windows DLLs.  The following sections give guidance on how to do this, although note that there are many different ways in which you may choose to partition the code.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CompilingtheRuntimeSupportingSoftwareSourceCode'></a>
<h3>2.2.1&nbsp;-&nbsp;Compiling the Runtime Supporting Software Source Code</h3>
As mentioned above, the Runtime Supporting Software is common to all LMX based projects.  The <code>.cpp</code> source files for this code are located in the <code>supporting-software/src</code> sub-directory of the installation, and the <code>.h</code> header files are located in the <code>supporting-software/include</code> sub-directory.
<p>
The set of source files you need for your build will depend on your requirements:
<ul>
<li><code>lmxparse.cpp</code> contains the low-level XML parser and related code.  Almost all LMX projects will need this file.</li>
<p>
<li><code>lmxtypes.cpp</code> contains the LMX type classes.  Most projects will use this file, although there is the option to provide your own alternative.</li>
<p>
<li><code>lmxregex.cpp</code> and <code>lmxunicode.cpp</code> are needed if you have not disabled regular expression handling in your build and you don't want to use your own variant of these (see <a href='#PatternFacetHandlingCustomization'>3.23&nbsp;-&nbsp;Pattern Facet Handling Customization</a>).</li>
<p>
<li><code>lmxsoap.cpp</code> may be included if you wish to use LMX's SOAP functionality.</li>
<p>
<li><code>lmxwinhttp.cpp</code> can optionally be included if you wish to use LMX's Windows HTTP functionality.  (Note that <code>lmxwinhttp.cpp</code> is Windows specific and will not compile on other platforms.  We recommend using libraries such as Linux's <code>libcurl</code> on other platforms.)</li>
</ul>
<p>
During the build process, these files will require access to the Supporting Software include files, typically located in the <code>supporting-software/include</code> sub-directory of the installation.  (Note that you might want to move the various files out of their default location when building a library so that you can more easily place them under version control.)
<p>
The exact process of building the source code will depend on your platform.  The simplest approach is to directly include the various source files in with your main project or makefile.  (Note that if you use the Visual Studio DLL C Runtime, the LMX code assumes by default that ultimately you will put the supporting software code in its own DLL.  As a result, if you include it directly in your project you will get <code>LNK4217: locally defined symbol</code> warnings (or similar).  In initial evaluation you can either ignore these warnings, or include <code>LMX_WANT_DLL=0</code> in the <code>Preprocessor Definitions</code> of your project settings.)
<p>
The Windows version of LMX includes a batch file called <code>build-libs.bat</code> in the <code>supporting-software/src</code> sub-directory of the installation that can be used to build the source code into static <code>.lib</code> files and dynamic <code>.dll</code> files.  This batch file should be run inside a Visual Studio Command Prompt window.  If you choose to build the files within the default <code>c:\Program Files\LMX</code> directory location then you will need to run the Visual Studio Command Prompt as an Administrator.  Read the comments in <code>build-libs.bat</code> for further details on how to customize the build to your needs.  
<p>
Note that to build the supporting software using <code>build-libs.bat</code> on Visual Studio 2015, 2017 & later, you need to ensure that the Windows SDK component of the Visual Studio installation process has been included.  (If not you can modify your Visual Studio configuration by re-running the Visual Studio installer.)
<p>
As you may notice from the <code>build-libs.bat</code> batch file, if you wish to build the Supporting Software Source Code into your own DLL, you need to configure your project to define <code>LMX_MAKE_DLL</code> (i.e. "Project->Properties->Configuration Properties->C/C++->Preprocessor->Preprocessor Definitions" includes <code>LMX_MAKE_DLL;</code>.) and also define <code>LMX_RT_SOURCE</code> (the value is not important in this latter case).  (For versions prior to version 6.1 of LMX or if you only want part of the LMX Supporting Software in a DLL, instead of defining <code>LMX_RT_SOURCE</code>, define <code>LMX_PARSE_SOURCE</code>, <code>LMX_TYPES_SOURCE</code>, and <code>LMX_REGEX_SOURCE</code>.)
<p>
If the Supporting Software Source Code has been built into a DLL and you which to combine the DLL with other code then you need to configure the project that references the DLL to define <code>LMX_WANT_DLL</code> to <code>1</code>.
<p>
The Linux version of LMX includes a makefile called <code>MakefileLMXlib</code> that can be used as a starting point for writing a makefile for building the Supporting Software into a static or shared library.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CompilingtheGeneratedCode'></a>
<h3>2.2.2&nbsp;-&nbsp;Compiling the Generated Code</h3>
<p>
The code generated by LMX will need access to the Supporting Software include files, typically located in the <code>supporting-software/include</code> sub-directory of the installation, in order to compile.
<p>
If you wish to build the generated code into a DLL, you need to configure your project to define <code>LMX_MAKE_DLL</code> (i.e. "Project->Properties->Configuration Properties->C/C++->Preprocessor->Preprocessor Definitions" includes <code>LMX_MAKE_DLL;</code>).
<p>
If the generated code has been built into a DLL and you which to combine the DLL with other code then you need to configure the project that references the DLL to define <code>LMX_WANT_GEN_IMPORT_DLL</code> to <code>1</code>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CompilingYourCodetoUseLMXCode'></a>
<h3>2.2.3&nbsp;-&nbsp;Compiling Your Code to Use LMX Code</h3>
<p>
To compile your code so that it can use the LMX generated code and Runtime Support Software your code will need to have access to the generated header file.  For example, if the LMX generated header file is <code>generated.h</code>, then you will need to include the following lines in your .cpp file:
<pre class='code'>
    #include "generated.h"
</pre>
If your code performs 'advanced' forms of marshaling and unmarshaling by calling the generated <code>marshal()</code> and <code>unmarshal()</code> methods directly (see <a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a> and <a href='#Unmarshalingadvancedforms'>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</a>), then you will need to include both the LMX generated <code>.h</code> file and the LMX parser header file; <code>lmxparse.h</code>.  For example:
<pre class='code'>
    #include "generated.h"
    #include "lmxparse.h"
</pre>
(If you choose to configure LMX to generate multiple header files (e.g. one header file per class), you should substitute the line <code>#include "generated.h"</code> mentioned above as appropriate.)
<p>
The generated header file will need access to the Runtime Supporting Software header files, typically located in the <code>supporting-software/include</code> sub-directory of the installation.
<p>
If the Runtime Supporting Software Source Code has been built into a DLL and you wish to combine it with your code then you need to configure your code sub-project to define <code>LMX_WANT_DLL</code> to <code>1</code>.
<p>
If the generated code has been built into a DLL and you wish to combine it with your code then you need to configure your code sub-project to define <code>LMX_WANT_GEN_IMPORT_DLL</code> to <code>1</code>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Unmarshalingsimpleform'></a>
<h2>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</h2>
<p>
Unmarshaling is the process of reading in XML and converting it to C++ objects.  LMX can parse UTF-8, UTF-16 (big and little endian), ISO-10646-UCS-2 (big and little endian), ISO-8859-1 (aka Latin-1), and US-ASCII.  The source XML can either be in an in-memory data buffer, or a file.  
<p>
For the class generated at the top of the class hierarchy (e.g. c_root) LMX generates convenience functions to help the marshaling and unmarshaling process.  These functions are not generated for other classes in order to reduce generated code size.  This section first presents the method for unmarshaling using these convenience methods.  Later in the section an alternative method of unmarshaling is presented, which can be used with other classes.  Additionally, advanced unmarshaling techniques are presented in <a href='#Unmarshalingadvancedforms'>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</a>.
<p>
To read XML from a <code>std::string</code>, code similar to the following can be used:
<pre class='code'>
    <span class='ccom'>// Allocate somewhere to store any error code that the unmarshaling may </span>
    <span class='ccom'>// produce</span>
    lmx::elmx_error result;
    lmx::s_debug_error error_detail;

    <span class='ccom'>// Construct an object from the XML contained in the std::string  </span>
    <span class='ccom'>// xml_message_data_string and store the result code of the </span>
    <span class='ccom'>// unmarshaling in the 'result' variable.</span>
    <span class='ckw'>const</span> c_generated_xsd_root_class top_object(
                                        xml_message_data_string, 
                                        &result,
                                        &error_detail );

    <span class='ccom'>// If the 'result' variable indicates that all is OK, interact with the</span>
    <span class='ccom'>// object.</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
The <code>error_detail</code> argument is optional, so the following code is also valid if detailed error information is not required:
<pre class='code'>
    lmx::elmx_error result;

    <span class='ckw'>const</span> c_generated_xsd_root_class top_object(
                                        xml_message_data_string, 
                                        &result );

    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
To read XML from an in-memory buffer, where <code>xml_message_data_buffer</code> is of type <code>const char *</code> or similar, code similar to the following can be used:
<pre class='code'>
    <span class='ccom'>// Allocate somewhere to store any error code that the unmarshaling may </span>
    <span class='ccom'>// produce</span>
    lmx::elmx_error result;
    lmx::s_debug_error error_detail;    <span class='ccom'>// Using error_detail is optional</span>

    <span class='ccom'>// Construct an object from the XML contained in the memory located at </span>
    <span class='ccom'>// xml_message_data_buffer and store the result code of the unmarshaling in </span>
    <span class='ccom'>// the 'result' variable.</span>
    <span class='ckw'>const</span> c_generated_xsd_root_class top_object(
                                        xml_message_data_buffer, 
                                        number_of_bytes_in_buffer,
                                        &result,
                                        &error_detail );    <span class='ccom'>// error_detail is optional</span>

    <span class='ccom'>// If the 'result' variable indicates that all is OK, interact with the</span>
    <span class='ccom'>// object.</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
To read XML from a file, code similar to the following can be used (which doesn't use the option to retrieve detailed error information):
<pre class='code'>
    <span class='ccom'>// Allocate somewhere to store any error code that the unmarshaling may </span>
    <span class='ccom'>// produce</span>
    lmx::elmx_error result;

    <span class='ccom'>// Construct an object from the XML contained in the file 'c:/myxml.xml'</span>
    <span class='ccom'>// and store the result code of the unmarshaling in the 'result' variable.</span>
    <span class='ckw'>const</span> c_generated_xsd_root_class top_object( "c:/myxml.xml", &result );

    <span class='ccom'>// If the 'result' variable indicates that all is OK, interact with the</span>
    <span class='ccom'>// object.</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
<p>
Convenience methods are also generated to unmarshal instances corresponding to <code>xs:any</code> constructs that have previously been unmarshalled from an XML instance.  This can be done using code similar to the following:
<pre class='code'>
    <span class='ccom'>// Allocate somewhere to store any error code that the unmarshaling may </span>
    <span class='ccom'>// produce</span>
    lmx::elmx_error result;

    <span class='ccom'>// Construct an object from the XML corresponding to an xs:any instance</span>
    <span class='ccom'>// unmarshalled from a previous unmarshaling run.</span>
    <span class='ckw'>const</span> c_generated_xsd_root_class top_object(
                              my_previously_unmarshaled_object.get_any(), 
                              &result );

    <span class='ccom'>// If the 'result' variable indicates that all is OK, interact with the</span>
    <span class='ccom'>// object.</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
<p>
where the <code>get_any()</code> method is described in <a href='#SingularxsanyCInterface'>2.5.10&nbsp;-&nbsp;Singular xs:any C++ Interface</a> and <a href='#MultiplexsanyCInterface'>2.5.12&nbsp;-&nbsp;Multiple xs:any C++ Interface</a>.
<p>
If it is not convenient to unmarshal at the time the object is constructed (for example, if the object is a static global store of the application's user preferences) then the following methods can be used.
<p>
To read XML from a <code>std::string</code>, code similar to the following can be used:
<pre class='code'>
    <span class='ccom'>// Create an instance of the class</span>
    c_generated_xsd_root_class top_object;

    <span class='ccom'>// ... additional code ...</span>

    <span class='ccom'>// Use the unmarshal method, giving the std::string to read from</span>
    lmx::elmx_error result = top_object.unmarshal( xml_message_data_string );

    <span class='ccom'>// If unmarshaling was successful, interact with the object</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
To read XML from an in-memory buffer (of type <code>const char *</code> or similar), code similar to the following can be used:
<pre class='code'>
    <span class='ccom'>// Create an instance of the class</span>
    c_generated_xsd_root_class top_object;

    <span class='ccom'>// ... additional code ...</span>

    <span class='ccom'>// Use the unmarshal method, giving the details of the memory to read from</span>
    lmx::elmx_error result = top_object.unmarshal( xml_message_data_buffer, 
                                        number_of_bytes_in_buffer );

    <span class='ccom'>// If unmarshaling was successful, interact with the object</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
To read XML from a file:
<pre class='code'>
    <span class='ccom'>// Create an instance of the class</span>
    c_generated_xsd_root_class top_object;

    <span class='ccom'>// ... additional code ...</span>

    <span class='ccom'>// Use the unmarshal method, giving the details of the file to read from</span>
    lmx::elmx_error result = top_object.unmarshal( "c:\\myxml.xml" );

    <span class='ccom'>// If unmarshaling was successful, interact with the object</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
If you wish to unmarshal from an object for which the convenience functions were not generated, then you can use the <code>unmarshal</code> template functions that are defined in <code>lmxparse.h</code>.  In this case the code form is:
<p>
- for XML in a <code>std::string</code>:
<pre class='code'>
    <span class='ccom'>// Create an instance of the class</span>
    c_generated_class an_object;

    <span class='ccom'>// Use the template unmarshal method, giving the details of the memory to</span>
    <span class='ccom'>// read from</span>
    lmx::elmx_error result = lmx::unmarshal( &an_object, 
                                             xml_message_data_string );

    <span class='ccom'>// If unmarshaling was successful, interrogate the object</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
- for XML in memory:
<pre class='code'>
    <span class='ccom'>// Create an instance of the class</span>
    c_generated_class an_object;

    <span class='ccom'>// Use the template unmarshal method, giving the details of the memory to</span>
    <span class='ccom'>// read from</span>
    lmx::elmx_error result = lmx::unmarshal( &an_object, xml_message_data_buffer, 
                                        number_of_bytes_in_buffer );

    <span class='ccom'>// If unmarshaling was successful, interrogate the object</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
- for XML in a file:
<pre class='code'>
    <span class='ccom'>// Create an instance of the class</span>
    c_generated_class an_object;

    <span class='ccom'>// Use the unmarshal method, giving the details of the file to read from</span>
    lmx::elmx_error result = lmx::unmarshal( &an_object, "c:\\myxml.xml" );

    <span class='ccom'>// If unmarshaling was successful, interrogate the object</span>
    <span class='ckw'>if</span>( result == lmx::ELMX_OK )
    {
        <span class='ccom'>// Work with unmarshalled data...</span>
</pre>
For information on how to diagnose errors, particularly during debugging, when using these convenience methods, see <a href='#CollectingDebugErrorInformationwhenusingConvenienceMethods'>3.16.4&nbsp;-&nbsp;Collecting Debug Error Information when using Convenience Methods</a>.
<p>
As mentioned previously, additional unmarshaling techniques are described in <a href='#Unmarshalingadvancedforms'>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</a>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Marshalingsimpleform'></a>
<h2>2.4&nbsp;-&nbsp;Marshaling (simple form)</h2>
<p>
Marshaling is the process converting the C++ object content into XML data.
<p>
For the class generated at the top of the class hierarchy (e.g. c_root) LMX generates convenience functions to help the marshaling and unmarshaling process.  These functions are not generated for other classes in order to reduce generated code size.  This section first presents the method for marshaling using these convenience methods.  Later in the section an alternative method of marshaling is presented, which can be used with other classes.  Additionally, advanced marshaling techniques are presented in <a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a>.
<p>
A typical section of marshaling code for writing the XML to a string looks as follows:
<pre class='code'>
        <span class='ccom'>// Create an instance of the class</span>
        c_generated_xsd_root_class top_object;

        <span class='ccom'>// ... Populate and manipulate top_object ... </span>

        <span class='ccom'>// Allocate a string in which to store the marshalled XML</span>
        std::string my_string;

        <span class='ccom'>// Marshal the object to the string</span>
        top_object.marshal( &my_string );
</pre>
<p>
The equivalent code for writing to a file is as follows:
<pre class='code'>
        <span class='ccom'>// Create an instance of the class</span>
        c_generated_xsd_root_class top_object;

        <span class='ccom'>// ... Populate and manipulate top_object ... </span>

        <span class='ccom'>// Marshal the object to the file "c:\myxml.xml"</span>
        <span class='ckw'>if</span>( top_object.marshal( "c:\\myfile.xml" ) != lmx::ELMX_OK )
        {
            <span class='ccom'>// Something went wrong!</span>
        }
</pre>
If you wish to marshal an object for which the convenience functions are not generated, then you can use the <code>marshal</code> template functions defined in <code>lmxparse.h</code>.  In this case, the code for marshaling to string is:
<pre class='code'>
        <span class='ccom'>// Create an instance of the class</span>
        c_generated_class an_object;

        <span class='ccom'>// ... Populate and manipulate an_object ... </span>

        <span class='ccom'>// Allocate a string in which to store the marshalled XML</span>
        std::string my_string;

        <span class='ccom'>// Marshal the object to the string</span>
        lmx::marshal( an_object, &my_string );
</pre>
<p>
and the code for marshaling to a file is:
<pre class='code'>
        <span class='ccom'>// Create an instance of the class</span>
        c_generated_class an_object;

        <span class='ccom'>// ... Populate and manipulate an_object ... </span>

        <span class='ccom'>// Marshal the object to the file "c:\myxml.xml"</span>
        <span class='ckw'>if</span>( lmx::marshal( an_object, "c:\\myfile.xml" ) != lmx::ELMX_OK )
        {
            <span class='ccom'>// Something went wrong!</span>
        }
</pre>
As in the unmarshalling case, for information on how to diagnose errors, particularly during debugging, when using these convenience methods, see <a href='#CollectingDebugErrorInformationwhenusingConvenienceMethods'>3.16.4&nbsp;-&nbsp;Collecting Debug Error Information when using Convenience Methods</a>.
<p>
As mentioned previously, additional marshaling techniques are described in <a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AccesingtheDataintheGeneratedClasses'></a>
<h2>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</h2>
<p>
The C++ class interface to a generated item is independent of whether the item is an element or an attribute.  Hence the difference between these two forms is abstracted away.  The term 'item' is used here to refer to either an element or an attribute.  
<p>
An interface to an item depends in one respect on whether an item is:
<ul>
<li>empty.
<p>
<li>a simpleType.
<p>
<li>a complexType.
<p>
<li>xs:anyAttribute.
<p>
<li>xs:any.
<p>
</ul>
The other aspect that affects the interface is whether the item is:
<ul>
<li>Singular - minOccurs = maxOccurs = 1, or a required attribute.
<p>
<li>Optional - minOccurs = 0, maxOccurs = 1, or a normal attribute.
<p>
<li>Multiple - maxOccurs > 1 (or unbounded), or a list.
</ul>
<p>
A further consideration for optional items is whether the item is in an xs:choice construct.
<p>
There are also special functions to interface with enumerated values, and additional functions to interface to complex types that are polymorphic.
<p>
The following sections describe the interface for each of these combinations.  Throughout the discussion, the string <code>NAME</code> is used to represent the name given to the item.
<p>
An element of type <code>xs:any</code> will by default have the <code>NAME</code> part of the method name set to <code>any</code>.  However, if there is more than one xs:any element in a complex type, or another element is named <code>any</code>, numbers will be appended to the name to provide differentiation.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SingularEmptyTypeCInterface'></a>
<h3>2.5.1&nbsp;-&nbsp;Singular Empty Type C++ Interface</h3>
<p>
No interface is generated.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='OptionalEmptyTypeCInterface'></a>
<h3>2.5.2&nbsp;-&nbsp;Optional Empty Type C++ Interface</h3>
<p>
If the item is not in an xs:choice, the following method is generated:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> set_NAME();
</pre>
</dt><dd>Marks the item <code>NAME</code> as present.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> isset_NAME() <span class='ckw'>const</span>;
</pre>
</dt><dd>Returns <code>true</code> if the item <code>NAME</code> is present, and <code>false</code> otherwise.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> unset_NAME();
</pre>
</dt><dd>Marks the item <code>NAME</code> as not present.</dd>
<p>
</dl>
If the item is allowed in an xs:choice, but not present, the <code>getchosen()</code> method returns <code>&lt;class name>::e_choice_not_set</code>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SingularSimpleTypeCInterface'></a>
<h3>2.5.3&nbsp;-&nbsp;Singular Simple Type C++ Interface</h3>
<p>
Note that for the interface to list types, see <a href='#MultipleSimpleTypeandListSimpleTypeCInterface'>2.5.5&nbsp;-&nbsp;Multiple Simple Type and List Simple Type C++ Interface</a>.
<dl>
<dt>
<pre class='proto'>
&lt;return type> get_NAME() <span class='ckw'>const</span>;
</pre></dt>
<dd>Return either the value of item <code>NAME</code> or a reference to <code>NAME</code> depending on the particular type.</dd>
<p>
<dt>
<pre class='proto'>
&lt;non-const ref to type> get_NAME();
</pre></dt>
<dd>Generated if the type of NAME is a compound class such as for xs:date.  Returns a non-const reference to <code>NAME</code>.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> set_NAME( simple_type );
</pre>
</dt>
<dd>Set item <code>NAME</code> to the specified value.</dd>
<p>
</dl>
If the type has enumerations, the following additional methods are generated:
<dl>
<dt>
<pre class='proto'>
elmx_enums getenum_NAME() <span class='ckw'>const</span>;
</pre>
</dt>
<dd>Returns the enumerated constant corresponding to the value of item <code>NAME</code>.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> setenum_NAME( elmx_enums );
</pre></dt>
<dd>Sets the value of item <code>NAME</code> to the value corresponding to the specified enumerated constant.  <code>true</code> is returned if the value is correctly set, and <code>false</code> otherwise.</dd>
<p>
</dl>
<p>
If a simple type is nillable, then it is treated as complex type / simple content.  Thus the interaction with nillable types is discussed below.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='OptionalSimpleTypeCInterface'></a>
<h3>2.5.4&nbsp;-&nbsp;Optional Simple Type C++ Interface</h3>
<p>
(Note: See <a href='#MultipleSimpleTypeandListSimpleTypeCInterface'>2.5.5&nbsp;-&nbsp;Multiple Simple Type and List Simple Type C++ Interface</a> for the interface to list types.)
The Optional Simple Type has the same methods as defined in <a href='#SingularSimpleTypeCInterface'>2.5.3&nbsp;-&nbsp;Singular Simple Type C++ Interface</a>, plus the following methods:
<p>
If the item is not in an xs:choice, the following methods are generated:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> isset_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>Returns <code>true</code> if the item <code>NAME</code> is present, and <code>false</code> otherwise.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> unset_NAME();
</pre></dt><dd>Marks the item <code>NAME</code> as not present.</dd>
<p>
</dl>
<p>
If the item is allowed in an xs:choice, but not present, the <code>getchosen()</code> method returns <code>&lt;class name>::e_choice_not_set</code>.
</p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultipleSimpleTypeandListSimpleTypeCInterface'></a>
<h3>2.5.5&nbsp;-&nbsp;Multiple Simple Type and List Simple Type C++ Interface</h3>
<p>
This interface is used for elements that have a cardinality greater than 1, and elements or attributes with lists.
<dl>
<dt>
<pre class='proto'>
size_t size_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>Returns the number of instances to type <code>NAME</code>.</dd>
<p>
<dt>
<pre class='proto'>
&lt;return type> get_NAME( size_t n ) <span class='ckw'>const</span>;
</pre></dt><dd>Returns the n-th value of item <code>NAME</code>.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
&lt;non-const ref to type> get_NAME( size_t n );
</pre></dt>
<dd>Generated if the type of NAME is a compound class such as for xs:date.  Returns a non-const reference to the n-th value of item <code>NAME</code>.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
lmx::elmx_error set_NAME( size_t n, type );
</pre></dt><dd>Sets the instance at the n-th position of the collection of <code>NAME</code> items.  The item previously at the n-th position is over-written.  If a value of n is specified that is larger than the size of the collection, the <code>append_NAME( type )</code> method is called.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
lmx::elmx_error append_NAME( type );
</pre></dt><dd>Appends an instance to the collection of <code>NAME</code> items.</dd>
<p>
<dt>
<pre class='proto'>
lmx::elmx_error insert_NAME( size_t n, type );
</pre></dt><dd>Inserts an instance into the n-th position of the collection of <code>NAME</code> items.  The item previously at the n-th position is moved to the (n+1)-th position and so on.  If a value of n is specified that is larger than the size of the collection, the <code>append_NAME( type )</code> method is called.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> delete_NAME( size_t n );
</pre></dt><dd>Deletes the n-th value of item <code>NAME</code>.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> clear_NAME();
</pre></dt><dd>Removes all items from the collection.  In the case of a list item, calling this method can be used to create an empty list if a list with no members is wanted.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>auto</span> in_NAME();
</pre></dt>
<dd>Returns iterator details that can be used in a C++11 range-based for statement.  See example in <a href='#MultipleSimpleTypeUsageExamples'>2.5.5.1&nbsp;-&nbsp;Multiple Simple Type Usage Examples</a>.</dd>
</dl>
<p>
If the type has enumerations, the following additional methods are generated:
<dl>
<dt>
<pre class='proto'>
elmx_enums getenum_NAME( size_t n ) <span class='ckw'>const</span>;
</pre></dt>
<dd>Returns the enumeration constant corresponding to the n-th instance of item <code>NAME</code>.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> setenum_NAME( size_t n, elmx_enums set );
</pre></dt> <dd>Sets the value of the item at the n-th position of the <code>NAME</code> collection to the value corresponding to the specified enumeration constant.  If a value of n is specified that is larger than the size of the collection, the <code>appendenum_NAME( type )</code> method is called.  The first instance is n=0.  <code>true</code> is returned if the value is correctly set, and <code>false</code> otherwise.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> appendenum_NAME( elmx_enums set );
</pre></dt> <dd>Appends a value to the item <code>NAME</code> corresponding to the specified enumeration constant.  <code>true</code> is returned if the value is correctly set, and <code>false</code> otherwise.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> insertenum_NAME( size_t n, elmx_enums set );
</pre></dt> <dd>Inserts a value at the n-th position of the collection <code>NAME</code> corresponding to the specified enumeration constant.  If a value of n is specified that is larger than the size of the collection, the <code>appendenum_NAME( type )</code> method is called.  The first instance is n=0.  <code>true</code> is returned if the value is correctly set, and <code>false</code> otherwise.</dd>
<p>
</dl>
If the type is an optional list, the following additional methods are generated (this allows an empty list to be present):
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> isset_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>Returns <code>true</code> if the item <code>NAME</code> is present, and <code>false</code> otherwise.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> unset_NAME();
</pre></dt><dd>Marks the item <code>NAME</code> as not present.</dd>
<p>
</dl>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultipleSimpleTypeUsageExamples'></a>
<h4>2.5.5.1&nbsp;-&nbsp;Multiple Simple Type Usage Examples</h4>
<p>
For reading:
<pre class='code'>
    <span class='ckw'>for</span>( size_t i=0; i&lt;top.size_NAME(); ++i )
        do_something( top.get_NAME( i ) );
</pre>
<p>
Or:
<pre class='code'>
    <span class='ckw'>for</span>( <span class='ckw'>auto</span> & i : top.in_NAME() )
        do_something( i );
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SingularComplexTypeCInterface'></a>
<h3>2.5.6&nbsp;-&nbsp;Singular Complex Type C++ Interface</h3>
<dl>
<dt>
<pre class='proto'>
&lt;const ref to type> get_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>This method provides read-only access to <code>NAME</code>.  It is recommended that this method be used for reading the item rather than the read/write variant.</dd>
<p>
<dt>
<pre class='proto'>
&lt;non-const ref to type> get_NAME();
</pre></dt><dd>This method allows read/write access to <code>NAME</code> by returning a reference.</dd>
<p>
</dl>
If the complex type is an xs:choice, the following method is generated:
<dl>
<dt>
<pre class='proto'>
&lt;class name>::elmx_chosen getchosen() <span class='ckw'>const</span>;
</pre></dt><dd>Returns the class specific enumerated value corresponding to the present choice.</dd>
<p>
</dl>
<p>
For the marshaling operation, the appropriate choice is selected when the relevant <code>set_NAME</code> or non-const <code>get_NAME</code> method among the choice's children is called.  For example, if <code>CHOICE</code> is a choice, represented by the class <code>c_CHOICE</code>, and <code>OPTION</code> is one of the elements within the choice, then if we have:
</p>
<pre class='code'>
    c_CHOICE &my_choice = ...;
</pre>
we can select the desired option within the choice by doing:
<pre class='code'>
    my_choice.set_OPTION(...);
</pre>
Similarly, if we do not immediately have a pointer or reference to <code>c_CHOICE</code>, we can set the desired option by doing:
<pre class='code'>
    my_item.get_CHOICE().set_OPTION(...);
</pre>
If <code>OPTION</code> is a complex type which has associated with it a non-const get method, then the act of calling that non-const get method will cause the appropriate choice option to be selected.  For example:
<pre class='code'>
    c_OPTION &my_option = my_item.get_CHOICE().get_OPTION(...);
</pre>
or:
<pre class='code'>
    my_item.get_CHOICE().get_OPTION().set_an_option_child(12);
</pre>
<p>
If the complex type is an xs:all, the following methods are generated:
<dl>
<dt>
<pre class='proto'>
&lt;class name>::elmx_all getorder( size_t n ) <span class='ckw'>const</span>;
</pre></dt><dd>Returns the enumeration constant corresponding to the n-th present element in the xs:all construct.  The first element corresponds to n == 0.</dd>
<p>
<dt>
<pre class='proto'>
size_t getorder( elmx_all enumeration_const ) <span class='ckw'>const</span>;
</pre></dt><dd>Returns the position within the <code>xs:all</code> construct of the element corresponding to the enumeration constant <code>enumeration_const</code>.  The function returns <code>lmx::k_all_order_not_present</code> if the element is not present.</dd>
<p>
<dt>
<pre class='proto'>
size_t getorder_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>Returns the position of element NAME within the <code>xs:all</code> construct.  The function returns <code>lmx::k_all_order_not_present</code> if the element is not present.</dd>
<p>
<dt>
<pre class='proto'>
size_t sizeorder() <span class='ckw'>const</span>;
</pre></dt><dd>Returns the number of elements present in the xs:all construct.</dd>
<p>
</dl>
During marshaling, the order that the elements are output corresponds to the order in which they are written to the object.
<p>
A nillable type will always have a class generated for it, even if it is a simple type.  (In effect a nillable simple type is treated as complex type / simple content.)  If a type is nillable, the following functions will be generated:-
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> setnil_NAME();
</pre></dt><dd>Used to set the element to a nil value.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> isnil_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>Returns <code>true</code> is a value is nil, and false otherwise.</dd>
<p>
</dl>
If a value is nillable, you should test <code>isnil_NAME()</code> prior to attempting to read the element's body value(s) using <code>get_NAME()</code> etc.
<p>
If a type is polymorphic, the following method is generated:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> assign_NAME( c_NAME_TYPE *p_derived_type );
</pre></dt><dd>Sets the polymorphic type associated with item NAME to the object pointed to by p_derived_type, which must be a derived type of c_NAME_TYPE.  Once the pointer is assigned to the generated object, the generated object takes responsibility for deleting the pointer on destruction.  (Note: the <code>get_NAME()</code> method can be used to access a polymorphic type, and no additional methods are generated for this purpose.)</dd>
<p>
</dl>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SingularComplexTypeUsageExamples'></a>
<h4>2.5.6.1&nbsp;-&nbsp;Singular Complex Type Usage Examples</h4>
<p>
To read a child of <code>NAME</code>:
<pre class='code'>
    <span class='ckw'>int</span> an_int = top.get_NAME().get_CHILD();
</pre>
Or, if you intend to read a lot of items from <code>NAME</code>, another possibility is:
<pre class='code'>
    <span class='ckw'>const</span> c_NAME & name_ref = top.get_NAME();
    <span class='ckw'>int</span> an_int = name_ref.get_CHILD();
    <span class='ckw'>float</span> a_float = name_ref.get_CHILD2();
</pre>
To write to <code>NAME</code>:
<pre class='code'>
    top.get_NAME().set_CHILD( 12 );
</pre>
Or:
<pre class='code'>
    c_NAME & name_ref = top.get_NAME();
    name_ref.set_CHILD( 12 );
    name_ref.set_CHILD2( 1.2 );
</pre>
If the complex type is an <code>xs:choice</code>:
<pre class='code'>
    <span class='ckw'>switch</span>( top.getchosen() )
        {
    <span class='ckw'>case</span> c_top::e_my_int:
        ...
    <span class='ckw'>break</span>;
    <span class='ckw'>case</span> c_top::e_my_float:
        ...
    <span class='ckw'>break</span>;
    <span class='ckw'>default</span>:
        assert(0);
        }
</pre>
An alternative to the above with better compile time checking is:
<pre class='code'>
    c_top::elmx_chosen chosen = top.getchosen();
    <span class='ckw'>if</span>( chosen == c_top::e_my_int ) {
        ...
    }
    <span class='ckw'>else</span> <span class='ckw'>if</span>( chosen == c_top::e_my_float ) {
        ...
    }
</pre>
<p>
To set the choice option when marshaling, use one of the children's <code>set</code> or non-const <code>get</code> methods.  For example:
<pre class='code'>
    top.get_NAME().set_CHILD( 12 );
</pre>
Or:
<pre class='code'>
    c_NAME & name_ref = top.get_NAME();
    name_ref.set_CHILD( 12 );
</pre>
If the complex type is an <code>xs:all</code>:
<pre class='code'>
    <span class='ckw'>for</span>( size_t i=0; i&lt;top.sizeorder(); ++i )
        {
        <span class='ckw'>switch</span>( top.getorder(i) )
            {
        <span class='ckw'>case</span> c_top::e_my_int:
            ...
        <span class='ckw'>break</span>;
        <span class='ckw'>case</span> c_top::e_my_float:
            ...
        <span class='ckw'>break</span>;
        <span class='ckw'>default</span>:
            assert(0);
            }
        }
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='OptionalComplexTypeCInterface'></a>
<h3>2.5.7&nbsp;-&nbsp;Optional Complex Type C++ Interface</h3>
<p>
An Optional Complex Type has the same methods as a Singular Complex type, plus the additional methods specified <a href='#OptionalSimpleTypeCInterface'>2.5.4&nbsp;-&nbsp;Optional Simple Type C++ Interface</a></a>.  
<p>
If the complex type is an xs:choice, a <code>getchosen()</code> method is generated as described in <a href='#SingularComplexTypeCInterface'>2.5.6&nbsp;-&nbsp;Singular Complex Type C++ Interface</a>.  If the optional xs:choice is not present, the <code>getchosen()</code> method returns <code>&lt;class name>::e_choice_not_set</code>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='OptionalComplexTypeUsageExamples'></a>
<h4>2.5.7.1&nbsp;-&nbsp;Optional Complex Type Usage Examples</h4>
<p>
To read an optional complex type:
<pre class='code'>
    <span class='ckw'>if</span>( top.isset_NAME() ) {
        <span class='ckw'>const</span> c_NAME & name_ref = top.get_NAME();
        <span class='ckw'>int</span> an_int = name_ref.get_CHILD();
        <span class='ckw'>float</span> a_float = name_ref.get_CHILD2();
    }
</pre>
To write to an optional complex type:
<pre class='code'>
    c_NAME & name_ref = top.get_NAME();
    name_ref.set_CHILD( 12 );
    name_ref.set_CHILD2( 1.2 );
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultipleComplexTypeCInterface'></a>
<h3>2.5.8&nbsp;-&nbsp;Multiple Complex Type C++ Interface</h3>
Common to reading and writing:
<dl>
<dt>
<pre class='proto'>
size_t size_NAME() <span class='ckw'>const</span>;
</pre></dt><dd>Returns the number of instances of item <code>NAME</code>.</dd>
<p>
</dl>
For reading:

<dl>
<dt>
<pre class='proto'>
&lt;const ref to type> get_NAME( size_t n ) <span class='ckw'>const</span>;
</pre></dt> <dd>Returns a const reference to the n-th instance of item <code>NAME</code>.  This version should always be used when reading from item <code>NAME</code>.  The first instance is n=0.</dd>
<p>
</dl>
For writing:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> append_NAME();
</pre></dt><dd>Appends a new instance of item <code>NAME</code>.  This method is used in conjunction with the <code>back_NAME()</code> method.  For more information see the example below.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> append_NAME( &lt;type> * p );
</pre></dt><dd>Appends the value pointed to by <code>p</code> to the collection of <code>NAME</code> items.  The LMX generated code takes ownership of the object pointed to by <code>p</code> when the method is called, and will delete it when the LMX object is deleted.  Use <code>get_NAME( n )</code> to access and modify the inserted value.</dd>
<p>
<dt>
<pre class='proto'>
&lt;non-const ref to type> back_NAME();
</pre></dt><dd>Returns a reference to the instance at the back of the list of item <code>NAME</code>.  This method is used in conjunction with the <code>append_NAME()</code> method.  For more information, see the example below.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> insert_NAME( size_t n );
</pre></dt><dd>Inserts an instance into the n-th position of the collection of <code>NAME</code> items.  The item previously at the n-th position is moved to the (n+1)-th position and so on.  The first instance is n=0.  If a value of n is specified that is larger than the size of the collection, the <code>append_NAME()</code> method is called.  Use <code>get_NAME( n )</code> to access and modify the inserted value.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> insert_NAME( size_t n, &lt;type> * p );
</pre></dt><dd>Inserts the value pointed to by <code>p</code> into the n-th position of the collection of <code>NAME</code> items.  The item previously at the n-th position is moved to the (n+1)-th position and so on.  The first instance is n=0.  If a value of n is specified that is larger than the size of the collection, the <code>append_NAME( p )</code> method is called.  The LMX generated code takes ownership of the object pointed to by <code>p</code> when the method is called, and will delete it when the LMX object is deleted.  Use <code>get_NAME( n )</code> to access and modify the inserted value.</dd>
<p>
<dt>
<pre class='proto'>
&lt;non-const ref to type> get_NAME( size_t n );
</pre></dt><dd>Returns a reference to the n-th instance of item <code>NAME</code>.  The first instance is n=0.  If such an instance does not currently exist, an instance (and all intervening instances) will be created.  For example, if m instances already exist, and instance n is requested (where m &lt; n) n - m instances will be created.</dd>
<p>
<dt>
<pre class='proto'>
&lt;non-const ref to type> assign_NAME( size_t n, &lt;const ref to type> );
</pre></dt><dd>Does a deep copy of the input parameter to the n-th position of the collection.  The first instance is n=0.  If such an instance does not currently exist, an instance (and all intervening instances) will be created.  For example, if m instances already exist, and instance n is requested (where m &lt; n) n - m instances will be created.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> delete_NAME( size_t n );
</pre></dt> <dd>Deletes the n-th instance of item <code>NAME</code>.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> clear_NAME();
</pre></dt><dd>Removes all items from the collection.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>auto</span> in_NAME();
</pre></dt>
<dd>Returns iterator details that can be used in a C++11 range-based for statement.  See example in <a href='#MultipleComplexTypeUsageExamples'>2.5.8.1&nbsp;-&nbsp;Multiple Complex Type Usage Examples</a>.</dd>
<p>
</dl>
<p>
If <code>NAME</code> is an optional xs:list, it also has the methods defined for an <a href='#oct'>Optional Complex Type</a>.
<p>
If the complex type is an xs:choice, the following method is also generated:
<dl>
<dt>
<pre class='proto'>
&lt;class name>::elmx_chosen getchosen( size_t n ) <span class='ckw'>const</span>;
</pre></dt>
<dd>Returns the class specific enumerated value corresponding to the chosen element in the n-th instance of the xs:choice.  n=0 specifies the first instance.  Other than the <code>n</code> parameter to select the index, the <code>getchosen()</code> method operates the same way as described in <a href='#SingularComplexTypeCInterface'>2.5.6&nbsp;-&nbsp;Singular Complex Type C++ Interface</a>.</dd>
<p>
</dl>
If a type is polymorphic, the following method is generated:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> append_NAME( c_NAME_TYPE *p_derived_type );
</pre></dt><dd>Appends the polymorphic type pointed to by p_derived_type to the item NAME, which must be a derived type of c_NAME_TYPE.  Once the pointer is assigned to the generated object, the generated object takes responsibility for deleting the pointer on destruction.  (Note: the <code>get_NAME(size_t n)</code> method can be used to access a polymorphic type, and no additional methods are generated for this purpose.)</dd>
<p>
</dl>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultipleComplexTypeUsageExamples'></a>
<h4>2.5.8.1&nbsp;-&nbsp;Multiple Complex Type Usage Examples</h4>
<p>
For reading:
<pre class='code'>
    <span class='ckw'>for</span>( size_t i=0; i&lt;top.size_NAME(); ++i )
        do_something( top.get_NAME( i ) );
</pre>
Or:
<pre class='code'>
    <span class='ckw'>for</span>( <span class='ckw'>auto</span> & i : top.in_NAME() )
        do_something( i );
</pre>
<p>
For writing, a new instance of the complex type is appended using the <code>append_NAME</code> method.  The new instance is then populated by repeated use of the <code>back_NAME</code> method.  For example:
<pre class='code'>
    <span class='ckw'>while</span>( not_finished( &an_int, &a_float ) ) {
        top.append_NAME();
        top.back_NAME().set_int( an_int );
        top.back_NAME().set_float( a_float );
    }
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultiplexsanyAttributeCInterface'></a>
<h3>2.5.9&nbsp;-&nbsp;Multiple xs:anyAttribute C++ Interface</h3>
<p>
If xs:anyAttribute is specified, only the 'multiple' case is allowed.
<p>
When a document has instances xs:anyAttribute it may be necessary to add extra namespace information to the <code>c_xml_writer</code> class.  See <a href='#AddingExtraNamespaceInformation'>3.18&nbsp;-&nbsp;Adding Extra Namespace Information</a> for more information.
<dl>
<dt>
<pre class='proto'>
size_t sizeany_attribute() <span class='ckw'>const</span>;
</pre></dt>
<dd>Returns the number of xs:anyAttributes present.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> getany_attribute( size_t n,
                       std::string *p_namespace,
                       std::string *p_name,
                       std::string *p_value ) <span class='ckw'>const</span>;
</pre></dt>
<dd>Retrieves the n-th xs:anyAttribute.  The namespace of the attribute (e.g. 'http://...') is stored in the string pointed to by p_namespace, the name of the attribute is stored in the string pointed to by p_name, and the value is stored in the string pointed to by p_value.  n=0 refers to the first instance.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> appendany_attribute( <span class='ckw'>const</span> std::string &name,
                          <span class='ckw'>const</span> std::string &value );
</pre></dt>
<dd>Appends an xs:anyAttribute to the list of xs:anyAttributes.  The name of the attribute is stored in name, and the value in value.  When written to the XML document, the value part will be surrounded by quote marks, and standard XML entities will be escaped (e.g. & ' " etc).</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> insertany_attribute( size_t n,
                          <span class='ckw'>const</span> std::string &name,
                          <span class='ckw'>const</span> std::string &value );
</pre></dt>
<dd>Inserts an xs:anyAttribute at the n-th position of the list of xs:anyAttributes.  The item previously at the n-th position is moved to the (n+1)-th position and so on.  The first instance is n=0.  If a value of n is specified that is larger than the size of the collection, the <code>appendany_attribute()</code> method is called.  The name of the attribute is stored in name, and the value in value.  When written to the XML document, the value part will be surrounded by quote marks, and standard XML entities will be escaped (e.g. & ' " etc).</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> deleteany_attribute( size_t n );
</pre></dt>
<dd>Deletes the n-th instance of xs:anyAttribute.  n=0 refers to the first instance.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> clearany_attribute();
</pre></dt><dd>Removes all items from the collection.</dd>
<p>
</dl>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SingularxsanyCInterface'></a>
<h3>2.5.10&nbsp;-&nbsp;Singular xs:any C++ Interface</h3>
<p>
When a document has instances xs:any it may be necessary to add extra namespace information to the <code>c_xml_reader</code> and <code>c_xml_writer</code> class.  See <a href='#AddingExtraNamespaceInformation'>3.18&nbsp;-&nbsp;Adding Extra Namespace Information</a> for more information.
<p>
To access the xs:any information, use the following methods:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>const</span> lmx::c_any_info & get_any() <span class='ckw'>const</span>;
lmx::c_any_info       & get_any();
</pre></dt>
<dd>
Retrieves the <code>lmx::c_any_info</code> object corresponding to the data in the <code>xs:any</code> instance, where <code>lmx::c_any_info</code> has the following public interface:
	<p>
<pre class='proto'>
<span class='ckw'>class</span> c_any_info
{
<span class='ckw'>public</span>:
    c_any_info();
    <span class='ccom'>// Compiler generated c_any_info( const c_any_info & ar_rhs ) is OK</span>
    <span class='ccom'>// For writing during unmarshaling</span>
    c_any_info( <span class='ckw'>const</span> std::string &ar_namespace,
                            <span class='ckw'>const</span> std::string &ar_name,
                            <span class='ckw'>const</span> std::string &ar_value );
    <span class='ccom'>// For user writing xs:anyAttribute</span>
    c_any_info( <span class='ckw'>const</span> std::string &ar_name,
                            <span class='ckw'>const</span> std::string &ar_value )
    <span class='ccom'>// For user writing xs:any</span>
    c_any_info( <span class='ckw'>const</span> std::string &ar_value );
    <span class='ccom'>// Compiler generated operator = ( const c_any_info & ar_rhs ) is OK</span>
    <span class='ckw'>const</span> std::string & get_namespace() <span class='ckw'>const</span>;
    <span class='ckw'>const</span> std::string & get_name() <span class='ckw'>const</span>;
    <span class='ckw'>const</span> std::string & get_value() <span class='ckw'>const</span>;
    std::string get_local_name() <span class='ckw'>const</span>;
    <span class='ckw'>void</span> set_namespace( <span class='ckw'>const</span> std::string &ar_namespace );
    <span class='ckw'>void</span> set_name( <span class='ckw'>const</span> std::string &ar_name );
    <span class='ckw'>void</span> set_value( <span class='ckw'>const</span> std::string &ar_value );

    <span class='ckw'>const</span> c_namespace_context & get_namespace_context() <span class='ckw'>const</span>;
    c_namespace_context & get_namespace_context();
};</pre>
If the <code>xs:any</code> element corresponds to:
<p>
<ul>
<code>&lt;nsp:myElement xmlns:nsp="http://codalogic.com/example" etc....>...&lt;/nsp:myElement></code>
<p>
</ul>then:
<ul>
<li><code>get_namespace()</code> returns: <code>http://codalogic.com/example</code>
<li><code>get_name()</code> returns: <code>nsp:myElement</code>
<li><code>get_local_name()</code> returns: <code>myElement</code>
<li><code>get_value()</code> returns: <code>&lt;nsp:myElement xmlns:nsp="http://codalogic.com/example" etc....>...&lt;/nsp:myElement></code>.
</ul>
<p>
</dd>
</dl>
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> set_any( <span class='ckw'>const</span> lmx::tlmx_string &any );
</pre></dt>
<dd>Set the value of an <code>xs:any</code> element.  The specified value must include the start tag and end tag, and be UTF-8 encoded.  The value is inserted into the output using a simple copy operation.  </dd>
<p>
</dl>
(See <a href='#AccesingtheDataintheGeneratedClasses'>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</a> for the naming of <code>xs:any</code> access methods.)
<p>
Additionally, the generated code supports a legacy mode interface to <code>xs:any</code> using the following interface:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> get_any( std::string *p_namespace,
              std::string *p_name,
              std::string *p_value ) <span class='ckw'>const</span>;
</pre></dt>
<dd>Retrieves the details of an <code>xs:any</code> element.  If the <code>xs:any</code> element corresponds to:
<p>
<ul>
<code>&lt;nsp:myElement xmlns:nsp="http://codalogic.com/example" etc....>...&lt;/nsp:myElement></code>
<p>
</ul>then:
<ul>
<li><code>*p_namespace</code> is set to: <code>http://codalogic.com/example</code>
<li><code>*p_name</code> is set to: <code>nsp:myElement</code>
<li><code>*p_value</code> is set to: <code>&lt;nsp:myElement xmlns:nsp="http://codalogic.com/example" etc....>...&lt;/nsp:myElement></code>.
</ul>
<p>
<code>*p_namespace</code> and/or <code>*p_name</code> may be set to 0 (NULL) if it is not desired to retrieve their corresponding values.</dd>
<p>
</dl>


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='OptionalxsanyCInterface'></a>
<h3>2.5.11&nbsp;-&nbsp;Optional xs:any C++ Interface</h3>
<p>
An Optional <code>xs:any</code> has the same interface methods as a Singular xs:any instance as described in <a href='#SingularxsanyCInterface'>2.5.10&nbsp;-&nbsp;Singular xs:any C++ Interface</a>, plus the methods of any described in <a href='#OptionalSimpleTypeCInterface'>2.5.4&nbsp;-&nbsp;Optional Simple Type C++ Interface</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultiplexsanyCInterface'></a>
<h3>2.5.12&nbsp;-&nbsp;Multiple xs:any C++ Interface</h3>
<p>
When a document has instances xs:any it may be necessary to add extra namespace information to the <code>c_xml_reader</code> and <code>c_xml_writer</code> class.  See <a href='#AddingExtraNamespaceInformation'>3.18&nbsp;-&nbsp;Adding Extra Namespace Information</a> for more information.
<dl>
<dt>
<pre class='proto'>
size_t size_any() <span class='ckw'>const</span>;
</pre></dt><dd>Returns the number of instances of a particular <code>xs:any</code>.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>const</span> lmx::c_any_info & get_any( size_t n ) <span class='ckw'>const</span>;
lmx::c_any_info       & get_any( size_t n );
</pre></dt>
<dd>
Retrieves a reference to the <code>lmx::c_any_info</code> object representing the n-th instance of a particular <code>xs:any</code>.  The first instance is n=0.  <code>lmx::c_any_info</code> is described in <a href='#SingularxsanyCInterface'>2.5.10&nbsp;-&nbsp;Singular xs:any C++ Interface</a>.
</dd>
</dl>
(See <a href='#AccesingtheDataintheGeneratedClasses'>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</a> for the naming of <code>xs:any</code> access methods.)
<p>
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> append_any( <span class='ckw'>const</span> lmx::tlmx_string &any );
</pre></dt>
<dd>Appends an instance to a particular <code>xs:any</code>.  The specified value must include the start tag and end tag, and be UTF-8 encoded.  The value is inserted into the output using a simple copy operation.<p></dd>
</dl>
<dl>

<dt>
<pre class='proto'>
<span class='ckw'>void</span> insert_any( size_t n, <span class='ckw'>const</span> lmx::tlmx_string &any );
</pre></dt>
<dd>Inserts an instance to the n-th position of a particular <code>xs:any</code>.  The first instance is n=0.  The item previously at the n-th position is moved to the (n+1)-th position and so on.  If a value of n is specified that is larger than the size of the collection, the <code>append_any()</code> method is called.  The specified value must include the start tag and end tag, and be UTF-8 encoded.  The value is inserted into the output using a simple copy operation.</dd>
<p>
</dl>
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> delete_any( size_t n );
</pre></dt>
<dd>Deletes the n-th instance of a particular <code>xs:any</code>.  The first instance is n=0.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> clear_any();
</pre></dt><dd>Removes all items from the collection.</dd>
<p>
<dt>
<pre class='proto'>
<span class='ckw'>auto</span> in_any();
</pre></dt>
<dd>Returns iterator details that can be used in a C++11 range-based for statement.  See a related example in <a href='#MultipleComplexTypeUsageExamples'>2.5.8.1&nbsp;-&nbsp;Multiple Complex Type Usage Examples</a>.</dd><p>
</dl>
Additionally, the generated code supports a legacy mode interface to the <code>xs:any</code> using the following interface:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> get_any( size_t n,
              std::string *p_namespace, 
              std::string *p_name,
              std::string *p_value ) <span class='ckw'>const</span>;
</pre></dt>
<dd>Retrieves the details of n-th element of a particular <code>xs:any</code>.  On completion of the function, the string pointed to by p_value will include the start tag and end tag.  The first instance is n=0.
<p>
If the <code>xs:any</code> element corresponds to:
<p>
<ul>
<code>&lt;nsp:myElement xmlns:nsp="http://codalogic.com/example" etc....>...&lt;/nsp:myElement></code>
<p>
</ul>then:
<ul>
<li><code>*p_namespace</code> is set to: <code>http://codalogic.com/example</code>
<li><code>*p_name</code> is set to: <code>nsp:myElement</code>
<li><code>*p_value</code> is set to: <code>&lt;nsp:myElement xmlns:nsp="http://codalogic.com/example" etc....>...&lt;/nsp:myElement></code>.
</ul>

<p>
<code>*p_namespace</code> and/or <code>*p_name</code> may be set to 0 (NULL) if it is not desired to retrieve their corresponding values.
<p>
</dd>
</dl>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AdditionalPolymorphicMethods'></a>
<h3>2.5.13&nbsp;-&nbsp;Additional Polymorphic Methods</h3>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='FindingtheIdentityofaPolymorphicClass'></a>
<h4>2.5.13.1&nbsp;-&nbsp;Finding the Identity of a Polymorphic Class</h4>
<p>
One way to determine the type of a polymorphic class is to use C++'s RTTI.  Additionally, LMX generates methods and members that allow the identity of a class to be determined.
<p>
Each polymorphic class has the following public data member:
<dl>
<dt>
<pre class='proto'>
t_class_identity id
</pre></dt><dd>Returns a constant that is unique for the particular class.</dd>
<p>
</dl>
Each polymorphic class has the following public methods:
<dl>
<dt>
<pre class='proto'>
t_class_identity getid() <span class='ckw'>const</span>;
</pre></dt><dd> A virtual function that returns the id constant that identifies the class type.</dd>
<p>
</dl>
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> has_id( t_class_identity sought_id ) <span class='ckw'>const</span>;
</pre></dt><dd> A virtual function that returns true if the class hierarchy contains the type corresponding to sought_id.</dd>
<p>
</dl>
For example:
<pre class='code'>
    c_base *p_base = &item.get_base();
    <span class='ckw'>if</span>( p_base->getid() == c_derived::id )
    {
        c_derived *p_derived = dynamic_cast&lt;c_derived *>( p_base );
    }
</pre>
Or:
<pre class='code'>
    c_base *p_base = &item.get_base();
    <span class='ckw'>if</span>( p_base->has_id( c_derived::id ) )
    {
        c_derived *p_derived = dynamic_cast&lt;c_derived *>( p_base );
        <span class='ccom'>// Do the common things specific to c_derived</span>
    }
    <span class='ckw'>if</span>( p_base->has_id( c_more_derived::id ) )
    {
        c_more_derived *p_more_derived = dynamic_cast&lt;c_more_derived *>( p_base );
        <span class='ccom'>// Do the common things specific to c_more_derived</span>
    }
</pre>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='PolymorphicCloning'></a>
<h4>2.5.13.2&nbsp;-&nbsp;Polymorphic Cloning</h4>
<p>
To support polymorphic object duplication, LMX generates a virtual <code>clone()</code> method.  This returns a pointer to a deep copy of the object on which the <code>clone()</code> method is called.  For example:
<pre class='code'>
    c_base *p_base = item.get_base().clone();
</pre>



<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ResettingtheClass'></a>
<h3>2.5.14&nbsp;-&nbsp;Resetting the Class</h3>
<p>
Each class has a function that resets the object to the state it would be after construction.  The prototype for this function is:
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>void</span> reset();
</pre></dt>
<dd>Resets the state of the object to that as if it had just been constructed.</dd>
</dl>
<p>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='RuntimeChecking'></a>
<h3>2.5.15&nbsp;-&nbsp;Run-time Checking</h3>
<p>
LMX generates two functions for each class that can be used to check whether sufficient attributes and elements have been set for a class to be minimally valid.  
<dl>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL );
</pre></dt>
<dd>Tests whether sufficient elements and attributes have been set for the class to be valid.  <code>is_occurs_ok()</code> only checks members of its class and not members of any child or base classes.  Returns <code>true</code> if sufficient items have been set, and <code>false</code> otherwise.</dd>
<dt>
<pre class='proto'>
<span class='ckw'>bool</span> check( lmx::c_check_tracker * p_tracker_in = LMXNULL );
</pre></dt>
<dd>Recursively calls the current classes <code>is_occurs_ok()</code> method and the <code>check()</code> methods of the child classes offering a 'deep' version of <code>is_occurs_ok()</code>.  Returns <code>true</code> if sufficient items have been set, and <code>false</code> otherwise.</dd>
</dl>
<p>
One way to use these functions is in a debug version <code>assert</code> statement, e.g.:
<pre class='code'>
    c_NAME & name_ref = top.get_NAME();
    name_ref.set_CHILD( 12 );
    name_ref.set_CHILD2( 1.2 );

    assert( name_ref.is_occurs_ok() );
</pre>
<p>
If the above call to <code>is_occurs_ok()</code> finds missing components it will populate the global instance of <code>lmx::c_check_exception</code> called <code>lmx::global_check_exception</code>.  If the <code>#define</code> <code>LMX_USE_CHECK_EXCEPTIONS</code> is set to <code>1</code> or  <code>LMX_USE_CHECK_EXCEPTIONS</code> is not set and <code>LMX_USE_EXCEPTIONS</code> is set to <code>1</code> then <code>is_occurs_ok()</code> will throw a <code>lmx::c_check_exception</code> exception if it finds missing components.
<p>
<code>is_occurs_ok()</code> can also be configured to populate a local instance of <code>c_check_exception</code> using the following code:
<pre class='code'>
    lmx::c_check_exception check_exception;
    lmx::c_check_tracker check_tracker( &check_exception );
    <span class='ckw'>if</span>( ! name_ref.is_occurs_ok( &check_tracker ) )
    {
        <span class='ccom'>// Look at check_exception for details of error</span>
    }
</pre>
<p>
The <code>check()</code> method has similar behavior to the <code>is_occurs_ok()</code> method, but recursively calls the child members versions of <code>check()</code> to give a deep version of <code>is_occurs_ok()</code>.
<p>
To test the facets of simple type components LMX allows optional testing of facets when the various <code>set_NAME</code> functions are called.
<p>
See section <a href='#DebuggingSupport'>3.16.5&nbsp;-&nbsp;Debugging Support</a> for more information on these features.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='TheAbbreviatedTypeNotation'></a>
<h2>2.6&nbsp;-&nbsp;The Abbreviated Type Notation</h2>
<p>
In both the generated C++ header file and the HTML documentation file an abbreviated notation is used to describe the various types.  The intention is to allow you to work mainly from the generated C++ header file or HTML file without having to refer to the actual schema definition, thus speeding up the development process.  This section describes the format.
<p>
The complete abbreviated type notation has the form:
<pre class='anot'>
    name_in_schema --> type { facets } [ cardinality ]
</pre>
The <code>name_in_schema</code> field is the name of the item from the schema (possibly made ASCII safe).  If the item is an xs:any element, then the field is set to <code>{any}</code>.  If the item is the body of a Simple Content element, the field is set to <code>{body}</code>.
<p>
The <code>type</code> is the type of the item.  This may be one of the built-in schema types (e.g. xs:string) or the name of a type defined elsewhere in the schema.  If the type is a built-in schema type, its name is prefixed by <code>xs:</code> irrespective of whether the schema namespace prefix has been set to <code>xs</code>.
<p>
The <code>facets</code> field specifies (some of) the facets applied to a type by a schema.  The <code>facets</code> are wrapped in curly braces and each facet description is separated by a comma.  If there are no relevant facets, the <code>facets</code> field and the enclosing curly braces are omitted. Currently this field captures pattern, min/max and length facets.  Enumeration facets are documented along with the methods for reading and writing items via enumeration (e.g. <code>getenum_NAME</code> and <code>setenum_NAME</code>).
<p>
A pattern facet follows the Perl regular expression format without the beginning and end anchors.  That is:
<pre class='anot'>
    /pattern/
</pre>
The min and max range facets have the form:
<pre class='anot'>
    min_value &lt;= x &lt; max_value
</pre>
If either the min or the max limits are not specified, then the corresponding leg of the facet description is omitted.  For example, if no min_value were specified, the following format would be used:
<pre class='anot'>
    x &lt; max_value
</pre>
The comparison operator shown in the description (e.g. &lt; or &lt;=) depends on whether the facet is exclusive or inclusive.
<p>
Length facets are documented for <code>xs:string</code>, <code>xs:hexBinary</code> and <code>xs:base64Binary</code> types where specified.  The facet is documented as:
<pre class='anot'>
    min_length .. max_length
</pre>
If the maximum length is unbounded, the following form is used:
<pre class='anot'>
    min_length .. *
</pre>
If the minimum length and the maximum length are the same, this is documented as:
<pre class='anot'>
    length .. length
</pre>
<p>
The cardinality field specifies how many instances of the item are allowed.  If the field is absent (including absence of the square brackets), one, and only one, occurrence of the item is allowed.  If the field is present, the general format is:
<pre class='anot'>
    [ min .. max ]
</pre>
where <code>min</code> specifies the minimum number of times the item can occur and <code>max</code> specifies the maximum number of times an item can occur.  If <code>min</code> and <code>max</code> are the same values, then the following form is used:
<pre class='anot'>
    [ min ]
</pre>
If the maximum number of occurrences is unbounded, then the following form is used:
<pre class='anot'>
    [ min .. * ]
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AbbreviatedTypeNotationExamples'></a>
<h3>2.6.1&nbsp;-&nbsp;Abbreviated Type Notation Examples</h3>
<p>
To illustrate the Abbreviated Type Notation, the following examples are presented:
<pre class='anot'>
    e1 --> xs:unsignedShort
</pre>
<code>e1</code> is an unsigned short that can occur once, and only once.
<pre class='anot'>
    e2 --> xs:unsignedShort [0..1]
</pre>
<code>e2</code> is an optional unsigned short.  It can occur zero or one time.
<pre class='anot'>
    e3 --> xs:unsignedShort { 0&lt;=x&lt;1000 }
</pre>
<code>e3</code> is an unsigned short that is constrained to be greater than or equal to 0 and less than 1000.  It can occur once, and only once.
<pre class='anot'>
    e4 --> xs:unsignedShort { 0&lt;=x&lt;1000 }[0..1]
</pre>
<code>e4</code> is an unsigned short that is constrained to be greater than or equal to 0 and less than 1000.  It can occur zero or one time.
<pre class='anot'>
    e5 --> xs:unsignedShort { 0&lt;x&lt;=1000 }[1..*]
</pre>
<code>e5</code> is an unsigned short that is constrained to be greater than 0 and less than or equal to 1000.  It can occur one or more times.
<pre class='anot'>
    e6 --> xs:string { /a\d/,/b\d\d/ }[1..*]
</pre>
<code>e6</code> is a string that must match the pattern a\d or b\d\d (e.g. 'a1' or 'b12').  It can occur one or more times.
<pre class='anot'>
    e7 --> xs:string { 1..5 }[1..*]
</pre>
<code>e7</code> is a string that can be between 1 and 5 characters long.  It can occur one or more times.

<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='InMoreDepth'></a>
<h1>3&nbsp;-&nbsp;In More Depth</h1>
</skip>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Configurationusinglmxuserh'></a>
<h2>3.1&nbsp;-&nbsp;Configuration using lmxuser.h</h2>
<p>
As already alluded to, in addition to configuring data binding behavior via the LMX executable, you can also control the behavior by setting various <code>C++ #define</code>s and editing <code>USER:</code> sections in <code>lmxuser.h</code>.
<p>
For a number of features, the effect of <code>lmxuser.h</code> can be changed by setting <code>C++ #define</code>s.  This can be done using <code>-#define</code> flag or in your C++ project or makefiles.
<p>
If a large number of defines need to be used, it may be easier to use the <code>-lmxuser-defs</code> flag, or define <code>LMX_WANT_USER_DEFS</code> in your project/makefile.  This will cause <code>lmxuser.h</code> to <code>#include "lmxuser-defs.h"</code> and you can set your other <code>#define</code>s via the included file.
<p>
You can also specify the <code>-lmxuser-defs-end</code> flag or define <code>LMX_WANT_USER_DEFS_END</code> in your project/makefile, (perhaps in the <code>lmxuser-defs.h</code> file), and this will cause the file <code>lmxuser-defs-end.h</code> to be included at the end of <code>lmxuser.h</code>.  This allows further customization of LMX behavior using features that have been defined by <code>lmxuser.h</code>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Unmarshalingadvancedforms'></a>
<h2>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</h2>
<a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a> describes the simple method for unmarshaling object content direct from files and memory.  In certain situations more flexibility is required, and the following more advanced techniques may be required.
<p>
To read XML from an in-memory buffer, code similar to the following can be used:
<pre class='code'>
    lmx::c_xml_reader_memory reader( xml_message_data_buffer, 
                                        number_of_bytes_in_buffer );

    c_generated_xsd_root_class top_object;

    lmx::elmx_error error = top_object.unmarshal( reader );

    <span class='ckw'>if</span>( error == lmx::ELMX_OK )
    {
        <span class='ckw'>const</span> c_generated_xsd_root_class & const_top_object = top_object;
        ...
</pre>
To read XML from a C++ <code>std::string</code>, the <code>lmx::c_xml_reader_string</code> class can be used in place of <code>lmx::c_xml_reader_memory</code> in the code above.
<p>
To read XML from an instance of <code>lmx::c_any_info</code>, the <code>lmx::c_xml_reader_any_info</code> class can be used.
<p>
To read XML from a file, code similar to the following can be used:
<pre class='code'>
    lmx::c_xml_reader_file reader( "c:\\myxml.xml" );

    <span class='ckw'>if</span>( reader.is_open() )
    {
        c_generated_xsd_root_class top_object;

        lmx::elmx_error error = top_object.unmarshal( reader );

        <span class='ckw'>if</span>( error == lmx::ELMX_OK )
            {
            <span class='ckw'>const</span> c_generated_xsd_root_class & const_top_object = top_object;
            ...
</pre>
Looking more closely at the in-memory case, we first create an object that will do low-level read operations from memory.  This is an instance of <code>c_xml_reader_memory</code> from the <code>lmx</code> namespace.  The constructor for this object takes a pointer to the buffer as the first argument and the number of valid bytes in the buffer as the second argument.
<pre class='code'>
    lmx::c_xml_reader_memory reader( xml_message_data_buffer, 
                                        number_of_bytes_in_buffer );
</pre>
We then create an instance of the top-level class generated by the LMX code generator.  The name of this class will differ.  If there is only one global element, the relevant class will be that of the global element.  Alternatively, the name is either derived from the namespace prefix assigned to the schema's target namespace, or is c_root.  It is normally the last class defined in the .h file.
<pre class='code'>
    c_generated_xsd_root_class top_object;
</pre>
To do the unmarshaling, the unmarshal method of the top level object is called, giving it a reference to the low-level reader class.  Note that you must always unmarshal into a freshly created object otherwise the results may be unpredictable.  The method returns an error code.
<pre class='code'>
    lmx::elmx_error error = top_object.unmarshal( reader );
</pre>
If the returned error code is <code>lmx::ELMX_OK</code> then unmarshaling has been successful, and the data structure can be interrogated.  Section <a href='#ErrorCodes'>3.9&nbsp;-&nbsp;Error Codes</a> lists other possible error codes.
<pre class='code'>
    <span class='ckw'>if</span>( error == lmx::ELMX_OK )
    {
</pre>
Having determined that the unmarshalled object is suitable for processing, it is advisable to create a const version of the class reference to avoid accidentally modifying the various objects.
<pre class='code'>
        <span class='ckw'>const</span> c_generated_xsd_root_class & const_top_object = top_object;
        ...
</pre>
Unmarshaling from a file is a similar process, however in this case the <code>c_xml_reader_file</code> class from the <code>lmx</code> namespace is used as the type for the low-level reader.  The constructor takes a single argument, which is the name of the file from which to read.
<pre class='code'>
    lmx::c_xml_reader_file reader( "c:\\myxml.xml" );
</pre>
Having created the <code>c_xml_reader_file</code> instance, it is necessary to test whether the file has been successfully opened by calling the <code>is_open</code> method.  (This method can also be called on an object of type <code>c_xml_reader_memory</code>, <code>c_xml_reader_string</code> or <code>c_xml_reader_any_info</code>, but this always returns true.)
<pre class='code'>
    <span class='ckw'>if</span>( reader.is_open() )
    {
</pre>
If the file is successfully opened, the unmarshaling operation continues as for the from memory case, e.g.:
<pre class='code'>
        c_generated_xsd_root_class top_object;

        lmx::elmx_error error = top_object.unmarshal( reader );

        <span class='ckw'>if</span>( error == lmx::ELMX_OK )
        {
            <span class='ckw'>const</span> c_generated_xsd_root_class & const_top_object = top_object;
            ...
</pre>
Note that during unmarshaling memory may be dynamically allocated, which may cause exceptions to be thrown.  Therefore it may be appropriate to include <code>try/catch</code> blocks at some level in your code.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='UnmarshalingwithAdditionalControlwhenReadingXMLInput'></a>
<h3>3.2.1&nbsp;-&nbsp;Unmarshaling with Additional Control when Reading XML Input</h3>
<p>
If additional control is required over the way XML is read, a further method for unmarshaling is available.  The interface class for reading XML input is <code>c_read</code>, which is defined in <code>lmxparse.h</code>.  To implement reading from different sources, or perform special processing while reading (such a reading from a socket or a compressed file), implement a concrete class that derives from <code>c_read</code> and implements the relevant virtual methods.  Assuming such a concrete class is called <code>c_my_reader</code>, the code to unmarshal using this class would be:
<pre class='code'>
    c_my_reader low_level_reader( ...relevant parameters... );

    lmx::c_xml_reader reader( low_level_reader );

    c_generated_xsd_root_class top_object;

    lmx::elmx_error error = top_object.unmarshal( reader );

    <span class='ckw'>if</span>( error == lmx::ELMX_OK )
    {
        <span class='ckw'>const</span> c_generated_xsd_root_class & const_top_object = top_object;
        ...
</pre>
The key part is creating an instance of the concrete class and then passing it to an instance of <code>lmx::c_xml_reader</code>.  The rest of the unmarshaling operation is the same as described in <a href='#Unmarshalingadvancedforms'>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='UnmarshallingMultipleXMLInstancesfromtheSameSource'></a>
<h3>3.2.2&nbsp;-&nbsp;Unmarshalling Multiple XML Instances from the Same Source</h3>
<p>
If you wish to read multiple XML instances from the same input source you can create a single low-level reader (such as <code>lmx::c_read_file</code>, <code>c_read_memory</code> and <code>c_read_string</code>) and use that to construct multiple instances of <code>c_xml_reader</code> from which to read each new XML instance.  For example:

<pre class='code'>
    <span class='ccom'>// Setup the input source</span>
    lmx::c_read_file file_reader( file_in );

    <span class='ckw'>for</span>(;;)
    {
        <span class='ccom'>// Create new c_xml_reader to read from the input source</span>
        lmx::c_xml_reader xml_reader( file_reader );

        <span class='ccom'>// Read the XML</span>
        lmx::elmx_error lmx_error;
        c_MyElement item( xml_reader, &lmx_error );

        <span class='ccom'>// An error will be reported if there is no input XML</span>
        <span class='ckw'>if</span>( lmx_error != lmx::ELMX_OK )
            <span class='ckw'>break</span>;

        <span class='ccom'>// TODO: Process data in 'item'</span>
    }
</pre>
See also <a href='#MarshallingMultipleXMLInstancestotheSameDestination'>3.5.1&nbsp;-&nbsp;Marshalling Multiple XML Instances to the Same Destination</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CheckingfortrailingnonXMLmaterial'></a>
<h3>3.2.3&nbsp;-&nbsp;Checking for trailing non-XML material</h3>
<p>
If you wish to check that your unmarshalled XML does not have non-valid XML end matter following it, you can use the <code>c_xml_reader::is_xml_end()</code> method.
<pre class='code'>
    lmx::c_xml_reader_string reader( xml_message );

    lmx::elmx_error error;
    c_generated_xsd_root_class top_object( reader, &error );

    <span class='ckw'>if</span>( error == lmx::ELMX_OK && reader.is_xml_end() )
    {
        ...
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='UnmarshallingSchemaFragments'></a>
<h3>3.2.4&nbsp;-&nbsp;Unmarshalling Schema Fragments</h3>
<p>
Typically an entry point for initiating an unmarshal process corresponds to a global element definition.  If you wish to unmarshal an item that corresponds to a global type you need to use the <code>unmarshal_partial</code> template functions located in <code>lmxparse.h</code>.  These have the prototypes:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    elmx_error unmarshal_partial(
            c_xml_reader & ar_reader,
            T *ap_item,
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string &ar_namespace,
            <span class='ckw'>const</span> std::string &ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    elmx_error unmarshal_partial(
            T *ap_item,
            <span class='ckw'>const</span> <span class='ckw'>char</span> ac_file_name[],
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string &ar_namespace,
            <span class='ckw'>const</span> std::string &ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    elmx_error unmarshal_partial(
            T *ap_item,
            <span class='ckw'>const</span> wchar_t ac_file_name[],
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string &ar_namespace,
            <span class='ckw'>const</span> std::string &ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    elmx_error unmarshal_partial(
            T *ap_item,
            <span class='ckw'>const</span> <span class='ckw'>char</span> *ap_memory,
            size_t a_memory_size,
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string &ar_namespace,
            <span class='ckw'>const</span> std::string &ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    elmx_error unmarshal_partial(
            T *ap_item,
            <span class='ckw'>const</span> std::string &ar_string,
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string &ar_namespace,
            <span class='ckw'>const</span> std::string &ar_local_name )
</pre>
The first two read XML from a file, the third from an array of bytes, the fourth from a std::string and the last one from an <code>lmx::c_xml_reader</code> object.
<p>
The parameters have the following meaning:
<dl>
<dt>ar_reader</dt><dd>A reference to an LMX reader object.</dd>
<dt>ap_item</dt><dd>A pointer to the object that is will receive the unmarshalled data.</dd>
<dt>ac_file_name</dt><dd>The name of a file to be parsed.</dd>
<dt>ap_memory</dt><dd>A pointer to memory containing XML to be parsed.</dd>
<dt>a_memory_size</dt><dd>The number of bytes pointer to be ap_memory.</dd>
<dt>ar_string</dt><dd>A std::string containing XML to be parsed.</dd>
<dt>ac_ns_map</dt><dd>The generated namespace map for the schema to be unmarshalled.  It can be found by looking in the generated <code>.h</code> file and has the name <code>ns_map_reader</code>.  You may need to include the C++ namespace with the variable name, e.g. <code>my_cpp_namespace::ns_map_reader</code>.</dd>
<dt>ar_namespace</dt><dd>The XML namespace of the root element that is to be unmarshalled.  If there is no namespace, set this to <code>""</code>.</dd>
<dt>ar_local_name</dt><dd>The local part of the name of the root element to be unmarshalled, without any namespace or namespace prefix information.</dd>
</dl>
An example usage is:
<pre class='code'>
    c_my_object   my_object;
    lmx::elmx_error error = lmx::unmarshal_partial(
            "myFile.xml",
            &my_object,
            my_cpp_namespace::ns_map_reader,
            "http://myDomain.com",    <span class='ccom'>// or "" if no namespace</span>
            "localName" );
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='UnmarshallingaSubelementwithinanXMLInstance'></a>
<h2>3.3&nbsp;-&nbsp;Unmarshalling a Sub-element within an XML Instance</h2>
<p>
If you wish to only unmarshal a particular element within an XML instance you can use the <code>unmarshal_find</code> template function located in <code>lmxparse.h</code>.  This is available in the following forms:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    <span class='ckw'>bool</span> /*is_found*/ unmarshal_find(
            c_xml_reader & ar_reader,
            elmx_error * ap_error,
            T * ap_item,
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string & ar_sought_namespace,
            <span class='ckw'>const</span> std::string & ar_sought_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    <span class='ckw'>bool</span> /*is_found*/ unmarshal_find(
            elmx_error * ap_error,
            T * ap_item,
            <span class='ckw'>const</span> <span class='ckw'>char</span> ac_file_name[],
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string & ar_namespace,
            <span class='ckw'>const</span> std::string & ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    <span class='ckw'>bool</span> /*is_found*/ unmarshal_find(
            elmx_error * ap_error,
            T * ap_item,
            <span class='ckw'>const</span> wchar_t ac_file_name[],
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string & ar_namespace,
            <span class='ckw'>const</span> std::string & ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    <span class='ckw'>bool</span> /*is_found*/ unmarshal_find(
            elmx_error * ap_error,
            T * ap_item,
            <span class='ckw'>const</span> <span class='ckw'>char</span> * ap_memory,
            size_t a_memory_size,
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string & ar_namespace,
            <span class='ckw'>const</span> std::string & ar_local_name );

    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    <span class='ckw'>bool</span> /*is_found*/ unmarshal_find(
            elmx_error * ap_error,
            T * ap_item,
            <span class='ckw'>const</span> std::string & ar_string,
            <span class='ckw'>const</span> s_ns_map ac_ns_map[],
            <span class='ckw'>const</span> std::string & ar_namespace,
            <span class='ckw'>const</span> std::string & ar_local_name );
</pre>
<p>
The parameters have the following meaning:
<dl>
<dt>ar_reader</dt><dd>A reference to an LMX reader object.</dd>
<dt>ap_error</dt><dd>A pointer to where any error code is to be placed when unmarshalling is completed.</dd>
<dt>ap_item</dt><dd>A pointer to the object that is will receive the unmarshalled data.</dd>
<dt>ac_file_name</dt><dd>The name of a file to be parsed.</dd>
<dt>ap_memory</dt><dd>A pointer to memory containing XML to be parsed.</dd>
<dt>a_memory_size</dt><dd>The number of bytes pointer to be ap_memory.</dd>
<dt>ar_string</dt><dd>A std::string containing XML to be parsed.</dd>
<dt>ac_ns_map</dt><dd>The generated namespace map for the schema to be unmarshalled.  It can be found by looking in the generated <code>.h</code> file and has the name <code>ns_map_reader</code>.  You may need to include the C++ namespace with the variable name, e.g. <code>my_cpp_namespace::ns_map_reader</code>.</dd>
<dt>ar_namespace</dt><dd>The XML namespace of the root element that is to be unmarshalled.  If there is no namespace, set this to <code>""</code>.</dd>
<dt>ar_local_name</dt><dd>The local name of the root element to be unmarshalled, without any namespace or namespace prefix information.</dd>
</dl>
The function returns <code>true</code> if the specified element was found and <code>false</code> if not.
<p>
<code>unmarshal_find()</code> is available in the following variants:
<pre class='code'>
</pre>
<p>
An example usage is:
<pre class='code'>
    c_my_object  my_object;
    lmx::elmx_error  error;
    <span class='ckw'>bool</span> is_found = lmx::unmarshal_find(
            &error,
            &my_object,
            "myfile.xml",
            my_cpp_namespace::ns_map_reader,
            "http://myDomain.com",    <span class='ccom'>// or "" if no namespace</span>
            "localName" );
    <span class='ckw'>if</span>( is_found && error != lmx::ELMX_OK )
    {...}
</pre>


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='UnmarshallingMultipleSubelementswithinanXMLInstance'></a>
<h2>3.4&nbsp;-&nbsp;Unmarshalling Multiple Sub-elements within an XML Instance</h2>
<p>
If you wish to only unmarshal a subset of elements within an XML instance you can use the <code>unmarshal_select</code> functions located in <code>lmxselected.h</code>.  These have the prototypes:
<pre class='code'>
    <span class='ckw'>bool</span> /*is_complete*/ unmarshal_select(
            c_xml_reader & ar_reader,
            lmx::elmx_error * ap_error,
            <span class='ckw'>const</span> lmx::s_ns_map ac_ns_map[],
            lmx::tc_elements_to_select ac_elements_to_select,
            lmx::c_selected_element * ap_handler );

    <span class='ckw'>bool</span> /*is_complete*/ unmarshal_select(
            lmx::elmx_error * ap_error,
            <span class='ckw'>const</span> <span class='ckw'>char</span> ac_file_name[],
            <span class='ckw'>const</span> lmx::s_ns_map ac_ns_map[],
            lmx::tc_elements_to_select ac_elements_to_select,
            lmx::c_selected_element * ap_handler );

    #if LMX_WANT_WIDE_FILE_NAMES == 1
    <span class='ckw'>bool</span> /*is_complete*/ unmarshal_select(
            lmx::elmx_error * ap_error,
            <span class='ckw'>const</span> wchar_t ac_file_name[],
            <span class='ckw'>const</span> lmx::s_ns_map ac_ns_map[],
            lmx::tc_elements_to_select ac_elements_to_select,
            lmx::c_selected_element * ap_handler );
    #endif

    <span class='ckw'>bool</span> /*is_complete*/ unmarshal_select(
            lmx::elmx_error * ap_error,
            <span class='ckw'>const</span> <span class='ckw'>char</span> * ap_memory,
            size_t a_memory_size,
            <span class='ckw'>const</span> lmx::s_ns_map ac_ns_map[],
            lmx::tc_elements_to_select ac_elements_to_select,
            lmx::c_selected_element * ap_handler );

    <span class='ckw'>bool</span> /*is_complete*/ unmarshal_select(
            lmx::elmx_error * ap_error,
            <span class='ckw'>const</span> std::string & ar_string,
            <span class='ckw'>const</span> lmx::s_ns_map ac_ns_map[],
            lmx::tc_elements_to_select ac_elements_to_select,
            lmx::c_selected_element * ap_handler );</pre>
<p>
The parameters have the following meaning:
<dl>
<dt>ar_reader</dt><dd>A reference to an LMX reader object.</dd>
<dt>ap_error</dt><dd>A pointer to where any error code is to be placed when unmarshalling is completed.</dd>
<dt>ac_file_name</dt><dd>The name of a file to be parsed.</dd>
<dt>ap_memory</dt><dd>A pointer to memory containing XML to be parsed.</dd>
<dt>a_memory_size</dt><dd>The number of bytes pointer to be ap_memory.</dd>
<dt>ar_string</dt><dd>A std::string containing XML to be parsed.</dd>
<dt>ac_ns_map</dt><dd>The generated namespace map for the schema to be unmarshalled.  It can be found by looking in the generated <code>.h</code> file and has the name <code>ns_map_reader</code>.  You may need to include the C++ namespace with the variable name, e.g. <code>my_cpp_namespace::ns_map_reader</code>.</dd>
<dt>ac_elements_to_select</dt><dd>An array containing the namespaces and local names of the elements being selected.  The final entry in the array is marked by both fields being set to NULL.</dd>
<dt>ap_handler</dt><dd>A pointer to a base class of type <code>lmx::c_selected_element</code> that is called when a selected element is found.  This is described further below.</dd>
</dl>
The function returns <code>true</code> if the operation was complete and <code>false</code> if not.
<p>
<code>lmx::tc_elements_to_select</code> is defined as:
<pre class='code'>
    <span class='ckw'>typedef</span> <span class='ckw'>struct</span> s_elements_to_select
    {
        <span class='ckw'>const</span> <span class='ckw'>char</span> *p_namespace;
        <span class='ckw'>const</span> <span class='ckw'>char</span> *p_local_name;
    } tc_elements_to_select[];    <span class='ccom'>// Last member marked by NULL values</span>
</pre>
<code>lmx::c_selected_element</code> is defined as:
<pre class='code'>
    <span class='ckw'>class</span> c_selected_element
    {
    <span class='ckw'>public</span>:
        <span class='ckw'>enum</span> elmx_unmarshal_select_result { E_STOP, E_PARSED, E_SKIP };

        virtual elmx_unmarshal_select_result element_found(
            c_xml_reader & ar_reader,
            elmx_error *ap_error,
            <span class='ckw'>const</span> std::string &ar_sought_namespace,
            <span class='ckw'>const</span> std::string &ar_sought_local_name,
            <span class='ckw'>const</span> std::string &ar_full_element_name ) = 0;
    };
</pre>
<p>
To use <code>unmarshal_select()</code> you define a class that derives from 
<code>lmx::c_selected_element</code> and implements an <code>element_found()</code> virtual method. 
<p>
You then give the <code>unmarshal_select()</code> function a list of element names that you want to process in an instance of the <code>lmx::tc_elements_to_select</code> array.
<p>
Each time <code>unmarshal_select()</code> finds one of the elements you asked for it calls the <code>lmx::c_selected_element::element_found()</code> virtual method and you can decide how to process it.
<p>
<code>lmx::c_selected_element::element_found()</code> returns either <code>lmx::c_selected_element::E_PARSED</code> to indicate that it parsed the element, <code>lmx::c_selected_element::E_SKIP</code> to indicate that it did not parse the element and the <code>unmarshal_select()</code> function should skip over it, or <code>lmx::c_selected_element::E_STOP</code> to indicate that parsing should be stopped.
<p>
An example usage of <code>unmarshal_select()</code> is as follows:
<pre class='code'>
    #include "selected.h"
    #include "lmxparse.h"
    #include &lt;fstream>
    #include &lt;sstream>
    #include &lt;iostream>

    #include "lmxselected.h"

    <span class='ccom'>// 1. Setup an array with a list of elements that we are interested in.</span>
    <span class='ccom'>// Need namespace and local name.  The end of the list is marked by all</span>
    <span class='ccom'>// NULLs.</span>
    lmx::tc_elements_to_select mc_elements_to_select = {
        { "http://xml2cpp.com/selected.xsd", "stat" },
        { 0, 0 } };

    <span class='ccom'>// 2. Define a class that contains a callback that will be called when the</span>
    <span class='ccom'>// sought element is found.  This is derived from lmx::c_selected_element.</span>
    <span class='ccom'>// This example is intended to just find the max and total values of the</span>
    <span class='ccom'>// input.</span>
    <span class='ckw'>class</span> c_selected : <span class='ckw'>public</span> lmx::c_selected_element
    {
    <span class='ckw'>private</span>:
        <span class='ckw'>int</span> count;
        <span class='ckw'>int</span> max_height;
        <span class='ckw'>int</span> total_height;
        <span class='ckw'>int</span> max_width;
        <span class='ckw'>int</span> total_width;

    <span class='ckw'>public</span>:
        c_selected() : count( 0 ), max_height( 0 ), 
                     total_height( 0 ), max_width( 0 ), total_width( 0 )
        {}

        <span class='ccom'>// 3. This is the virtual function that is called when the element is found.</span>
        virtual elmx_unmarshal_select_result
                        element_found(
                                lmx::c_xml_reader & ar_reader,
                                lmx::elmx_error *ap_error,
                                <span class='ckw'>const</span> std::string &ar_sought_namespace,
                                <span class='ckw'>const</span> std::string &ar_sought_local_name,
                                <span class='ckw'>const</span> std::string &ar_full_element_name );

        <span class='ckw'>void</span> print( std::wostream &ar_os ) <span class='ckw'>const</span>
        {
            ar_os &lt;&lt; L"Max Height: " &lt;&lt; max_height&lt;&lt; L"\n" &lt;&lt;
                    L"Total Height: " &lt;&lt; total_height&lt;&lt; L"\n" &lt;&lt;
                    L"Max Width: " &lt;&lt; max_width&lt;&lt; L"\n" &lt;&lt;
                    L"Total Width: " &lt;&lt; total_width &lt;&lt; L"\n";
        }
    };

    std::wostream & <span class='ckw'>operator</span> &lt;&lt; ( std::wostream &ar_os, <span class='ckw'>const</span> c_selected &ar_selected )
    {
        ar_selected.print( ar_os );
        <span class='ckw'>return</span> ar_os;
    }

    <span class='ccom'>// 4. The implementation of the virtual function that is called when the</span>
    <span class='ccom'>// element is found.</span>
    c_selected::elmx_unmarshal_select_result
            c_selected::element_found(
                    lmx::c_xml_reader & ar_reader,
                    lmx::elmx_error *ap_error,
                    <span class='ckw'>const</span> std::string &ar_sought_namespace,
                    <span class='ckw'>const</span> std::string &ar_sought_local_name,
                    <span class='ckw'>const</span> std::string &ar_full_element_name )
    {
        <span class='ccom'>// 5. Let's say we skip the second occurence of the element</span>
        <span class='ckw'>if</span>( ++count == 2 )
            <span class='ckw'>return</span> c_selected_element::E_SKIP;

        <span class='ccom'>// 6. ...and stop at the 5th occurence</span>
        <span class='ckw'>else</span> <span class='ckw'>if</span>( count >= 5 )
            <span class='ckw'>return</span> c_selected_element::E_STOP;

        <span class='ccom'>// 7. Unmarshal what we are interested in</span>
        c_statType l_stat;
        *ap_error = l_stat.unmarshal( ar_reader, ar_full_element_name );

        <span class='ccom'>// 8. And if everything is all right, do something with it</span>
        <span class='ckw'>if</span>( *ap_error == lmx::ELMX_OK )
        {
            std::wcout &lt;&lt; L"An element: Name=" &lt;&lt; l_stat.get_name() &lt;&lt;
                        L", Height=" &lt;&lt; l_stat.get_height() &lt;&lt;
                        L", Width=" &lt;&lt; l_stat.get_width() &lt;&lt; L"\n";

            <span class='ckw'>if</span>( l_stat.get_height() > max_height )
                max_height = l_stat.get_height();
            total_height += l_stat.get_height();
            <span class='ckw'>if</span>( l_stat.get_width() > max_width )
                max_width = l_stat.get_width();
            total_width += l_stat.get_width();
        }

        <span class='ccom'>// 9. Say that we parsed the XML</span>
        <span class='ckw'>return</span> c_selected_element::E_PARSED;
    }

    <span class='ccom'>// 10. Now to actually use what we have written...</span>
    <span class='ckw'>int</span> test_it( <span class='ckw'>const</span> <span class='ckw'>char</span> ac_file_in[] )
    {
        <span class='ccom'>// 11. Create an instance of our callback class.</span>
        c_selected l_selected;

        <span class='ccom'>// 12. Create an LMX reader to read XML from a file</span>
        lmx::c_xml_reader_file l_reader( ac_file_in );
        <span class='ckw'>if</span>( ! l_reader.is_open() )
            <span class='ckw'>return</span> 1;

        <span class='ccom'>// 13. We need to be able to return an LMX error code</span>
        lmx::elmx_error l_error;

        <span class='ccom'>// 14. Actually call the LMX selective unmarsharshalling functionality</span>
        <span class='ckw'>if</span>( lmx::unmarshal_select(
                    &l_error,               <span class='ccom'>// Place to store any LMX error code</span>
                    ac_file_in,             <span class='ccom'>// XML file name</span>
                    ns_map_reader,          <span class='ccom'>// List of namespaces relevant to </span>
                                            <span class='ccom'>// this XML schema (created by LMX)</span>
                    mc_elements_to_select,  <span class='ccom'>// List of sought element names</span>
                    &l_selected ) )         <span class='ccom'>// Object to be called when elements </span>
                                            <span class='ccom'>// found</span>
            std::wcout &lt;&lt; L"All the XML was parsed\n";
        <span class='ckw'>else</span>
            std::wcout &lt;&lt; L"XML parsed was terminated before the end of the input\n";

        <span class='ccom'>// 15. Check if everything went OK</span>
        <span class='ckw'>if</span>( l_error != lmx::ELMX_OK )
        {
            std::wcout &lt;&lt; L"Unable to unmarshal " &lt;&lt; lmx::convert( ac_file_in ) &lt;&lt; L"\n";

            <span class='ckw'>return</span> 2;
        }

        <span class='ccom'>// 16. Print out the callback classes collected results</span>
        std::wcout &lt;&lt; l_selected;

        <span class='ckw'>return</span> 0;
    }
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Marshalingadvancedforms'></a>
<h2>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</h2>
<p>
<a href='#Marshalingsimpleform'>2.4&nbsp;-&nbsp;Marshaling (simple form)</a> describes the simple method for marshaling object content direct to files and memory.  In certain situations more flexibility is required, and the following more advanced techniques may be required.
<p>
Marshaling is the process converting the C++ object content into XML data.  An advanced section of marshaling code for writing the XML to a string looks as follows:
<pre class='code'>
        c_generated_xsd_root_class top_object;

        <span class='ccom'>// ... Populate and manipulate top_object ... </span>

        std::ostringstream sos;

        lmx::c_xml_writer writer( sos );

        top_object.marshal( writer );

        std::string string_out( sos.str() );
</pre>
Breaking this down into its component parts, we first create an instance of the top-level class generated by the LMX code generator.  (See the description in section <a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a> on the name given to the top level class.)  This is populated either by interacting with the object's methods (see <a href='#AccesingtheDataintheGeneratedClasses'>2.5&nbsp;-&nbsp;Accesing the Data in the Generated Classes</a>), performing an unmarshaling operation as described in  <a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a> or a combination of the two.
<p>
The first part of the marshaling operation is to create an instance of a class that is derived from <code>std::ostream</code>.  This is where the output will be written.  The line below uses the class derived from <code>std::ostream</code> by the C++ library for outputting to a string, but the line <code>std::ofstream sos;</code> could equally be used for outputting to a file.
<pre class='code'>
        std::ostringstream sos;
</pre>
Now create a low-level LMX XML writer object of type <code>lmx::c_xml_writer</code>, telling it to write using the <code>sos</code> object.
<pre class='code'>
        lmx::c_xml_writer writer( sos );
</pre>
Tell the generated top-level object to marshal itself using the <code>writer</code> object by calling the top-level object's <code>marshal</code> method and giving it a reference to the <code>writer</code> low-level XML writer object:
<pre class='code'>
        top_object.marshal( writer );
</pre>
Finally, for when writing to a string, get the output into a form where it is more readily usable:
<pre class='code'>
        std::string string_out( sos.str() );
</pre>
<code>string_out</code> is then a <code>std::string</code> object containing the marshaled XML.

<p>
The equivalent code for writing to a file is as follows:
<pre class='code'>
        c_generated_xsd_root_class top_object;

        <span class='ccom'>// Open a file using the C++ class derived from ostream</span>
        <span class='ccom'>// for writing to a file</span>
        std::ofstream fos( "c:\\myfile.xml" );

        <span class='ccom'>// If the file is opened successfully</span>
        <span class='ckw'>if</span>( fos.is_open() )
        {
            <span class='ccom'>// Create an instance of an LMX writer class,</span>
            <span class='ccom'>// giving it a reference to the opened file's</span>
            <span class='ccom'>// stream</span>
            lmx::c_xml_writer writer( fos );

            <span class='ccom'>// Tell the top_object to marshal its contents</span>
            <span class='ccom'>// using the LMX writer class</span>
            top_object.marshal( writer );
        }
</pre>
At the end of the above operations, the file <code>c:\myfile.xml</code> will contain the marshaled XML.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MarshallingMultipleXMLInstancestotheSameDestination'></a>
<h3>3.5.1&nbsp;-&nbsp;Marshalling Multiple XML Instances to the Same Destination</h3>
<p>
If you wish to marshal multiple XML instances to the same output destination you can create a single C++ output stream and use that to construct multiple instances of <code>c_xml_writer</code> with which to write each new XML instance.  For example:

<pre class='code'>
    <span class='ccom'>// Setup output destination</span>
    std::ofstream fos( file_out );

    <span class='ckw'>if</span>( fos.is_open() )
    {
        c_MyElement * p_item;

        <span class='ckw'>while</span>( (p_item = get_item_data()) != 0 )
        {
            <span class='ccom'>// Create a new c_xml_writer to the output destination</span>
            <span class='ccom'>// (The 0 for the t_writer_options prevents the XMLDecl being output)</span>
            lmx::c_xml_writer xml_writer( fos, 0 );

            <span class='ccom'>// Write out the XML</span>
            p_item->marshal( xml_writer );
        }
    }
</pre>
See also <a href='#UnmarshallingMultipleXMLInstancesfromtheSameSource'>3.2.2&nbsp;-&nbsp;Unmarshalling Multiple XML Instances from the Same Source</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SelectingtheInputFileTypeXSDWSDLDTD'></a>
<h2>3.6&nbsp;-&nbsp;Selecting the Input File Type (XSD, WSDL, DTD)</h2>
<p>
LMX can parse both W3C Schema (XSD) and XML (external) DTD files.  LMX can also locate and parse W3C Schema definitions embedded in WSDL files.  The parsing that LMX performs depends on the file extension of the base schema file.  
<p>
If the file extension is '<code>.wsdl</code>', LMX with attempt to locate a schema within a WSDL file and parse that.  Note that LMX will only extract the first schema within a WSDL file.  If multiple schema are present in a WSDL file then it is necessary to manually extract the second and subsequent schemas into separate schema files prior to parsing.  
<p>
If the file extension is '<code>.dtd</code>', LMX will assume the file is an XML external DTD.  When parsing DTD definitions, the Imported files window has no effect.  Files names referenced as external entities within a DTD are opened relative to file location of the DTD file.
<p>
All other file extensions, including '<code>.xsd</code>' are assumed to be W3C Schema definitions.
<p>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='TheCommandlineandConfigurationFileFormat'></a>
<h2>3.7&nbsp;-&nbsp;The Command-line and Configuration File Format</h2>
<p>
LMX and WinLMX can be configured using command-line flags and configuration files.  The contents of a configuration file is simply a number of command-line flags (See <a href='#CommandlineFlags'>3.8&nbsp;-&nbsp;Command-line Flags</a>).  The layout of the flags in the file (whether on the same line or different lines etc) is not significant, although one command option per line is suggested.  Comments can be included in a configuration file using a '#' character.  Any characters after the '#' character until the end of the line are ignored.  For example:
<pre class='conf'>
    # This is my LMX config file
    # Created: today
    # By: Me
    -cpplines 2000
    MyProject.xsd     # The schema for our project
    MyProjectXML      # The root of the output files
</pre>
<p>
When a set of command-line arguments are first received by either tool, it is subject to some special processing:
<ul>
<li>If a single command-line argument is present, and it ends with '.lmxprj' it is assumed to be the name of a configuration file, and the tool reads and processes the file.  
<p>
<li>In the case of the command-line tool, if a single argument is present, but it does not end in '.lmxprj', the tool tries appending '.lmxprj' to the end of the name and tests whether a file of the resultant name exists.  If it does, the tool treats the resultant file as a configuration file and executes its contents.  This allows configuration files to be associated with particular schema files.  
</ul>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CommandlineFlags'></a>
<h2>3.8&nbsp;-&nbsp;Command-line Flags</h2>
<p>
The LMX code generator understands the following flags:-
<dl>
<a name='flag-hash-define'></a>
<dt>-#define YYY</dt><dd>Outputs the line <code>#define YYY</code> in the generated .h file before the inclusion of <code>lmxuser.h</code>.  This allows configuration of the <code>lmxuser.h</code> file.  If the <code>YYY</code> field includes spaces, place it in <code>"</code> marks for correct command line argument parsing.  For example, <code>-#define "LMX_WANT_DLL 1"</code></dd>
<p>
<a name='flag-alt-xml-reader'></a>
<dt>-alt-xml-reader YYY</dt><dd>Changes the XML reader class that the unmarshal code uses to read XML.  The default XML reader class is <code>lmx::c_xml_reader</code>.  Typically this flag would be used to specify a class that derives from <code>lmx::c_xml_reader</code> and the derived class would contain extra data and methods to be used in conjugation with custom event handlers during the unmarshal process.</dd>
<p>
<a name='flag-alt-xml-writer'></a>
<dt>-alt-xml-writer YYY</dt><dd>Changes the XML writer class that the marshal code uses to write XML.  The default XML writer class is <code>lmx::c_xml_writer</code>.  Typically this flag would be used to specify a class that derives from <code>lmx::c_xml_writer</code> and the derived class would contain extra data and methods to be used in conjugation with custom event handlers during the marshal process.</dd>
<p>
<a name='flag-no-assign'></a>
<dt>-no-assign</dt><dd>Switches off the generation of operator = and copy constructor code.  The code generated uses the construct and swap pattern for exception safety.  This can generate a lot of code and if the assignment operator is not needed in your code you can have a smaller executable by specifying this flag.</dd>
<p>
<a name='flag-autover'></a>
<dt>-autover</dt><dd>This option allows the generated code to support limited automatic versioning of your schema.  If this option is selected, the parser will allow unknown elements to appear before an end tag.  This allows new elements to be added to a schema in subsequent versions, but still allow old installations of the code to operate successfully.  Note that selecting this option results in non-standard schema behavior.</dd>
<p>
<a name='flag-autover-subst-groups'></a>
<dt>-autover-subst-groups</dt><dd>This option allows the generated code to support automatic versioning of substitution groups.  With this option, if an unknown element is encountered in the place of a mandatory substitution group member, then the element is skipped, the element is recorded as unknown, and no error is generated.  Without this option being specified an error is reported under these circumstances.</dd>
<p>
<a name='flag'></a>
<dt>-braces-indent</dt><dd>Causes the braces ({}) to be indented.</dd>
<p>
<a name='flag-build'></a>
<dt>-build YYY</dt><dd>Tells the code generator to generate code for the project described in configuration file YYY and return.  A configuration file may have multiple -build arguments allowing multiple projects to be built from a single configuration file.</dd>
<p>
<a name='flag-cd'></a>
<dt>-cd YYY</dt><dd>Changes the current working directory to YYY.  This allows the configuration file to specify relative file names rather than absolute file names.</dd>
<p>
<a name='flag-no-check-code'></a>
<dt>-no-check-code</dt><dd>Disables generation of the check() methods.  See <a href='#RuntimeChecking'>2.5.15&nbsp;-&nbsp;Run-time Checking</a>.</dd>
<p>
<a name='flag-check-is-occurs-ok-on-marshal'></a>
<dt>-check-is-occurs-ok-on-marshal</dt><dd>Adds code to the marshal methods to check that <code>is_occurs_ok()</code> returns <code>true</code>.  The <code>lmx::ELMX_OCCURRENCE_ERROR</code> error is returned if <code>is_occurs_ok()</code> returns <code>false</code>.  By default this check is not done in order to maximize performance.</dd>
<p>
<a name='flag-class-base'></a>
<dt>-class-base CLASS BASE</dt><dd>Specifies that the generated class named CLASS should be generated such that it derives from BASE.  Note the CLASS field should not include the class name prefix.  Thus by default the option <code>-class-base MyClass MyBase</code> will generate code of the form <code>class c_MyClass : public MyBase</code>.</dd>
<p>
<a name='flag-cns'></a>
<dt>-cns YYY</dt><dd>Sets the C++ namespace to YYY.  In other words, the generated code is wrapped in a <code>namespace YYY { ... }</code> statement.  By default the C++ namespace is derived from the XML namespace prefix assigned to the primary schema's target namespace.  Nested C++ namespaces can also be specified.  To do this use the form <code>-cns YYY::ZZZ</code>.</dd>
<p>
<a name='flag-no-cns'></a>
<dt>-no-cns</dt><dd>Indicates that no C++ namespace statements should be generated, even if a default namespace name can be derived from the XML schema.</dd>
<p>
<a name='flag-no-container-ops'></a>
<dt>-no-container-ops</dt><dd>By default items that can have multiple instances will have container operations generated which allow you to insert, delete or clear members of the container.  Specifying this option disables the generation of these methods.</dd>
<p>
<a name='flag-no-convenience'></a>
<dt>-no-convenience</dt><dd>Switches off the generation of convenience functions that allow direct marshaling and unmarshaling from files and strings.</dd>
<p>
<a name='flag-no-convenience-xs-any'></a>
<dt>-no-convenience-xs-any</dt><dd>Switches off the generation of convenience functions that allow direct unmarshaling from content retrieved <code>xs:any</code> instances.</dd>
<p>
<a name='flag-cpp-compiler'></a>
<dt>-cpp-compiler YYY</dt><dd>Indicates that code should be generated that is specific to the C++ compiler identified by YYY.  The only compiler that requires special support is the IBM Visual Age compiler.  This is identified by setting YYY to 'VisualAge'.</dd>
<p>
<a name='flag-cpp-per-class'></a>
<dt>-cpp-per-class</dt><dd>Tells LMX to store the code for each class in a separate .h/.cpp file pair.  -cpplines has no effect when this option is specified.  The -multi-file flag has the same effect.  If neither -cpp-per-class or -cpp-per-schema is specified, then a single .h and a single .cpp file are generated.</dd>
<p>
<a name='flag-cpp-per-schema'></a>
<dt>-cpp-per-schema</dt><dd>Tells LMX to generate one .cpp file for each schema.  Note that the generated code for included schemas is included in the same .cpp as the schema doing the including.  This mode generates a single .h file.  -cpplines has no effect when this option is specified.  If neither -cpp-per-class or -cpp-per-schema is specified, then a single .h and a single .cpp file are generated.</dd>
<p>
<a name='flag-cpplines'></a>
<dt>-cpplines YYY</dt><dd>Some schemas can generate a large number of lines of code.  This may cause a compiler problems if all the lines are stored in a single file.  This flag allows you to control the number of lines that are stored in each <code>.cpp</code> file.  During code generation, before the methods and data for a class is output, LMX tests whether the number of lines in the <code>.cpp</code> file exceeds the value specified by <code>YYY</code>.  If it does, LMX closes the current file and starts outputting code to a new file.  Files are differentiated by appending a number to the end of the file name root;  e.g. <code>my_xsd_code2.cpp</code>.</dd>
<p>
<a name='flag-doc-in-h'></a>
<dt>-doc-in-h</dt><dd>Causes the <code>xs:documentation</code> information from the schemas to be included in the generated <code>.h</code> files.</dd>
<p>
<a name='flag-doc-in-html'></a>
<dt>-doc-in-html</dt><dd>Causes the <code>xs:documentation</code> information from the schemas to be included in the generated HTML documentation.</dd>
<p>
<a name='flag-no-dynamic-cast'></a>
<dt>-no-dynamic-cast</dt><dd>Forces use of a static_cast rather than a dynamic_cast when a down cast is required.  This is less safe, but may be more efficient and permits use of compilers that don't support C++'s RTTI.</dd>
<p>
<a name='flag-enums-global'></a>
<dt>-enums-global</dt><dd>Makes the C++ enums associated with schema xs:enumerations be all coalesced into a single global C++ enum.  This is the default behavior.</dd>
<p>
<a name='flag-enums-local'></a>
<dt>-enums-local</dt><dd>Generate separate C++ enums for each element or attribute having xs:enumeration facets within the relevant class.  This mode is deprecated and it is recommended to use <a href='#flag-enums-per-type'>-enums-per-type</a> instead.</dd>
<p>
<a name='flag-enums-per-type'></a>
<dt>-enums-per-type</dt><dd>Generate separate C++ enums for each type that has xs:enumeration facets defined in the schema.  C++ enums associated with global schema types will be in C++ global space, and C++ enums associated with local schema elements and attributes will be in the relevant C++ class.</dd>
<p>
<a name='flag-eq'></a>
<dt>-eq</dt><dd>Enables generation of operator ==() and operator !=() methods.</dd>
<p>
<a name='flag-error-fast'></a>
<dt>-error-fast</dt><dd>Normally when an error is detected LMX writes code that calls a common error handler method giving you the opportunity to intercept the error and implement custom error handling.  This also provides a convenient place to put a breakpoint when debugging.  When the <code>-error-fast</code> is specified the error code is returned immediately without calling the handler.  This results in faster, more compact code, but does not have the other benefits.</dd>
<p>
<a name='flag-no-ev'></a>
<dt>-no-ev</dt><dd>If a type such as a string is enumerated, by default LMX will generate code checks that a read XML document matches one of the enumerations.  Setting this flag turns off generation of such code.</dd>
<p>
<a name='flag-no-exceptions'></a>
<dt>-no-exceptions</dt><dd>Indicates that try/catch blocks should not be generated in C++ functions.</dd>
<p>
<a name='flag-exec-pre'></a>
<dt>-exec-pre YYY</dt><dd>Specifies the name of a program or script that should be executed prior to starting to generate code into a file.  The script is given the name of the file that is about to be generated.  For example, if LMX is about to starting generating code into myproject.cpp, then, with this option, LMX will execute the shell command <code>YYY myproject.cpp</code>.</dd>
<p>
<a name='flag-exec-pre-all'></a>
<dt>-exec-pre-all YYY</dt><dd>Specifies the name of a program or script that should be executed prior to starting the code generation process.  The script is given the Output File Base Name for the project.  For example, if LMX is about to starting generating code for a project whose Out File Base name is myproject, then, with this option, LMX will execute the shell command <code>YYY myproject</code>.</dd>
<p>
<a name='flag-exec-post'></a>
<dt>-exec-post YYY</dt><dd> Specifies the name of a program or script that should be executed when LMX has finished generating code into a file.  The script is given the name of the file that has been generated.  For example, if LMX finished generating code into myproject.h, then, with this option, LMX will execute the shell command <code>YYY myproject.h</code>.</dd>
<p>
<a name='flag-exec-post-all'></a>
<dt>-exec-post-all YYY</dt><dd>Specifies the name of a program or script that should be executed when the code generation process is completed.  The script is given the Output File Base Name for the project.  For example, if LMX has completed code generation for a project whose Out File Base name is myproject, then, with this option, LMX will execute the shell command <code>YYY myproject</code>.  Note that the program/script will not be executed if errors have occurred during the code generation process.</dd>
<p>
<a name='flag-exec-post-all-error'></a>
<dt>-exec-post-all-error YYY</dt><dd>Similar to <code>-exec-post-all</code>, except that the program/script is run when an error occurs during code generation.</dd>
<p>
<a name='flag-expose-containers'></a>
<dt>-expose-containers</dt><dd>Causes LMX to generate methods that return references to the containers (e.g. instances of std::vector) used in the objects.  This allows more fine-grained control of the containers.  Specifying <code>-no-container-ops</code> in conjunction with <code>-expose-containers</code> allows smaller code to be generated while still maintaining the ability to manipulate the contents of the containers when required.</dd>
<p>
<a name='flag-expose-storage'></a>
<dt>-expose-storage</dt><dd>Generates methods that expose the underlying objects that store the data.  Direct use of these objects allows more generic handling of similar data in different parent objects.</dd>
<p>
<a name='flag-f'></a>
<dt>-f YYY</dt><dd>Tells the code generator to add the configuration information contained in the file YYY to the current configuration.  The contents of the configuration file is the same as the command-line flags described here.</dd>
<p>
<a name='flag-file-ext-cpp'></a>
<dt>-file-ext-cpp YYY</dt><dd>Set the extension for generated CPP files to YYY.  The default is <code>.cpp</code>.</dd>
<p>
<a name='flag-file-ext-h'></a>
<dt>-file-ext-h YYY</dt><dd>Set the extension for generated header files to YYY.  The default is <code>.h</code>.</dd>
<p>
<a name='flag-fname-sep'></a>
<dt>-fname-sep YYY</dt><dd>Sets the character sequence used to separate parts of file names that are constructed from multiple parts during multiple file generation modes to YYY.  The default is <code>-</code>.</dd>
<p>
<a name='flag-file-ext-snippets'></a>
<dt>-file-ext-snippets YYY</dt><dd>By default a <code>.h</code> is checked to locate user specified snippets and snippet events.  Using this option specifies the file extension of files that are used to store snippets.  This allows snippets to be stored in a file other than the <code>.h</code> file, and means that the source file storing snippets will not be overwritten by LMX.  The separate snippets file should include zero or more sections of snippets consisting of both the snippet markers and the additional user code.</dd>
<p>
<a name='flag-forcegen'></a>
<dt>-forcegen</dt><dd>Normally LMX will not generate code if errors are found when parsing the schema.  Setting this flag forces code generation even if errors are found.  The results of setting this flag when errors are encountered are unpredictable.</dd>
<p>
<a name='flag-no-gen'></a>
<dt>-no-gen</dt><dd>Tells LMX not to generate any code (even if there are no errors).  This can be used when developing a schema and code generation is not required.  LMX can be used in evaluation mode with this flag set without displaying any warning messages about licensing!</dd>
<p>
<a name='flag-no-gen-date'></a>
<dt>-no-gen-date</dt><dd>Normally, when writing a file, LMX will include a comment specifying the date when the file was generated.  This flag prevents this.  This means that each time LMX is run it will generate the same output, minimizing diffs in version control systems.</dd>
<p>
<a name='flag-no-html'></a>
<dt>-no-html</dt><dd>Tells the tool NOT to create HTML documentation for the project.</dd>
<p>
<a name='flag-include-cpp'></a>
<dt>-include-cpp YYY</dt><dd>Specifies that when generating a .cpp file, a line of the form <code>#include "YYY"</code> should be included in the file.  If you would like to use the <code>#include &lt;YYY&gt;</code> form, then include the &lt;> brackets as part of the parameter, e.g. do <code>-include-cpp &lt;YYY&gt;</code>.  Multiple instances of this flag are allowed.</dd>
<p>
<a name='flag-include-h'></a>
<dt>-include-h YYY</dt><dd> Specifies that when generating a .h file, a line of the form <code>#include "YYY"</code> should be included in the file.  If you would like to use the <code>#include &lt;YYY&gt;</code> form, then include the &lt;> brackets as part of the parameter, e.g. do <code>-include-h &lt;YYY&gt;</code>.  Multiple instances of this flag are allowed.</dd>
<p>
<a name='flag-include-guard'></a>
<dt>-include-guard YYY</dt><dd>Sets the .h file include guard text to YYY rather that the default derived from the C++ namespace and name of the file.</dd>
<p>
<a name='flag-lmx-cns'></a>
<dt>-lmx-cns YYY</dt><dd>Tells the code generator to use the C++ namespace YYY:: when referring to the LMX parser and other similar items.  This allows the user to define an alternative parser to that supplied with LMX.</dd>
<p>
<a name='flag-no-lmx-cns'></a>
<dt>-no-lmx-cns</dt><dd>Tells the code generator not to use a C++ namespace when referring to the LMX parser components and other similar items.</dd>
<p>
<a name='flag-lmx-include-path'></a>
<dt>-lmx-include-path YYY</dt><dd>Allows the path to be specified when code is generated to <code>#include</code> the LMX header files.  To avoid making assumptions about directory separator characters, LMX does not append a <code>/</code> or <code>\</code> character if no such character is present.  Thus the flag sequence <code>-lmx-include-path YYY</code> will generate a line similar to <code>#include "YYYlmxuser.h"</code>, and in general it will be necessary to specify the directory separator as part of the parameter; for example <code>-lmx-include-path YYY/</code>.  If the LMX files are to be considered system files (i.e. so that code similar to <code>#include &lt;YYY/lmxuser.h&gt;</code> is generated), then include the <code>&lt;></code> brackets as part of the parameter, e.g. <code>-lmx-include-path &lt;YYY/&gt;</code>.  If you want the LMX headers to be considered as system header files, but don't want them in a sub-directory, do <code>-lmx-include-path &lt;&gt;</code>.  This will generate lines similar to <code>#include &lt;lmxuser.h&gt;</code>.  Note that if the directory name contains spaces, then, as for all such parameters, the parameter will need to be included in double quote marks, for example <code>-lmx-include-path "Y Y Y/"</code>.  This is also the case if a system path contains spaces, requiring a flag sequence of the form <code>-lmx-include-path "&lt;Y Y Y/&gt;"</code>.  In this case the <code>"</code> characters will be stripped by the command-line processor, and won't appear in the generated code.</dd>
<p>
<a name='flag-lmx-types-cns'></a>
<dt>-lmx-types-cns YYY</dt><dd>Tells the code generator to use the C++ namespace YYY:: when referring to the LMX defined data types.  By default <code>lmx::</code> is used.  Changing this allows different C++ classes and types to be used to represent the data objects in the XML schema.</dd>
<p>
<a name='flag-no-lmx-types-cns'></a>
<dt>-no-lmx-types-cns</dt><dd>Tells LMX not to generate a C++ namespace qualifier (such as lmx::) when referring to LMX defined types.  This allows you to define and control the types and classes used by the generated code.</dd>
<p>
<a name='flag-lmxuser-defs'></a>
<dt>-lmxuser-defs</dt><dd>Outputs the line <code>#define LMX_WANT_USER_DEFS</code> in the generated .h file before the inclusion of <code>lmxuser.h</code>.  This causes the file <code>lmxuser-defs.h</code> to be included by <code>lmxuser.h</code>, which allows configuration of <code>lmxuser.h</code>.</dd>
<p>
<a name='flag-lmxuser-defs-end'></a>
<dt>-lmxuser-defs-end</dt><dd>Outputs the line <code>#define LMX_WANT_USER_DEFS_END</code> in the generated .h file before the inclusion of <code>lmxuser.h</code>.  This causes the file <code>lmxuser-defs-end.h</code> to be included by <code>lmxuser.h</code>, which allows configuration of <code>lmxuser.h</code>.</dd>
<p>
<a name='flag-no-local-classes'></a>
<dt>-no-local-classes</dt><dd>By default LMX generates the unmarshal helper class as a local class in the unmarshal method.  If your compiler does not correctly support the access rights of local classes then use this flag to generate the unmarshal helper class outside the unmarshal method.</dd>
<p>
<a name='flag-local-enums'></a>
<dt>-local-enums</dt><dd>Obsolete version of <a href='#flag-enums-local'>-enums-local</a> flag.</dd>
<p>
<a name='flag-no-local-enums'></a>
<dt>-no-local-enums</dt><dd>Obsolete version of <a href='#flag-enums-global'>-enums-global</a> flag.</dd>
<p>
<a name='flag-makefile'></a>
<dt>-makefile</dt><dd>Generates a makefile fragment that contains makefile variables that specify the names of C++ files that have been generated.  See <a href='#Generatingmakefiles'>3.10&nbsp;-&nbsp;Generating makefiles</a> for more information.</dd>
<p>
<a name='flag-makefile-lib'></a>
<dt>-makefile-lib YYY</dt><dd>When creating a makefile, specifies the name of the library containing the LMX Supporting Software Runtime Source Code.  For example, <code>-makefile-lib lmx410</code> will include a <code>-llmx410</code> in the makefile.  See <a href='#Generatingmakefiles'>3.10&nbsp;-&nbsp;Generating makefiles</a> for more information.</dd><p>
<a name='flag-markers'></a>
<dt>-markers</dt><dd>Indicates that comment based markers should be output in the code.  This can facilitate post processing of generated code, for example by using the <code>-exec-post</code> flag.</dd>
<p>
<a name='flag-no-marshal'></a>
<dt>-no-marshal</dt><dd>Disables the generation of the methods associated with marshaling the C++ objects to XML.  See also -no-unmarshal.</dd>
<p>
<a name='flag-max-else-ifs'></a>
<dt>-max-else-ifs YYY</dt><dd>Some sections of code have the form if() ... else if() ... else if() ....  Some compilers have limitations on how much nesting of this form can be used.  This option allows specification of the maximum number of else if() constructs.  For constructs larger than YYY, the form if() ...; if() ...; is used.  This is less efficient in some cases.</dd>
<p>
<a name='flag-max-inline'></a>
<dt>-max-inline YYY</dt><dd>Some short methods can now be generated in-line with the class definition.  This flag allows specification of the maximum number of lines that are allowed to be generated in-line.  The default is 3.</dd>
<p>
<a name='flag-micro-format'></a>
<dt>-micro-format PATH  CLASS</dt><dd>Specifies that the simpleType item identified by PATH should be represented by a micro format using C++ class CLASS.  See <a href='#SpecifyingMicroFormats'>3.26&nbsp;-&nbsp;Specifying Micro Formats</a> for more information.</dd>
<p>
<a name='flag-method-getchosen'></a>
<dt>-method-getchosen YYY</dt><dd>Set the name of the getchosen() method to YYY.</dd>
<p>
<a name='flag-method-getid'></a>
<dt>-method-getid YYY</dt><dd>Set the name of the getid() method to YYY.</dd>
<p>
<a name='flag-method-getorder'></a>
<dt>-method-getorder YYY</dt><dd>Set the name of the indexed getorder( index ) method to YYY.</dd>
<p>
<a name='flag-method-has_id'></a>
<dt>-method-has_id YYY</dt><dd>Set the name of the has_id() method to YYY.</dd>
<p>
<a name='flag-method-is_occurs_ok'></a>
<dt>-method-is_occurs_ok YYY</dt><dd>Set the name of the is_occurs_ok() method to YYY.</dd>
<p>
<a name='flag-method-marshal'></a>
<dt>-method-marshal YYY</dt><dd>Set the name of the marshal(...) method to YYY.</dd>
<p>
<a name='flag-method-reset'></a>
<dt>-method-reset YYY</dt><dd>Set the name of the reset() method to YYY.</dd>
<p>
<a name='flag-method-sizeorder'></a>
<dt>-method-sizeorder YYY</dt><dd>Set the name of the sizeorder() method to YYY.</dd>
<p>
<a name='flag-method-unmarshal'></a>
<dt>-method-unmarshal YYY</dt><dd>Set the name of the unmarshal(...) method to YYY.</dd>
<p>
<a name='flag-multi-file'></a>
<dt>-multi-file</dt><dd>Same as the -cpp-per-class flag.</dd>
<p>
<a name='flag-names-dir'></a>
<dt>-names-dir  YYY</dt><dd>Optionally specifies the directory that the names files are to be read from or saved to.  This flag does not enable names file usage by itself.  Such behavior is enabled by using the -names-in and -names-out flags.  See <a href='#NamingofMethodsandVariables'>3.12&nbsp;-&nbsp;Naming of Methods and Variables</a> for more information.</dd>
<p>
<a name='flag-names-in'></a>
<dt>-names-in</dt><dd>Use a names file to set the names of C++ variables in the generated code.  The name of the names file is derived from the schema file name by appending '.lmxnames-<em>in</em>.xml' to the file name.  If the schema is named mySchema.xsd, the names file looked for will be mySchema.xsd.lmxnames-<em>in</em>.xml.  See the section <a href='#NamingofMethodsandVariables'>3.12&nbsp;-&nbsp;Naming of Methods and Variables</a> for more information.</dd>
<p>
<a name='flag-names-out'></a>
<dt>-names-out</dt><dd>Output the C++ names used in the generation to a names file.  The name of the names file is derived from the schema file name by appending '.lmxnames-<em>out</em>.xml' to the file name.  If the schema is named mySchema.xsd, the names file looked for will be mySchema.xsd.lmxnames-<em>out</em>.xml.  See the section <a href='#NamingofMethodsandVariables'>3.12&nbsp;-&nbsp;Naming of Methods and Variables</a> for more information.</dd>
<p>
<a name='flag-naming'></a>
<dt>-naming YYY</dt><dd>Specifies the naming convention to be used for names in the generated code.  If <code>YYY</code> corresponds to <code>camel</code> LMX will attempt to convert base names generated in the code to CamelCase.  If <code>YYY</code> corresponds to <code>underscore</code> LMX will attempt to make base names underscore separated.  If <code>YYY</code> corresponds to <code>camel-no-xform</code> a set of name prefixes will be selected that are compatible with the CamelCase naming convention, but base names derived from the schemas will not be transformed to CamelCase.  The absence of this option is equivalent to <code>YYY</code> being set to <code>underscore-no-xform</code>.
<p>
<a name='flag-narrow-strings'></a>
<dt>-narrow-strings</dt><dd>Generates suitable <code>#define</code>s to instruct C++ compiler to use narrow strings for storing Unicode strings.</dd>
<p>
<a name='flag-no-nested-classes'></a>
<dt>-no-nested-classes</dt><dd>By default, C++ classes generated for types defined locally in a schema are nested in their parent class to echo the structure of the original schema.  For deeply nested schema (such as Russian Doll design) this approach may not be desirable.  This flag therefore allows you to specify that C++ classes should not be nested.</dd>
<p>
<a name='flag-ns-map-base'></a>
<dt>-ns-map-base YYY</dt><dd>Specifies an alternate prefix name for the <code>s_ns_map</code> instances containing namespace mapping information.  This can be used to prevent name clashes when multiple instances of LMX generated code are in the same project.  While this option is one solution to this problem, the preferred solution is to generate the code into separate C++ namespaces using the <code>-cns</code> flag.</dd>
<p>
<a name='flag-ns-prefix-map'></a>
<dt>-ns-prefix-map &nbsp;&nbsp; FROM &nbsp;&nbsp; TO</dt><dd>Specifies that if a schema defines a namespace prefix of <code>FROM</code>, the marshaling code should use a namespace prefix of <code>TO</code>.  For example, if the schema uses the namespace prefix <code>tns</code>, LMX can be instructed to use the default namespace for the marshalled XML using the flag sequence:<br>
&nbsp;&nbsp;&nbsp;<code>-ns-prefix-map&nbsp;&nbsp;tns&nbsp;&nbsp;""</code><br>It is the responsibility of the user to ensure that mapped namespace prefixes do not overlap.  Also, FROM may specify the relevant namespace URI, such as <code>http://www.example.com/myschema.xsd</code>.  For example, the flag sequence:<br>
&nbsp;&nbsp;&nbsp;<code>-ns-prefix-map&nbsp;&nbsp;http://www.example.com/myschema.xsd&nbsp;&nbsp;myns</code> <br> would cause elements and attributes in the <code>http://www.example.com/myschema.xsd</code> namespace to use the namespace prefix <code>myns</code>.</dd>
<p>
<a name='flag-old-enums'></a>
<dt>-old-enums</dt><dd>Specifies that the old way of generating enum names should be used.</dd>
<p>
<a name='flag-output-defaults'></a>
<dt>-output-defaults</dt><dd>Selecting this option results in the default values of attributes and elements being marshalled into the output if the value is not set by the user access functions.  This can be useful when debugging.  This is non-standard schema behavior.</dd>
<p>
<a name='flag-pattern-out'></a>
<dt>-pattern-out PATTERN FUNCTION</dt><dd>Allows the specification of a custom output converter so that output can be formatted to conform to a specified xs:pattern definition.  See <a href='#CustomPatternFacetOutputFormatting'>3.24&nbsp;-&nbsp;Custom Pattern Facet Output Formatting</a> for more information.</dd>
<p>
<a name='flag-no-polymorphic'></a>
<dt>-no-polymorphic</dt><dd>Disable generation of polymorphic code for schema extensions and restrictions.</dd>
<p>
<a name='flag-prefix-anonymous'></a>
<dt>-prefix-anonymous YYY</dt><dd>Specifies that all anonymous class names are prefixed by YYY.</dd>
<p>
<a name='flag-prefix-append'></a>
<dt>-prefix-append YYY</dt><dd>Set the prefix of the methods named append_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-appendenum'></a>
<dt>-prefix-appendenum YYY</dt><dd>Set the prefix of the methods named appendenum_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-assign'></a>
<dt>-prefix-assign YYY</dt><dd>Set the prefix of the methods named assign_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-back'></a>
<dt>-prefix-back YYY</dt><dd>Set the prefix of the methods named back_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-class'></a>
<dt>-prefix-class YYY</dt><dd>Set the prefix of class names to YYY.</dd>
<p>
<a name='flag-prefix-clear'></a>
<dt>-prefix-clear YYY</dt><dd>Set the prefix of the methods named clear_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-container'></a>
<dt>-prefix-container YYY</dt><dd>Set the prefix of the methods named container_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-declash'></a>
<dt>-prefix-declash YYY</dt><dd>Specifies a prefix to use to avoid name clashes when including multiple sets of generated code into a C++ project.  We do not recommend using this flag.  See <a href='#HandlingMultipleIndependentSchemas'>3.22.1&nbsp;-&nbsp;Handling Multiple Independent Schemas</a> for more information.</dd>
<p>
<a name='flag-prefix-default'></a>
<dt>-prefix-default YYY</dt><dd>Set the prefix of the default variables to YYY.</dd>
<p>
<a name='flag-prefix-delete'></a>
<dt>-prefix-delete YYY</dt><dd>Set the prefix of the methods named delete_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-enum'></a>
<dt>-prefix-enum YYY</dt><dd>Set the prefix of enum names to YYY.</dd>
<p>
<a name='flag-prefix-enumeration'></a>
<dt>-prefix-enumeration YYY</dt><dd>Sets the prefix used for the C++ enumerated values associated with <code>xs:enumeration</code> facets to YYY.  By default it is the same as that specified by the <code>-prefix-enum</code> flag.  Note that for backwards compatibility reasons this flag has no effect when a single global C++ enum is used to represent <code>xs:enumeration</code> values.</dd>
<p>
<a name='flag-prefix-enumeration-name'></a>
<dt>-prefix-enumeration-name YYY</dt><dd>Sets the prefix used for the C++ enum types associated with <code>xs:enumeration</code> facets to YYY.  By default it is the same as that specified by the <code>-prefix-enum</code> flag.  Note that for backwards compatibility reasons this flag has no effect when a single global C++ enum is used to represent <code>xs:enumeration</code> values.</dd>
<p>
<a name='flag-prefix-fraction-digits'></a>
<dt>-prefix-fraction-digits YYY</dt><dd>Set the prefix of the fraction_digits_{name} variables to YYY.</dd>
<p>
<a name='flag-prefix-get'></a>
<dt>-prefix-get YYY</dt><dd>Set the prefix of the methods named get_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-getenum'></a>
<dt>-prefix-getenum YYY</dt><dd>Set the prefix of the methods named getenum_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-getorder'></a>
<dt>-prefix-getorder YYY</dt><dd>Set the prefix of the methods named getorder_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-in'></a>
<dt>-prefix-in YYY</dt><dd>Specifies that the methods to retrieve range information for use in C++11 range-based for loops be prefixed by YYY.</dd>
<p>
<a name='flag-prefix-inner'></a>
<dt>-prefix-inner YYY</dt><dd>Specifies that all inner class names are prefixed by YYY.</dd>
<p>
<a name='flag-prefix-insert'></a>
<dt>-prefix-insert YYY</dt><dd>Set the prefix of the methods named insert_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-insertenum'></a>
<dt>-prefix-insertenum YYY</dt><dd>Set the prefix of the methods named insertenum_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-isnil'></a>
<dt>-prefix-isnil YYY</dt><dd>Set the prefix of the methods named isnil_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-isset'></a>
<dt>-prefix-isset YYY</dt><dd>Set the prefix of the methods named isset_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-nil'></a>
<dt>-prefix-nil YYY</dt><dd>Set the prefix of the nil_{name} variables to YYY.</dd>
<p>
<a name='flag-prefix-present'></a>
<dt>-prefix-present YYY</dt><dd>Set the prefix of the present_{name} variables to YYY.</dd>
<p>
<a name='flag-prefix-set'></a>
<dt>-prefix-set YYY</dt><dd>Set the prefix of the methods named set_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-setenum'></a>
<dt>-prefix-setenum YYY</dt><dd>Set the prefix of the methods named setenum_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-setnil'></a>
<dt>-prefix-setnil YYY</dt><dd>Set the prefix of the methods named setnil_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-size'></a>
<dt>-prefix-size YYY</dt><dd>Set the prefix of the methods named size_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-prefix-storage'></a>
<dt>-prefix-storage YYY</dt><dd>Set the prefix of the main stotage variable (m_{name}) to YYY.</dd>
<p>
<a name='flag-prefix-unset'></a>
<dt>-prefix-unset YYY</dt><dd>Set the prefix of the methods named unset_{name}(...) to YYY{name}(...).</dd>
<p>
<a name='flag-release-switch'></a>
<dt>-release-switch</dt><dd>Uses a switch statement when releasing members of a choice.  This results in more code, but is more portable.</dd>
<p>
<a name='flagroot'></a>
<dt>-root YYY</dt><dd>Specifies that if the root class is generated, which by default is derived from the main schema's namespace prefix, or called <code>c_root</code>, then it should be called <code>c_YYY</code>.  Note that the <code>-prefix-class</code> flag can be used to change the prefix of the class name.</dd>
<p>
<a name='flag-root-from-xsd-tns-prefix'></a>
<dt>-root-from-xsd-tns-prefix</dt><dd>Specifies that if the root class is generated, which by default is derived from the main schema's namespace prefix, or called <code>c_root</code>, then it's name should be derived from the namespace prefix associated with the schema's target namespace.  Note that the <code>-prefix-class</code> flag can be used to change the prefix of the class name.</dd>
<p>
<a name='flag-root-from-xsd-file'></a>
<dt>-root-from-xsd-file</dt><dd> Specifies that if the root class is generated, which by default is derived from the main schema's namespace prefix, or called <code>c_root</code>, then it's name should be derived from the filename of the main schema.  For example, if the main schema file is called <code>mySchema.xsd</code>, then the root class will be called <code>c_mySchema</code>.  Note that the <code>-prefix-class</code> flag can be used to change the prefix of the class name.</dd>
<p>
<a name='flag-no-root-class'></a>
<dt>-no-root-class</dt><dd>Prevents generation of a root class in the case where there is more than one global element.</dd>
<p>
<a name='flag-snippets'></a>
<dt>-snippets</dt><dd>Causes LMX to output markers between which you can add snippets of your own code.  See <a href='#AugmentingGeneratedClassesWithYourOwnCode'>3.14&nbsp;-&nbsp;Augmenting Generated Classes With Your Own Code</a> for more information.</dd>
<p>
<a name='flag-stdafx'></a>
<dt>-stdafx</dt><dd>Causes the line <code>#include "stdafx.h"</code> to be written into the generated code.</dd>
<p>
<a name='flag-soap'></a>
<dt>-soap</dt><dd>Generates additional code for when the generated results are used for SOAP transactions using LMX's <code>c_soap</code> SOAP wrapper template class.  See <a href='#UsewithWebServices'>3.11&nbsp;-&nbsp;Use with Web Services</a> for more information.</dd>
<p>
<a name='flag-suffix-attribute'></a>
<dt>-suffix-attribute YYY</dt><dd>Specifies that all attribute names are suffixed by YYY.</dd>
<p>
<a name='flag-suffix-element'></a>
<dt>-suffix-element YYY</dt><dd>Specifies that all element names are suffixed by YYY.</dd>
<p>
<a name='flag-suffix-type'></a>
<dt>-suffix-type YYY</dt><dd>Specifies that all type names are suffixed by YYY.</dd>
<p>
<a name='flag-suffix-group'></a>
<dt>-suffix-group YYY</dt><dd>Specifies that all group names are suffixed by YYY.</dd>
<p>
<a name='flag-suffix-inner'></a>
<dt>-suffix-inner YYY</dt><dd>Specifies that all inner class names are suffixed by YYY.</dd>
<p>
<a name='flag-suffix-anonymous'></a>
<dt>-suffix-anonymous YYY</dt><dd>Specifies that all anonymous class names are suffixed by YYY.</dd>
<p>
<a name='flag-no-summary'></a>
<dt>-no-summary</dt><dd>The error output of LMX uses the format used by Microsoft<sup>&reg;*</sup> Visual Studio to allow easy integration.  To allow standalone operation, LMX will produce a summary of the errors and warnings encountered (e.g. 0 error(s), 0 warning(s)).  However, when used within an IDE, some IDEs produce this summary themselves.  Setting this flag tells LMX not to produce an error summary so that only one error summary is produced.  (<sup>*</sup>Microsoft is a Registered Trademark of Microsoft Corporation.)</dd>
<p>
<a name='flag-tframework'></a>
<dt>-tframework</dt><dd>Tells LMX to create a separate .cpp file containing test code.  See <a href='#TestFrameworkGeneration'>3.31&nbsp;-&nbsp;Test Framework Generation</a> for more information.</dd>
<p>
<a name='flag-no-unmarshal'></a>
<dt>-no-unmarshal</dt><dd>Disables the generation of the methods associated with unmarshaling XML to C++ objects.  See also -no-marshal.</dd>
<p>
<a name='flag-user-base'></a>
<dt>-user-base</dt><dd>Selecting this option results in all generated classes ultimately deriving from a user implemented base class called <code>lmx::c_user_base</code>, defined in the <code>USER: USER_BASE</code> section of <code>lmxuser.h</code>.  This allows you to store common information in the generated class objects.</dd>
<p>
<a name='flag-no-warn-ur-type'></a>
<dt>-no-warn-ur-type</dt><dd>Some texts recommend not using types specified as anyType or the ur-type.  After all, this gives no useful information to the validator.  Consequently, by default, LMX gives a warning when a type is not specified for an item (thus defaulting to the ur-type).  This flag switches off the warning generated in this situation.</dd>
<p>
<a name='flag-werror'></a>
<dt>-werror</dt><dd>Causes warnings detected by LMX to be treated as errors when the final program return code is evaluated.</dd>
</dl>

Flags to support additional testing:
<dl>
<a name='flag-eframework'></a>
<dt>-eframework</dt><dd>Similar to <code>-tframework</code>, but generates more testing code.</dd>
<p>
<a name='flag-test-mem'></a>
<dt>-test-mem</dt><dd>When <code>-eframework</code> is used, this option generates code to ensure that memory is not lost when out of memory errors occur.</dd>
<p>
<a name='flag-no-tmain'></a>
<dt>-no-tmain
</dt><dd>When <code>-eframework</code> is used, this option changes the name of the <code>main()</code> function.  This permits the inclusion of the test code into a larger piece of code.</dd>
<p>
</dl>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ErrorCodes'></a>
<h2>3.9&nbsp;-&nbsp;Error Codes</h2>
<p>
The marshal and unmarshal functions return an error value of type <code>enum elmx_error</code>.  The error codes (whose integer values are given in the brackets) have the following meanings:-
<dl>
<dt>ELMX_OK (0)</dt><dd>No errors - everything is OK.</dd>
<p>
<dt>ELMX_ALL_CARDINALITY_VIOLATION (2)</dt><dd>The cardinality constraints of an xs:all construct have been violated.  One possibility is that multiple instances of an element are present.</dd>
<p>
<dt>ELMX_ATTRIBUTE_ALREADY_READ (3)</dt><dd>Two (or more) attributes with the same name appear in the same start tag.</dd>
<p>
<dt>ELMX_ATTRIBUTES_IN_ANONYMOUS_COMPOSITOR (4)</dt><dd>The read XML contained attributes in the start tag of an anonymous compositor.  This should not occur.</dd>
<p>
<dt>ELMX_BADLY_FORMED (5)</dt><dd>The XML is badly formed.</dd>
<p>
<dt>ELMX_BAD_CHAR_ENCODING (6)</dt><dd>Either the character encoding specified in the XML document, or the character encoding deduced from the opening sequence of bytes in the document are not supported by the parser.</dd>
<p>
<dt>ELMX_BAD_CHOICE (7)</dt><dd>A bad choice has been selected when you wrote data to the generated objects.  Most likely a choice was not selected when it should have been.</dd>
<p>
<dt>ELMX_BAD_COMMENT (8)</dt><dd>The format of an XML comment (e.g. &lt;!--...--&gt;) is invalid.</dd>
<p>
<dt>ELMX_BAD_DTD (9)</dt><dd>The DTD in an XML document could not be read correctly.</dd>
<p>
<dt>ELMX_BAD_ELEMENT_END (10)</dt><dd>An end tag was either expected and was not found, or the name in the end tag did not match the name of the element in the start tag.</dd>
<p>
<dt>ELMX_BAD_END_OF_START_TAG (11)</dt><dd>Failed to find a correct end of start tag when looked for.</dd>
<p>
<dt>ELMX_BAD_END_TAG (12)</dt><dd>The format of an end tag is not syntactically correct from an XML viewpoint.</dd>
<p>
<dt>ELMX_BAD_XML_DECL (13)</dt><dd>There is a problem with the XML decl spec.  For example, it may be syntactically incorrect, in the wrong place or multiple decl specs may appear.</dd>
<p>
<dt>ELMX_BAD_XML_VERSION (14)</dt><dd>The XML version is not known.</dd>
<p>
<dt>ELMX_CHAR_ENCODING_MISMATCH (15)</dt><dd>The sequence of bytes read from a data source are not legal for the character encoding specified in the XML document.</dd>
<p>
<dt>ELMX_ELEMENT_NOT_FOUND (16)</dt><dd>A sought element (typically the document element) was not found.</dd>
<p>
<dt>ELMX_ENTITY_NOT_FOUND (41)</dt><dd>The XML contained an entity that does not have a definition.</dd>
<p>
<dt>ELMX_EXTERNAL_ENTITY (17)</dt><dd>A reference to an external entity has been found.  The parser does not resolve references to external entities.</dd>
<p>
<dt>ELMX_FRACTION_DIGITS_EXCEEDED (18)</dt><dd>The maximum number of fraction digits specified for a value by a schema have been exceeded.</dd>
<p>
<dt>ELMX_LENGTH_TOO_LONG (19)</dt><dd>The length of a string or binary value is too long compared to the constraint set in the schema.</dd>
<p>
<dt>ELMX_LENGTH_TOO_SHORT (20)</dt><dd>The length of a string or binary value is too short compared to the constraint set in the schema.</dd>
<p>
<dt>ELMX_MANDATORY_ELEMENT_MISSING (21)</dt><dd>A mandatory element (minOccurs != 0) was not found.</dd>
<p>
<dt>ELMX_NILLED_ELEMENT_NOT_EMPTY (40)</dt><dd>The body of a nilled element was not empty.</dd>
<p>
<dt>ELMX_NO_FILE (1)</dt><dd>Unable to open file.</dd>
<p>
<dt>ELMX_NO_PATTERN_MATCHED (22)</dt><dd>The data value does not match any of the pattern facets specified for the item.</dd>
<p>
<dt>ELMX_NOT_WELL_FORMED (23)</dt><dd>The document is not well formed in the XML sense.</dd>
<p>
<dt>ELMX_OCCURRENCE_ERROR (46)</dt><dd>When marshalling, the number of occurrences of a element was not in the valid range.</dd>
<p>
<dt>ELMX_RECURSIVE_ENTITY_DEFINITION (24)</dt><dd>An entity definition is recursive, and hence cannot be successfully expanded.</dd>
<p>
<dt>ELMX_REQUIRED_ATTRIBUTES_MISSING (25)</dt><dd>One or more required attributes are missing.</dd>
<p>
<dt>ELMX_TOO_MANY_ITEMS (26)</dt><dd>The number of instances of an element exceeds the constraint set by the schema's relevant maxOccurs attribute.</dd>
<p>
<dt>ELMX_TOTAL_DIGITS_EXCEEDED (27)</dt><dd>The maximum number of total digits specified for a value by the schema have been exceeded.</dd>
<p>
<dt>ELMX_TYPE_NOT_SET (45)</dt><dd>An element that required its type to be specified using xsi:type did not have an xsi:type attribute.</dd>
<p>
<dt>ELMX_UNABLE_TO_READ_ATTRIBUTE_VALUE (28)</dt><dd>Unable to read an attribute's value.</dd>
<p>
<dt>ELMX_UNABLE_TO_READ_ELEMENT_VALUE (29)</dt><dd>Unable to read an element's value.</dd>
<p>
<dt>ELMX_UNDEFINED_ERROR (42)</dt><dd>Used as an initialization value that can be later overwritten with a valid error code.</dd>
<p>
<dt>ELMX_UNEXPECTED_ALL_EVENT (30)</dt><dd>Typically, an unknown element occurred in an xs:all construct.</dd>
<p>
<dt>ELMX_UNEXPECTED_ATTRIBUTE (39)</dt><dd>An unknown attribute has been encountered.</dd>
<p>
<dt>ELMX_UNEXPECTED_ELEMENT_EVENT (31)</dt><dd>Typically, an unknown element occurred in an xs:sequence or xs:choice construct.</dd>
<p>
<dt>ELMX_UNEXPECTED_EMPTY_ELEMENT (32)</dt><dd>An element was empty when it should not have been.</dd>
<p>
<dt>ELMX_UNEXPECTED_ENTITY (33)</dt><dd>An external entity was not declared as either PUBLIC or SYSTEM.</dd>
<p>
<dt>ELMX_UNEXPECTED_EOM (34)</dt><dd>The end of the message (or file) was encountered before the XML content was successfully parsed.</dd>
<p>
<dt>ELMX_UNKNOWN_XSI_TYPE (44)</dt><dd>The type declared for an element using xsi:type is unknown.</dd>
<p>
<dt>ELMX_USER_DEFINED_1 (1000) to ELMX_USER_DEFINED_9 (1008)</dt><dd>Error codes reserved for use by the user.  These can be used when errors are returned from snippet event handlers.</dd>
<p>
<dt>ELMX_VALUE_BAD_FORMAT (35)</dt><dd>A value such as an integer, binary value, float and so on was not of a suitable format.</dd>
<p>
<dt>ELMX_VALUE_DOES_NOT_MATCH_FIXED_CONSTRAINT (43)</dt><dd>The value of an element or attribute that is declared as fixed differs from the fixed value.</dd>
<p>
<dt>ELMX_VALUE_EXCEEDS_MAX (36)</dt><dd>The value in the XML document is greater than the maximum specified by the schema.</dd>
<p>
<dt>ELMX_VALUE_EXCEEDS_MIN (37)</dt><dd>The value in the XML document is less than the minimum specified by the schema.</dd>
<p>
<dt>ELMX_VALUE_NOT_ENUMERATED (38)</dt><dd>The read value could not be matched against any of the allowed enumeration values.</dd>
<p>
</dl>

<a name='makefile'></a>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Generatingmakefiles'></a>
<h2>3.10&nbsp;-&nbsp;Generating makefiles</h2>
<p>
LMX has the ability to generate a makefile fragment suitable for inclusion into your own makefiles.  This is invoked using the <code>-makefile</code> command-line flag.  The generated makefile fragment will be named <code>&lt;output root>.makefile</code>.
<p>
Additionally, if there is no file named <code>makefile</code> in the project output directory, then LMX will generate an example makefile that demonstrates a possible use of the generated makefile fragment.  You can then modify this file according to your requirements as LMX will not overwrite it if it is already present.
<p>
An example of the generated makefile fragment is shown below.  It contains a number of makefile variables specifying the files used in the project.  Note that it does not include any actual build instructions.
<pre>
    MYPROJECTCPPS = \
        myproject.cpp
    MYPROJECTTESTCPP = myproject-main.cpp
    MYPROJECTOBJS = $(MYPROJECTCPPS:.cpp=.o)
    MYPROJECTTESTOBJ = $(MYPROJECTTESTCPP:.cpp=.o)
    MYPROJECTHS = $(MYPROJECTCPPS:.cpp=.h)
</pre>
The expectation is that this makefile fragment will be included in another makefile written by the developer that contains the actual build instructions, for example:
<pre>
   include myproject.makefile
   
   LMXLIB = -llmx # Modify using LMX -makefile-lib flag
   
   .PHONY: all test clean
   
   all: libmyproject.a
   
   test: myproject-test
   
   libmyproject.a: $(MYPROJECTOBJS)
   	-rm libmyproject.a
   	ar rcs libmyproject.a $(MYPROJECTOBJS)
   
   myproject-test: $(MYPROJECTTESTOBJ) libmyproject.a
   	$(CXX) -o myproject-test $(MYPROJECTTESTOBJ) libmyproject.a $(LMXLIB)
   
   %.o: %.cpp $(MYPROJECTHS)
   	$(CXX) -c $(CXXFLAGS) $(LMXCXXFLAGS) $(LMXFLAGS) $< -o $@
   
   clean:
   	rm $(MYPROJECTOBJS)
</pre>

You can use the <code>-makefile-lib</code> flag to specify the name of the library containing the LMX Supporting Software Runtime Source Code.  For example, <code>-makefile-lib lmx710</code> will include a <code>-llmx710</code> in the makefile.
<p>
Note that in order to build the test project, you will need to specify the <code>-tframework</code> command-line option, or select the corresponding checkbox in the GUI interfaces when running LMX so that the necessary test <code>.cpp</code> is generated.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='UsewithWebServices'></a>
<h2>3.11&nbsp;-&nbsp;Use with Web Services</h2>
<p>
LMX supports a number of features that help developing web services.  Specifically, LMX has a <code>c_soap</code> template class that can be used to assemble the various components of a SOAP based web service, such as the specific SOAP header, body and fault detail types.
<p>
LMX also has a <code>c_winhttp</code> class which provides HTTP client functionality for SOAP and REST style client operations on the Windows platform.  (A similar HTTP component for Linux platforms is due to be included in a future release.)
<p>
Additionally LMX provides features for querying web service messages, such as that described in <a href='#mustUnderstandComprehensionRequired'>3.28&nbsp;-&nbsp;mustUnderstand / Comprehension Required</a>.


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='HandlingSOAPMessages'></a>
<h3>3.11.1&nbsp;-&nbsp;Handling SOAP Messages</h3>
<p>
To associate the various SOAP header, body and fault detail types that a SOAP messages can have, LMX provides the <code>c_soap</code> template class.  This is defined in <code>lmxsoap.h</code>.  The code for this is built into the binary versions of the LMX Supporting Software or available in source code form in the Professional edition.  The example at <a href='http://codalogic.com/lmx/download/?lmx-soap-example.zip'>http://codalogic.com/lmx/download/?lmx-soap-example.zip</a> shows a number of ways of using the SOAP functionality.
<p>
The <code>c_soap</code> template takes up to three parameters, these being the class representing the SOAP bodies, the class representing the SOAP headers and the class representing the fault detail.  It is thus defined as:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> Tbody, <span class='ckw'>class</span> Theader = c_soap_empty, <span class='ckw'>class</span> Tfault_detail = c_soap_empty >
    <span class='ckw'>class</span> c_soap
    {...}
</pre>
For cases where a fault detail is required, but a header is not, a derivative of <code>c_soap</code>, called <code>c_soap_no_header</code>, is defined as follows:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> Tbody, <span class='ckw'>class</span> Tfault_detail = c_soap_empty >
    <span class='ckw'>class</span> c_soap_no_header
    {...}
</pre>
Unless stated otherwise, anything that applies to <code>c_soap</code> also applies to <code>c_soap_no_header</code>.
<p>
These classes store <code>std::vector</code>s of pointers to the respective body and header types, and a separate fault class.  The fault class stores a pointer to a fault detail object if required.  The <code>bodies()</code> and <code>headers()</code> methods return a reference the relevant <code>std::vector</code> of pointers and by using <code>std::vector</code> operations such as <code>push_back()</code> and <code>at()</code> the overall SOAP message can be constructed or interrogated as required.
<p>
<code>c_soap</code> also contains a class for storing SOAP fault information, called <code>c_soap_fault</code>.  This latter class contains a <code>std::vector</code> of pointers to objects of the <code>Tfault_detail</code> template argument type.  <code>c_soap_fault</code> also contains the SOAP fault code, fault string and fault actor details if required, for which there are appropriate getter and setter methods, e.g. <code>get_fault_code()</code>, <code>set_fault_code()</code>, <code>get_fault_string()</code>, <code>set_fault_string()</code>, <code>get_fault_actor()</code>, and <code>set_fault_actor()</code>.  As the fault actor is optional, it's presence can be tested for using the <code>isset_fault_actor()</code> method.
<p>
By default, the <code>c_soap</code> object deletes the objects that its <code>std::vector</code> containers point to when it is destructed.  If this behavior is not required, then the <code>do_delete_on_destruct( false );</code> method should be called before the object is destructed.  If it is desired to have the <code>c_soap</code> object delete some objects that are pointed to but not all, then the <code>std::vector</code> operations can be used to remove pointers to those objects that it is desired to preserve prior to destructing the <code>c_soap</code> object.
<p>
If it is desired to marshal the SOAP message specified by a constructed <code>c_soap</code> instance, then one of <code>c_soap</code>'s <code>marshal()</code> methods can be called.  There are a number of such methods which allow marshaling to files, or memory for example.
<p>
Similarly, if a SOAP XML message is to be unmarshalled into the corresponding C++ objects, then one of <code>c_soap</code>'s <code>unmarshal()</code> methods can be called.
<p>
Finally, <code>c_soap</code> can also store a <code>SOAPAction</code>, accessible via the <code>get_soap_action()</code> and <code>set_soap_action()</code> methods (located in <code>c_soap_base</code>).  While SOAPAction is not part of a SOAP message's XML contents, it can be convenient to group it together with the other SOAP information.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='HTTPOperationsforWebServices'></a>
<h3>3.11.2&nbsp;-&nbsp;HTTP Operations for Web Services</h3>
<p>
LMX includes the <code>c_winhttp</code> class (declared in <code>lmxwinhttp.h</code>) to provide HTTP client functionality for the Windows platform.  A derivation of <code>c_winhttp</code> called <code>c_secure_winhttp</code> provides secure HTTPS client functionality. Unless stated otherwise, anything that applies to <code>c_winhttp</code> also applies to <code>c_secure_winhttp</code>.
<p>
To allow customization of this functionality to your particular needs, these are provided in source code form in both the Standard and Professional Editions of LMX.  Similar HTTP/HTTPS client functionality for the Linux platform is planned for a future release.  
<p>
LMX does not provide HTTP server side functionality as the expectation is that a regular HTTP server such as Apache or Microsoft IIS will provide this.  LMX generated code can then be plugged into one of those architectures in an appropriate way.  (However, please let us know if you have different requirements.)
<p>
LMX HTTP (and HTTPS) operations consist of two main parts; creating a connection to a server and then performing operations using the connection.  The example mentioned above that is located at <a href='http://codalogic.com/lmx/download/?lmx-soap-example.zip'>http://codalogic.com/lmx/download/?lmx-soap-example.zip</a> also includes examples of using the <code>c_winhttp</code> class's functionality.
<p>
The server to connect to is specified using <code>c_winhttp</code>'s constructor, which is:
<pre class='code'>
    c_winhttp( <span class='ckw'>const</span> std::string &ar_host,
               size_t a_port = k_default_port,
               <span class='ckw'>bool</span> a_is_secure = false );
</pre>
Or that of <code>c_secure_winhttp</code> who's constructor is:
<pre class='code'>
    c_secure_winhttp( <span class='ckw'>const</span> std::string &ar_host,
                      size_t a_port = k_default_https_port );
</pre>
The <code>ar_host</code> argument contains the name of the host being contacted.  For example, if the desired operation URI is <code>http://example.com:8080/my/soap/service</code> then <code>ar_host</code> should be set to <code>example.com</code>.
<p>
<p>
<code>c_winhttp</code> allows a number of different types of web service operation to be performed once a connection has been established.  The following sections describe each of these operations.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SOAPMessagetoMessageOperations'></a>
<h4>3.11.2.1&nbsp;-&nbsp;SOAP Message to Message Operations</h4>
<p>
Message to message SOAP operations are performed using the following method:
<pre class='code'>
    <span class='ckw'>int</span> soap_rpc( <span class='ckw'>const</span> std::string &ar_path,
                  <span class='ckw'>const</span> tlmx_uri_string &ar_soap_action,
                  <span class='ckw'>const</span> std::string &ar_request_xml,
                  std::string *ap_response_xml );
</pre>
This operation sends the XML encoded SOAP message contained in
<code>ar_request_message</code> to the server, and places the reply into the <code>std::string</code> pointed to by <code>ap_response_xml</code>.
<p>
The <code>ar_path</code> argument contains the path part of the HTTP URI.  For example, if the desired operation URI is <code>http://example.com:8080/my/soap/service</code> then <code>ar_path</code> should be set to <code>/my/soap/service</code>.
<p>
The <code>ar_soap_action</code> argument contains the <code>SOAPAction</code>.
<p>
The method returns <code>0</code> if the operation is successful and non-<code>0</code> otherwise.  The <code>get_error_description( int a_error )</code> method can be used to convert an error code into a text based error description.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SOAPObjecttoObjectOperations'></a>
<h4>3.11.2.2&nbsp;-&nbsp;SOAP Object to Object Operations</h4>
What LMX refers to as object to object SOAP operations are performed using the following method:
<pre class='code'>
    s_winhttp_error soap_rpc(
                        <span class='ckw'>const</span> std::string &ar_path,
                        <span class='ckw'>const</span> c_soap_base &ar_request,
                        c_soap_base *ap_response );
</pre>
This operation marshals the objects aggregated by the <code>c_soap</code> object referenced by <code>ar_request</code> into an XML message, and sends this to the server.  The XML message returned from the server is unmarshalled and placed in the <code>c_soap</code> object pointed to by <code>ap_response</code>.
<p>
The <code>SOAPAction</code> for the operation is retrieved from the <code>c_soap</code> object referenced by <code>ar_request</code>.
<p>
The <code>ar_path</code> argument has the same meaning as in the message to message operation case.
<p>
The method returns an instance of <code>s_winhttp_error</code>.  As the method performs both LMX and HTTP operations, this is an aggregate object capturing the various possible error conditions.  If <code>s_winhttp_error</code>'s <code>is_ok()</code> method returns <code>true</code> then the operation was successful.  If the operation was unsuccessful, the operation phase at which the error occurred (e.g marshalling, HTTP transaction or unmarshalling) can be determined by inspecting <code>s_winhttp_error</code>'s <code>phase</code> member.  Depending on the phase at which the error occurred, either the <code>lmx_error</code> or <code>http_error</code> member can be inspected to find out more specific information.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SimpleSOAPOperations'></a>
<h4>3.11.2.3&nbsp;-&nbsp;Simple SOAP Operations</h4>
<p>
When a SOAP operation consists of only a single body part, without SOAP headers or faults, then a Simple SOAP Operation can be performed using the following template function:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> Tin, <span class='ckw'>class</span> Tout>
    s_winhttp_error simple_soap(
                        <span class='ckw'>const</span> std::string &ar_host,
                        size_t a_port,
                        <span class='ckw'>const</span> std::string &ar_path,
                        <span class='ckw'>const</span> tlmx_uri_string &ar_soap_action,
                        Tin *ap_in,
                        Tout **app_out = LMXNULL,   <span class='ccom'>// Allows an empty SOAP body in the reply</span>
                        <span class='ckw'>bool</span> a_is_secure = false )
</pre>
Or, if it is not necessary to change the default port, the following template function:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> Tin, <span class='ckw'>class</span> Tout>
    s_winhttp_error simple_soap(
                        <span class='ckw'>const</span> std::string &ar_host,
                        <span class='ckw'>const</span> std::string &ar_path,
                        <span class='ckw'>const</span> tlmx_uri_string &ar_soap_action,
                        Tin *ap_in,
                        Tout **app_out = LMXNULL,   <span class='ccom'>// Allows an empty SOAP body in the reply</span>
                        <span class='ckw'>bool</span> a_is_secure = false )
</pre>
This is <em>not</em> a member of <code>c_winhttp</code>, but uses its services.
<p>
In these functions, the <code>ar_host</code>, <code>a_port</code>, <code>ar_path</code>, <code>ar_soap_action</code>, and <code>a_is_secure</code> have the same meanings as described elsewhere in this section.
<p>
The <code>ap_in</code> argument takes a pointer to an object corresponding to the template argument <code>Tin</code> (whose code is generated by LMX) that, when marshaled, will form the body of the SOAP request.  
<p>
If the operation is successful, the function creates an unmarshalled object of type template argument <code>Tout</code> on the heap.  To be able to access this object, the calling function must have a pointer to a <code>Tout</code> object.  A pointer to this pointer is then supplied to <code>simple_soap</code> so that <code>simple_soap</code> can set its value.  Note that if no SOAP body is returned, the pointer to <code>Tout</code> in the calling function may be set to <coee>0</code>.
<p>
The return value of the function is an instance of <code>s_winhttp_error</code>, and is interpreted as described in the object to object operation case above.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='RESTfulOperations'></a>
<h4>3.11.2.4&nbsp;-&nbsp;RESTful Operations</h4>
<p>
REST style operations can be performed using the following <code>c_winhttp</code> member method:
<pre class='code'>
    <span class='ckw'>int</span> rest_query( <span class='ckw'>const</span> std::string &ar_path,
                    <span class='ckw'>const</span> std::string &ar_query,
                    std::string *ap_response_xml );
</pre>
If the URI for the REST operation was <code>http://example.com:8080/my/service?what=rest</code> then <code>ar_path</code> should be set to <code>/my/service</code> and <code>ar_query</code> should be set to <code>what=rest</code>.  (The host is set when the <code>c_winhttp</code> object is constructed.)
<p>
The XML response to the query is placed in the <code>std::string</code> pointed to by <code>ap_response_xml</code>.  This can subsequently be unmarshalled using LMX generated code.
<p>
If the method returns <code>0</code> then the operation was successful.  A non-<code>0</code> value indicates an error.  If an error has occurred, a description of the error can be obtained by calling the <code>get_error_description( int a_error )</code> method.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='NamingofMethodsandVariables'></a>
<h2>3.12&nbsp;-&nbsp;Naming of Methods and Variables</h2>
LMX allows extensive customization of the variable and method names used in the generated code.  There are two parts to setting the names and variables in LMX; setting the prefixes and setting the base names.  Both of these operate independently.  
<p>
The prefixes of methods and variables are configured using project configuration flags (also accessible via the Windows UI).  For example, if you wish the functions that are named by default as <code>getenum_YYY()</code> to be <code>getEnumYYY()</code> then the project flag '<code>-prefix-getenum</code>' should be set to '<code>getEnum</code>', either directly or via the Windows UI.  The prefixes set in this way have project wide scope.  See the <code>-prefix-???</code> flags in section <a href='#CommandlineFlags'>3.8&nbsp;-&nbsp;Command-line Flags</a> for the set of prefixes that can be changed.
<p>
The base names of variables and methods (e.g. the <code>YYY</code> part in the examples above) can be automatically converted from the form specified in the schema to CamelCase or underscore_separated either via the GUIs or using the <code>-naming camel</code> or <code>-naming underscore</code> flag.
<p>
The base names of variables and methods can also be set by names files.  LMX automatically performs name collision avoidance, but if a schema is updated there is a small chance for a name to be assigned to a different element/attribute in the new code to the one it was in the previous version.  The names files address this problem.  (Note that in many scenarios such naming issues will not be a problem between versions of a schema, so this feature need not be used in all cases.)  
<p>
When the <code>-names-out</code> option is specified, LMX will generate a names file for each schema used in a project.  By default, the name of the names file will be the name of the schema appended with '<code>.lmxnames-<em>out</em>.xml</code>'.  For example, if the name of the schema file is '<code>mySchema.xsd</code>', the generated names file will be called '<code>mySchema.xsd.lmxnames-out.xml</code>'.  To avoid accidental overwriting, the appended text on the names file needs to be modified to '<code>.lmxnames-<em>in</em>.xml</code>' before it can be used as an input names file.  An input names file will be read (for example, when processing the new version of the schema) if the '<code>-names-in</code>' option is chosen. 
<p>
Additionally, it is also possible to specify an alternative directory in which the names files are stored.  This is done using the <code>-names-dir  YYY</code> flag; where YYY is the name of the directory (of folder) storing the names files.  This can allow the same schema to have different names files for different projects.  In this case the name of a names file is made up of the directory specified by the <code>-names-dir</code> flag, and the base name of the schema file, suffixed by either the extension <code>.lmxnames-out.xml</code>  or <code>.lmxnames-out.xml</code>.  For example, if <code>-names-dir foo</code> is specified and the schema file name is <code>bar/mySchema.xsd</code>, then the in names file would be <code>foo/mySchema.xsd.lmxnames-in.xml</code>.
<p>
The names file also allows you to customize the names used in the code.  If you are not able to use the WinLMX version of LMX, the easiest way to do this is to run the code generator with the '<code>-names-out</code>' option first, re-name the names file extension to '<code>.lmxnames-<em>in</em>.xml</code>', and edit the names in the file to your convenience.  When the naming is complete, run the code generator with the '<code>-names-in</code>' option specified.
<p>
The schema for the names file is as follows:
<pre class='schema'>
    &lt;<span class='xtag'>xs:schema</span> <span class='xattr'>targetNamespace</span>="http://xml2cpp.com/lmx-customize.xsd"
                    <span class='xattr'>elementFormDefault</span>="qualified"
                    <span class='xattr'>xmlns</span>="http://xml2cpp.com/lmx-customize.xsd"
                    <span class='xattr'>xmlns:xs</span>="http://www.w3.org/2001/XMLSchema"
                    <span class='xattr'>xmlns:clt</span>="http://codalogic.com/xsdtypes">
                      
        &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>='lmxCustomize'>
            &lt;<span class='xtag'>xs:complexType</span>>
                &lt;<span class='xtag'>xs:sequence</span>>
                    &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="element" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded"/>
                    &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="attribute" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded"/>
                    &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="group" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded"/>
                    &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="attributeGroup" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded"/>
                    &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="type" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded"/>
                &lt;/<span class='xtag'>xs:sequence</span>>
                
                &lt;<span class='xtag'>xs:attribute</span> <span class='xattr'>name</span>="version" <span class='xattr'>type</span>="xs:token" <span class='xattr'>default</span>="1.0">
                    &lt;<span class='xtag'>xs:annotation</span>>&lt;<span class='xtag'>xs:documentation</span>>
                        Use major.minor format
                    &lt;/<span class='xtag'>xs:documentation</span>>&lt;/<span class='xtag'>xs:annotation</span>>
                &lt;/<span class='xtag'>xs:attribute</span>>
                
            &lt;/<span class='xtag'>xs:complexType</span>>
        &lt;/<span class='xtag'>xs:element</span>>
        
        
        &lt;<span class='xtag'>xs:complexType</span> <span class='xattr'>name</span>="item">
            &lt;<span class='xtag'>xs:sequence</span>>
                &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="element" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded">
                    &lt;<span class='xtag'>xs:annotation</span>>&lt;<span class='xtag'>xs:documentation</span>>
                        For naming child elements of complex type/complex 
                        content.
                    &lt;/<span class='xtag'>xs:documentation</span>>&lt;/<span class='xtag'>xs:annotation</span>>
                &lt;/<span class='xtag'>xs:element</span>>

                &lt;<span class='xtag'>xs:element</span> <span class='xattr'>name</span>="attribute" <span class='xattr'>type</span>="item" 
                                    <span class='xattr'>minOccurs</span>="0" <span class='xattr'>maxOccurs</span>="unbounded"/>
            &lt;/<span class='xtag'>xs:sequence</span>>
            
            &lt;<span class='xtag'>xs:attribute</span> <span class='xattr'>name</span>="name" <span class='xattr'>type</span>="xs:string">
                &lt;<span class='xtag'>xs:annotation</span>>&lt;<span class='xtag'>xs:documentation</span>>
                    Optional.  The name of the item specified in the schema.  
                    It may be absent if it is an anonymous type.
                &lt;/<span class='xtag'>xs:documentation</span>>&lt;/<span class='xtag'>xs:annotation</span>>
            &lt;/<span class='xtag'>xs:attribute</span>>
            
            &lt;<span class='xtag'>xs:attribute</span> <span class='xattr'>name</span>="asVarName" <span class='xattr'>type</span>="clt:asciiString">
                &lt;<span class='xtag'>xs:annotation</span>>&lt;<span class='xtag'>xs:documentation</span>>
                    Optional - The name of the item when it is used as a 
                    variable's name, as in: 'c_type var_name;'  It must 
                    be locally unique, but need not be globally unique.
                &lt;/<span class='xtag'>xs:documentation</span>>&lt;/<span class='xtag'>xs:annotation</span>>
            &lt;/<span class='xtag'>xs:attribute</span>>
            
            &lt;<span class='xtag'>xs:attribute</span> <span class='xattr'>name</span>="asTypeName" <span class='xattr'>type</span>="clt:asciiString">
                &lt;<span class='xtag'>xs:annotation</span>>&lt;<span class='xtag'>xs:documentation</span>>
                    Optional.  The name of the item when it is used as a 
                    C++ type, e.g. 'c_type name;'  It must be globally unique.
                &lt;/<span class='xtag'>xs:documentation</span>>&lt;/<span class='xtag'>xs:annotation</span>>
            &lt;/<span class='xtag'>xs:attribute</span>>
            
        &lt;/<span class='xtag'>xs:complexType</span>>
    &lt;/<span class='xtag'>xs:schema</span>>
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AdaptingLMXtoYourEnvironment'></a>
<h2>3.13&nbsp;-&nbsp;Adapting LMX to Your Environment</h2>
<p>
In some cases you may find that the various classes and types included with LMX are not what you want.  LMX has been designed so that it is easy to change the types and classes used.
<p>
The majority of configuration options are specified in the <code>lmxuser.h</code> file.  Each user configuration section is marked with C++ comments of the form <code>USER: A_SECTION</code>.  
<p>
There are a number of ways in which you can customize the features controlled by the <code>lmxuser.h</code> file.  For example, you can:
<ol>
<li>Modify <code>lmxuser.h</code> directly.  This is the least recommended method because it means if a new version of LMX is issued, then you may have to update a new copy of <code>lmxuser.h</code>, potentially introducing bugs through human error.
<p>
<li>If only minor configuration is required, and the changes needed are of the more common type, the build environment (such as project files or make files) can arrange for the appropriate <code>#define</code>s to be set to get the desired configuration.
<p>
<li>If more substantial configuration is required, then it is suggested that the various <code>#define</code>s are included in their own <code>.h</code> file and that <code>.h</code> file in turn includes <code>lmxuser.h</code>.  You can then use LMX's <code>-include-h</code> flag (or "Advanced"->"Include Files in Generated.h Files..." menu option in WinLMX) to include the file in the generated code.
<p>
<li>As an alternative to the previous option, you can include your configuration changes in the files called <code>lmxuser-def.h</code> and <code>lmxuser-defs-end.h</code>.  <code>lmxuser.h</code> will pull in the file <code>lmxuser-def.h</code> if your project specifies the definition <code>LMX_WANT_USER_DEFS</code> and pull in <code>lmxuser-defs-end.h</code> if your project specifies <code>LMX_WANT_USER_DEFS_END</code>.  
</ol>
The last two methods are appropriate when complete sections of <code>lmxuser.h</code> need to be changed.  It will be observed that each section is included in its own conditional compilation guard block.  If a particular feature can not be changed using the <code>#define</code>s that LMX supports, then copy the entire section into the separate include file mentioned in the latter methods, and edit it accordingly.  Then <code>#define</code> the appropriate guard value so that the default section in <code>lmxuser.h</code> is ignored.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ModifyingSchemaTypetoCTypeMapping'></a>
<h3>3.13.1&nbsp;-&nbsp;Modifying Schema Type to C++ Type Mapping</h3>
<p>
XML schema type to C++ type mapping is specified in the <code>USER: BASIC_TYPES</code> and <code>USER: COMPOUND_TYPES</code> sections of the lmxuser.h file.  The type mapping is achieved using simple C++ <code>typedef</code> statements to avoid you having to learn additional LMX code-generator configuration options.  Changing the types used is simply a matter of modifying the <code>typedef</code> statements.  For example, if you wish to use your own date class, you could define a mapping of:
<pre class='code'>
    <span class='ckw'>typedef</span> c_my_date          tc_date;
</pre>

The following table describes the relationship between the schema types, the C++ <code>typedef</code> name used to represent it, and the default C++ type that the <code>typedef</code> name is mapped to.
<p>
<!-- NEED 35cm -->
<center>
<table border='1'>
<tr><th>XSD Type</th><th>C++ Intermediate Type</th><th>Default C++ Type</th></tr>
<tr><td>boolean </td>
	<td>bool</td>
	<td>bool <font size='-2'>(This type can not be customized)</font></td></tr>

<tr><td>byte</td>
	<td>tlmx_int8</td>
	<td>signed char</td></tr>

<tr><td>short</td>
	<td>tlmx_int16</td>
	<td>short</td></tr>

<tr><td>int</td>
	<td>tlmx_int32</td>
	<td>int</td></tr>

<tr><td>long</td>
	<td>tlmx_int64</td>
	<td>For MSVC: __int64<br>
		For GCC: long long</td></tr>

<tr><td>unsignedByte</td>
	<td>tlmx_uns8</td>
	<td>unsigned char</td></tr>

<tr><td>unsignedShort</td>
	<td>tlmx_uns16</td>
	<td>unsigned short</td></tr>

<tr><td>unsignedInt</td>
	<td>tlmx_uns32</td>
	<td>unsigned int</td></tr>

<tr><td>unsignedLong</td>
	<td>tlmx_uns64</td>
	<td>For MSVC: unsigned __int64<br>
		For GCC: unsigned long long</td></tr>

<tr><td>integer, nonPositiveInteger, negativeInteger,<br>
		nonNegativeInteger, positiveInteger</td>
	<td>tc_big_int</td>
	<td><a href='#section-ct_c_big_int'>c_big_int</a></td></tr>

<tr><td>decimal</td>
	<td>tc_decimal</td>
	<td><a href='#section-ct_c_decimal'>c_decimal</a></td></tr>

<tr><td>float</td>
	<td>tlmx_float</td>
	<td>float</td></tr>

<tr><td>double</td>
	<td>tlmx_double</td>
	<td>double</td></tr>

<tr><td>duration</td>
	<td>tc_duration</td>
	<td><a href='#section-ct_c_duration'>c_duration</a></td></tr>

<tr><td>dateTime</td>
	<td>tc_datetime</td>
	<td><a href='#section-ct_c_datetime'>c_datetime</a></td></tr>

<tr><td>time</td>
	<td>tc_time</td>
	<td><a href='#section-ct_c_time'>c_time</a></td></tr>

<tr><td>date</td>
	<td>tc_date</td>
	<td><a href='#section-ct_c_date'>c_date</a></td></tr>

<tr><td>gYearMonth</td>
	<td>tc_gyearmonth</td>
	<td><a href='#section-ct_c_gyearmonth'>c_gyearmonth</a></td></tr>

<tr><td>gYear</td>
	<td>tc_gyear</td>
	<td><a href='#section-ct_c_gyear'>c_gyear</a></td></tr>

<tr><td>gMonthDay</td>
	<td>tc_gmonthday</td>
	<td><a href='#section-ct_c_gmonthday'>c_gmonthday</a></td></tr>

<tr><td>gDay</td>
	<td>tc_gday</td>
	<td><a href='#section-ct_c_gday'>c_gday</a></td></tr>

<tr><td>gMonth</td>
	<td>tc_gmonth</td>
	<td><a href='#section-ct_c_gmonth'>c_gmonth</a></td></tr>

<tr><td>hexBinary, base64Binary</td>
	<td>tc_binary</td>
	<td><a href='#section-ct_c_binary'>c_binary</a></td></tr>

<tr><td>string,
		normalizedString, language, token, Name, NCName, 
		ID, IDREF, IDREFS, ENTITY, ENTITIES, NMTOKEN, 
		NMTOKENS, NOTATION</td>
	<td>tlmx_unicode_string</td><td>std::wstring</td></tr>

<tr><td>anyURI</td>
	<td>tlmx_uri_string</td><td>std::wstring</td></tr>

<tr><td>QName</td>
	<td>tc_qname</td><td>ct_qname&lt;tlmx_uri_string></td></tr>
</table>
<b>Table 5: XSD to C++ Type Mappings</b>
</center>
<p>
Similarly <code>tlmx_uri_string</code> controls the type of string used for URIs.  By default this is mapped to <code>std::wstring</code>, but if you wish it to be mapped to <code>std::string</code> then arrange for the #define variable <code>LMX_NARROW_URI_STRINGS</code> to be 1.  If <code>LMX_NARROW_URI_STRINGS</code> is not specified, then it is automatically given the same value as <code>LMX_NARROW_UNICODE_STRINGS</code>.
<p>
Note that by default <code>xs:float</code> is mapped to a C++ <code>float</code>.  Such a single precision floating point number has about 7.5 decimal places of precision; a precision that can not be readily expressed using C++'s output converters.  Consequently, LMX outputs C++ <code>float</code>s using 7 decimal places of precision (as opposed to 8 places which typically results in sub-optimal formatting), thus losing the ability to express the entire precision of the type.  Therefore, if you require the full precision of the <code>xs:float</code> type it is recommended that you map it to C++'s <code>double</code> type.
<p>
In addition to changing the C++ types used to represent the LMX types, LMX needs to know whether each integer type is a type native to your C++ compiler (e.g. VC++'s <code>__int64</code> is considered native), or a special class.  This is done using the <code>USER: INT_NATIVE_FOREIGN</code> section of the <code>lmxuser.h</code> file.  This section contains a number of macros specific to each integer type that either maps to a native value or a foreign value.  You should change the mapping of these macros according to your platform requirements.
<p>
See also <a href='#PatternFacetHandlingCustomization'>3.23&nbsp;-&nbsp;Pattern Facet Handling Customization</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ChoosingBetweenWideandNarrowUnicodeStrings'></a>
<h4>3.13.1.1&nbsp;-&nbsp;Choosing Between Wide and Narrow Unicode Strings</h4>
<p>
Of particular note is the mapping of <code>tlmx_unicode_string</code>.  By default this is mapped to <code>std::wstring</code>.  If you wish to use 'narrow' strings to store parsed strings, you can arrange your project C++ build configuration to define the #define variable <code>LMX_NARROW_UNICODE_STRINGS</code> to be 1.  Alternatively, you can directly modify the mapping in <code>lmxuser.h</code> to be <code>std::string</code>.  All other changes will be automatically taken care of by the C++ compiler.  Or you can map <code>tlmx_unicode_string</code> to some other string class.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='InputOutputConverters'></a>
<h4>3.13.1.2&nbsp;-&nbsp;Input/Output Converters</h4>
<p>
As part of changing the type mappings used, it may be necessary to define additional input and output converters.  These are defined in the <code>USER: TEMPLATE_INPUT_CONVERTERS</code>, and <code>USER: TEMPLATE_OUTPUT_CONVERTERS</code> sections of lmxuser.h.
<p>
All types are converted from their string form to their type form via the templated function <code>v_to_o</code> (short for 'value_to_object'.).  If your type (such as a date class) has an <code>operator =</code> member that can convert a std::string value to appropriate internal values, then the default <code>v_to_o</code> template function will take care of this and no additional work is required.  If your class does not support this, then you should provide a template specialization of <code>v_to_o</code> that will do the conversion.  Examples of such specializations are shown in the <code>USER: TEMPLATE_INPUT_CONVERTERS</code> section.  One option for such conversion that eases parsing is to first convert the input to an appropriate LMX class, and then use the public members of that class to populate your class.
<p>
For output, the LMX code generator arranges for each parameter to be wrapped in an instance of an <code>as_xml</code> io manipulator.  These manipulators are defined in the <code>USER: TEMPLATE_OUTPUT_CONVERTERS</code>.  If your class or type has an io operator (i.e. &lt;&lt;) that generates data in a suitable form for output in an XML document, then the default template will be sufficient and no additional specialization is required.  If this is not the case, then a specialization of the output template is required.  For example, a specialization for your type might appear as:
<pre class='code'>
    <span class='ckw'>template</span> &lt;>
    std::ostream & <span class='ckw'>operator</span> &lt;&lt; ( std::ostream & ar_os, 
                                 <span class='ckw'>const</span> c_as_xml&lt;c_my_date> &ar_v )
    { ... }
</pre>
Within the template specialization function, the quantity <code>ar_v.p</code> is a pointer to the item to be output.  You can look at some of the other specializations to see how to write a specialization.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AugmentingGeneratedClassesWithYourOwnCode'></a>
<h2>3.14&nbsp;-&nbsp;Augmenting Generated Classes With Your Own Code</h2>
<p>
LMX allows you to augment the generated classes with your own code.  Specifying the <code>-snippets</code> flag will cause LMX to output a pair of comments towards the beginning of each generated class in a .h file.  The markers have the form:
<pre class='code'>
    <span class='ccom'>//:snippet:start YYY</span>
    <span class='ccom'>//:snippet:end YYY</span>
</pre>
where YYY is the name of the class in which the markers are included.  You can add your own code between the markers.  When code is re-generated, LMX first reads the original .h file and extracts the code between the snippet markers.  The code is then put back when the new code is generated.  Non-header code such as method definitions should be put in a separate .cpp file.  You should not change the generated .cpp files.
<p>
As a precaution, it is recommended that you have a backup of the original .h file (for example, in a version control system) before re-generating code to replace it.
<p>
If you wish to augment a class with lots of code it may be appropriate to consider defining a separate class, and then including the declaration of an instance of that class in the snippets section.  This further separates your code and the generated code.  To do this it may be necessary to use the <code>-include-h</code> to inform LMX of a header file defining your class, and implement an <code>on_lmx_construct()</code> snippet event handler (see <a href='#AugmentingGeneratedClasseswithSnippetEventHandlers'>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</a> below) that can inform your separate class of the <code>this</code> pointer (or a reference) of the generated class.  For example, in this case the snippets section for a class might appear as:
<pre class='code'>
    <span class='ccom'>//:snippet:start YYY</span>
    c_my_details_class my_class;
    <span class='ckw'>void</span> on_lmx_construct() { my_class.set_parent( <span class='ckw'>this</span> ); }
    <span class='ccom'>//:snippet:end YYY</span>
</pre>
<p>
As described above this procedure requires editing the generated <code>.h</code> file.  If you do not wish to do this, the <code>-file-ext-snippets</code> flag allows the specification of the file extension for files that store snippets.  For example, if <code>-file-ext-snippets .lmxsnips</code> is specified, LMX will look in <code>foo.lmxsnips</code> for snippets rather than in <code>foo.h</code>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AugmentingGeneratedClasseswithSnippetEventHandlers'></a>
<h3>3.14.1&nbsp;-&nbsp;Augmenting Generated Classes with Snippet Event Handlers</h3>
<p>
The behavior of the LMX generated classes can be augmented by what are called snippet event handlers.  When generating code, LMX looks for the declaration of specially named functions in each class's snippets section.  If the name of a special function is found, then code is generated to call that function.  The defined snippet event handler functions are:
<pre class='code'>
  <span class='ckw'>void</span> on_lmx_construct();

  <span class='ckw'>void</span> on_lmx_copy_construct( <span class='ckw'>const</span> ??? & r_rhs );

  <span class='ckw'>void</span> on_lmx_swap( ??? & r_rhs );

  <span class='ckw'>void</span> on_lmx_destruct();

  <span class='ckw'>bool</span> on_lmx_eq( <span class='ckw'>const</span> ??? & r_rhs ) <span class='ckw'>const</span>;

  <span class='ckw'>bool</span> on_lmx_is_occurs_ok() <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_marshal_start( lmx::c_xml_writer & r_writer, 
                                        <span class='ckw'>const</span> <span class='ckw'>char</span> * p_element_name ) <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_marshal_end( lmx::c_xml_writer & r_writer ) <span class='ckw'>const</span>;

  <span class='ccom'>// Currently return code for on_lmx_marshal_start_tag() is ignored</span>
  lmx::elmx_error on_lmx_marshal_start_tag( lmx::c_xml_writer & r_writer ) <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_marshal_body_start( lmx::c_xml_writer & r_writer ) <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_marshal_body_end( lmx::c_xml_writer & r_writer ) <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_alt_marshal_attribute_XYZ(
            lmx::c_xml_writer & r_writer,
            <span class='ckw'>const</span> lmx::ct_typed_validation_spec&lt; ??? > & r_item_spec ) <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_alt_marshal_element_XYZ(
            lmx::c_xml_writer & r_writer,
            <span class='ckw'>const</span> lmx::ct_typed_validation_spec&lt; ??? > & r_item_spec ) <span class='ckw'>const</span>;

  lmx::elmx_error on_lmx_unmarshal_outer_start( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_unmarshal_outer_end( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_unmarshal_start( lmx::c_xml_reader & r_reader,
                                          <span class='ckw'>const</span> std::string & r_name );

  lmx::elmx_error on_lmx_unmarshal_start( lmx::c_xml_reader & r_reader,
                                          <span class='ckw'>const</span> std::string & r_name );

  lmx::elmx_error on_lmx_unmarshal_end( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_unmarshal_attributes_check( 
                                        lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_unmarshal_body_start( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_unmarshal_body_end( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_unmarshal_attribute_XYZ( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_alt_unmarshal_attribute_XYZ(
            lmx::c_xml_reader & r_reader,
            <span class='ckw'>const</span> lmx::ct_typed_validation_spec&lt; ??? > & r_item_spec );

  lmx::elmx_error on_lmx_unmarshal_element_XYZ( lmx::c_xml_reader & r_reader );

  lmx::elmx_error on_lmx_alt_unmarshal_element_XYZ(
            lmx::c_xml_reader & r_reader,
            <span class='ckw'>const</span> lmx::ct_typed_validation_spec&lt; ??? > & r_item_spec,
            <span class='ckw'>const</span> lmx::s_event_map event_map[] );

  lmx::elmx_error on_lmx_alt_unmarshal_xs_any(
            lmx::c_xml_reader & r_reader,
            <span class='ckw'>const</span> lmx::s_event_map ac_event_map[] );
</pre>
The snippet event handler functions are called in the following situations:
<ul>
<dl>
<dt>on_lmx_construct()</dt><dd>Called immediately after the code generated to initialize the object.  This allows initializing snippet data.</dd>
<p>
<dt>on_lmx_copy_construct()</dt><dd>Called in the generated copy constructor.</dd>
<p>
<dt>on_lmx_swap()</dt><dd>Called in the generated swap method.</dd>
<p>
<dt>on_lmx_destruct()</dt><dd>Called immediately before the code generated to destroy an object.  This is intended to give the opportunity to do special handling of the data before it is destroyed and destroy any data introduced through snippets.</dd>
<p>
<dt>on_lmx_eq()</dt><dd>Called in the generated equality testing methods called by the generated <code>operator ==()</code> method.</dd>
<p>
<dt>on_lmx_is_occurs_ok()</dt><dd>Called in place of the generated version of is_occurs_ok() at the start of the marshalling operation.</dd>
<p>
<dt>on_lmx_marshal_start()</dt><dd>Called at the start of the object's main top-level marshaling method.  It can be used to implement additional user defined checks on the data before it is marshaled.</dd>
<p>
<dt>on_lmx_marshal_end()</dt><dd>Called at the end of the object's main top-level marshalling method just prior to the final <code>return</code> statement.</dd>
<p>
<dt>on_lmx_marshal_start_tag()</dt><dd>Called while outputting attributes in an element's start tag.  It can be used to output additional attributes.  (Note that the return code from this function is currently ignored.  This situation may change in future however.)</dd>
<p>
<dt>on_lmx_marshal_body_start()</dt><dd>Called at the start of an elements <code>marshal_body()</code> method.</dd>
<p>
<dt>on_lmx_marshal_body_end()</dt><dd>Called at the end of an elements <code>marshal_body()</code> method.  It can be used to output additional elements.</dd>
<p>
<dt>on_lmx_alt_marshal_attribute_XYZ()</dt><dd>Allows you to specify alternative marshalling behavior for attribute XYZ.</dd>
<p>
<dt>on_lmx_alt_marshal_element_XYZ()</dt><dd>Allows you to specify alternative marshalling behavior for element XYZ.</dd>
<p>
<dt>on_lmx_unmarshal_outer_start()</dt><dd>Called at the start of the outer-most, top-level object's main unmarshaling method.</dd>
<p>
<dt>on_lmx_unmarshal_outer_end()</dt><dd>Called at the end of the outer-most, top-level object's main unmarshaling method.</dd>
<p>
<dt>on_lmx_unmarshal_start()</dt><dd>Called at the start of the object's main top-level unmarshaling method.  </dd>
<p>
<dt>on_lmx_unmarshal_end()</dt><dd>Called at the end of the object's main top-level unmarshalling method just prior to the final <code>return</code> statement.  It can be used to implement additional user defined checks on the data immediately after it is unmarshaled (for example co-occurrence constraints).</dd>
<p>
<dt>on_lmx_unmarshal_attributes_check()</dt><dd>Called in the <code>unmarshal_attributes_check()</code> method.</dd>
<p>
<dt>on_lmx_unmarshal_body_start()</dt><dd>Called at the start of an elements <code>unmarshal_body()</code> method.</dd>
<p>
<dt>on_lmx_unmarshal_body_end()</dt><dd>Called at the end of an elements <code>unmarshal_body()</code> method.</dd>
<p>
<dt>on_lmx_unmarshal_attribute_XYZ()</dt><dd>Called when the attribute stored in the C++ variable m_XYZ has been unmarshalled and stored in the object.</dd>
<p>
<dt>on_lmx_alt_unmarshal_attribute_XYZ()</dt><dd>Allows you to specify alternative unmarshalling behavior for attribute XYZ.</dd>
<p>
<dt>on_lmx_unmarshal_element_XYZ()</dt><dd>Called when a new instance of the element has been unmarshalled and is stored in the C++ variable m_XYZ.</dd>
<p>
<dt>on_lmx_alt_unmarshal_element_XYZ()</dt><dd>Allows you to specify alternative unmarshalling behavior for element XYZ.</dd>
<p>
<dt>on_lmx_alt_unmarshal_xs_any()</dt><dd>Allows you to specify alternative unmarshalling for an element corresponding to an xs:any specification.</dd>
<p>
</dl>
</ul>
It will be noticed that the marshal and unmarshal event handlers return an <code>lmx::elmx_error</code> value.  If the value returned is not <code>lmx::ELMX_OK</code> then the marshaling or unmarshaling operation is terminated and the error code returned.  To provide custom error feedback, the <code>lmx::elmx_error</code> enumeration contains enumeration values <code>ELMX_USER_DEFINED_1</code> to <code>ELMX_USER_DEFINED_9</code>.
<p>
Similarly, the marshal and unmarshal event handlers take as an argument a reference to the marshaling operations <code>lmx::c_xml_writer</code> object, or the unmarshaling operations <code>lmx::c_xml_reader</code> object.  If the <code>-alt-xml-writer</code> or <code>-alt-xml-reader</code> command-line flags are used to change the names of these two latter objects, then a reference to the specified objects will be passed.  This gives the opportunity to pass additional data into the event handlers.
<p>
One use of the <code>on_lmx_alt_unmarshal_element_XYZ()</code> snippet event handler is to enable the user to ignore particular elements.  The <code>elmx_error c_xml_reader::ignore_element(...)</code> method is provided to help with the implementation of such a handler.  For example:
<pre class='code'>
    lmx::elmx_error c_MyElement::on_lmx_alt_unmarshal_element_ChildElement( 
                lmx::c_xml_reader & ar_reader,
                <span class='ckw'>const</span> lmx::s_event_map ac_event_map[] )
    {
        <span class='ckw'>return</span> ar_reader.ignore_element( ac_event_map );
    }
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='DTDsandNamespaces'></a>
<h2>3.15&nbsp;-&nbsp;DTDs and Namespaces</h2>
<p>
DTDs do not explicitly support XML namespaces.  However, LMX can extract namespace information from DTDs via attribute definitions that contain the <code>xmlns</code> prefix and have a #FIXED specification.  For example, to declare that the namespace prefix '<code>ns</code>' should be associated with the namespace '<code>http://xml2cpp.com/example</code>', use the following attribute definition:
<pre class='code'>
&lt;!ATTLIST ns:MyElement xmlns:ns CDATA #FIXED "http://xml2cpp.com/dtd-test.html">
</pre>
To set the default namespace, use:
<pre class='code'>
&lt;!ATTLIST MyElement xmlns CDATA #FIXED "http://xml2cpp.com/dtd-test.html">
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='DebuggingandHandlingErrors'></a>
<h2>3.16&nbsp;-&nbsp;Debugging and Handling Errors</h2>
<p>
LMX is designed to be flexible about how run-time errors are handled.  It also includes features to aid debugging.
<p>
There are three categories of error that can occur.  These are parse errors, write errors, and class access errors.  Any error that occurs in one of these categories is first passed to a category specific error handling function.  The functions are <code>c_xml_reader::handle_error</code>, <code>c_xml_writer::handle_error</code> (both in lmxparse.h), and <code>lmx_error</code> in lmxuser.h respectively.  These functions allow you to tailor the error handling to your requirements.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ReportingErrors'></a>
<h3>3.16.1&nbsp;-&nbsp;Reporting Errors</h3>
<p>
LMX includes a number of functions to help report errors to a user.
<p>
To convert an error code to a description, the global <code>get_error_description</code> function can be called.  The prototype for this function is:
<pre class='proto'>
   <span class='ckw'>const</span> <span class='ckw'>char</span> *get_error_description( elmx_error a_error_code );
</pre>
The error code is entered in <code>a_error_code</code> and the return value points to a const char string describing the error.
<p>
<code>c_xml_reader</code> and <code>c_xml_writer</code> both include a <code>get_error_message</code> function.  The prototypes for the functions are:
<pre class='proto'>
   virtual std::string & c_xml_reader::get_error_message( std::string *ap_message );
   virtual std::string & c_xml_writer::get_error_message( std::string *ap_message );
</pre>
An error message, including the name of the element or attribute in question, and the line number (if applicable) will be inserted with a description into the string pointed to by <code>ap_message</code>.  The function returns a reference to <code>*ap_message</code>.  The function is virtual to allow user customization of the message format.
<p>
The line number that the error occurred on can be obtained by calling:
<pre class='proto'>
    <span class='ckw'>int</span> c_xml_reader::get_line_no();
</pre>
<code>c_xml_writer</code> does not keep track of line numbers due to its use of <code>iostream</code>s, and hence has no corresponding function.
<p>
<code>c_xml_reader</code> and <code>c_xml_writer</code> allow the element or attribute name applicable to an error to be obtained by calling:
<pre class='proto'>
    <span class='ckw'>const</span> std::string & c_xml_reader::get_error_item_name();
    <span class='ckw'>const</span> std::string & c_xml_writer::get_error_item_name();
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ChangingtheErrorHandlingBehavior'></a>
<h3>3.16.2&nbsp;-&nbsp;Changing the Error Handling Behavior</h3>
<p>
As supplied, the above functions support the 'return code' paradigm for reporting errors and the code generated by LMX allows the return code to be propagated back to the original calling function.  
<p>
You can select exception-based error reporting by setting the <code>LMX_USE_USER_VALIDATE_EXCEPTIONS</code> and <code>LMX_USE_EXCEPTIONS</code> pre-processor constants to <code>1</code>.  The constants are defined in the <code>USER: CTRL_DEFS</code> section of <code>lmxuser.h</code>.  <code>LMX_USE_USER_VALIDATE_EXCEPTIONS</code> selects exceptions when validating user access to the objects and  <code>LMX_USE_EXCEPTIONS</code> selects exceptions when marshaling and unmarshaling.  If exception-based error reporting is selected, exceptions are reported using instances of the <code>c_lmx_exception</code> and <code>c_lmx_reader_exception</code> classes defined in <code>lmxinternals.h</code>.  <code>c_lmx_reader_exception</code> is used to signal exceptions from <code>c_xml_reader</code>, and <code>c_lmx_exception</code> is used for all other exceptions.  There public interface is as follows:
<p>
<pre class='code'>
    <span class='ckw'>class</span> c_lmx_exception
    {
    <span class='ckw'>public</span>:
	    c_lmx_exception( elmx_error a_error_code );
	    elmx_error get_error() <span class='ckw'>const</span>;
	    virtual <span class='ckw'>const</span> <span class='ckw'>char</span> *what() <span class='ckw'>const</span> <span class='ckw'>throw</span>();
    };

    <span class='ckw'>class</span> c_lmx_reader_exception : <span class='ckw'>public</span> c_lmx_exception
    {
    <span class='ckw'>public</span>:
	    c_lmx_reader_exception( elmx_error a_error_code, <span class='ckw'>int</span> a_line );
	    <span class='ckw'>int</span> get_line() <span class='ckw'>const</span>;
    };
</pre>
<p>
If you wish to use an alternative error reporting strategy, then define new classes that derive from <code>c_xml_reader</code> and <code>c_xml_writer</code> and define appropriate <code>user_handle_error</code> methods.


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='ConditionalErrorHandling'></a>
<h3>3.16.3&nbsp;-&nbsp;Conditional Error Handling</h3>
<p>
The error handling structure used by LMX allows you to conditionally ignore errors.  For example, if the XML being parsed has been human generated, then for certain errors you may wish to continue parsing and reporting errors after the first error has occurred.  This can be done by modifying the <code>c_xml_reader::user_handle_error(...)</code> and <code>c_xml_writer::user_handle_error(...)</code> methods to return <code>lmx::ELMX_OK</code> rather than the error that occurred.  As <code>c_xml_reader::user_handle_error(...)</code> and <code>c_xml_writer::user_handle_error(...)</code> are virtual methods an alternative strategy is to define classes that extend <code>c_xml_reader</code> and <code>c_xml_writer</code> and define appropriate <code>user_handle_error(...)</code> methods therein.
<p>
Note that care should be taken when adopting this strategy as it is not possible to proceed after certain errors have occurred (such as an unexpected end of message).  Hence it is recommended that your code explicitly defines the errors that are being ignored rather than having a default of ignoring all errors and defining those that are not ignored.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CollectingDebugErrorInformationwhenusingConvenienceMethods'></a>
<h3>3.16.4&nbsp;-&nbsp;Collecting Debug Error Information when using Convenience Methods</h3>
<p>
The convenience methods for unmarshaling and marshaling (See <a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a> and <a href='#Marshalingsimpleform'>2.4&nbsp;-&nbsp;Marshaling (simple form)</a>) are intentionally light-weight, and in their simplest form only return an error code when an error occurs.  <p>
However, to aid debugging, in Debug mode the global <code>debug_error</code> object, which has the type <code>s_debug_error</code>, is set with any information about the latest error.
<p>
If use of a global object for debugging is not suitable, then the convenience methods can also be called with an instance of <code>s_debug_error</code> that will be populated with any error information.
<p>
<code>s_debug_error</code> is declared in <code>lmxinternals.h</code> and has the following declaration:
<pre class='code'>
    <span class='ckw'>struct</span> s_debug_error
    {
        elmx_error error;
        std::string item_name;
        <span class='ckw'>const</span> <span class='ckw'>char</span> * p_prog_file;
        <span class='ckw'>int</span> prog_line;
        <span class='ckw'>int</span> xml_line;

        LMX_PDECL s_debug_error();
        LMX_PDECL <span class='ckw'>void</span> clear();
        LMX_PDECL <span class='ckw'>void</span> set(
                    elmx_error error_in,
                    <span class='ckw'>const</span> std::string & r_item_name_in,
                    <span class='ckw'>const</span> <span class='ckw'>char</span> * p_prog_file_in,
                    <span class='ckw'>int</span> prog_line_in,
                    <span class='ckw'>int</span> xml_line_in = -1 );
        LMX_PDECL <span class='ckw'>const</span> <span class='ckw'>char</span> * get_description() <span class='ckw'>const</span>;
        LMX_PDECL <span class='ckw'>const</span> <span class='ckw'>char</span> * get_description(
                    <span class='ckw'>const</span> s_custom_error_description * p_custom_descriptions ) <span class='ckw'>const</span>;
        LMX_PDECL std::string to_string() <span class='ckw'>const</span>;
        LMX_PDECL std::string to_string(
                    <span class='ckw'>const</span> s_custom_error_description * p_custom_descriptions ) <span class='ckw'>const</span>;
        LMX_PDECL std::ostream & to_stream( std::ostream & r_os_in ) <span class='ckw'>const</span>;
        LMX_PDECL std::ostream & to_stream(
                    std::ostream & r_os_in,
                    <span class='ckw'>const</span> s_custom_error_description * p_custom_descriptions ) <span class='ckw'>const</span>;
    };

    LMX_PDECL std::ostream & <span class='ckw'>operator</span> &lt;&lt; (
                    std::ostream &ar_os, 
                    <span class='ckw'>const</span> s_debug_error &ar_debug_error );

    LMX_PDECL <span class='ckw'>extern</span> s_debug_error debug_error;

    #define LMX_OUTPUT_DEBUG_ERROR( xstream ) ...
</pre>
<p>
The <code>to_string()</code> method returns the combined debug information as a suitable message in a string.
<p>
The <code>to_stream()</code> method outputs the combined debug information in a suitable message to the specified stream.
<p>
The variants with the <code>const s_custom_error_description *</code> parameter allow setting custom mappings of LMX error codes to descriptions.  This is intended specifically for the LMX error codes of the form <code>ELMX_USER_DEFINED_?</code>.
<p>
Mappings are specified by an array of <code>struct</code>s of the form:
<pre class='code'>
    <span class='ckw'>struct</span> s_custom_error_description
    {
        elmx_error      code;
        <span class='ckw'>const</span> <span class='ckw'>char</span> *    p_description;
    };
</pre>
For example:
<pre class='code'>
    lmx::s_custom_error_description custom_error_descriptions[] = {
            { lmx::ELMX_USER_DEFINED_1, "Out of range" },
            { lmx::ELMX_USER_DEFINED_2, "A must be present with B" },
            { lmx::ELMX_OK, LMXNULL }
            };
</pre>
<p>
Note the end of the array is identified by the entry <code>{ lmx::ELMX_OK, LMXNULL }</code>.
<p>
If you want to disable <code>debug_error</code> being used in your code during Debug mode, then arrange for the #define <code>LMX_DEBUG_CAPTURE_ERROR</code> to have the value <code>0</code>.  Conversely, if you want to force <code>debug_error</code> to be in your code, even in Release mode (but see below), then arrange for the #define <code>LMX_DEBUG_CAPTURE_ERROR</code> to have the value <code>1</code>.
<p>
In Debug mode, or when <code>LMX_DEBUG_CAPTURE_ERROR</code> is set to 1, the <code>LMX_OUTPUT_DEBUG_ERROR( xstream )</code> macro will output the error information to the stream <code>xstream</code>.  In Release mode and when <code>LMX_DEBUG_CAPTURE_ERROR</code> is not set to 1 the <code>LMX_OUTPUT_DEBUG_ERROR( xstream )</code> macro has no effect.
<p>
The output operator function allows code such as:
<pre class='code'>
    std::cout &lt;&lt; debug_error;
</pre>
<p>
To access other debug information just access the data members directly.
<p>
If additional flexibility is required for error reporting, it is suggested that the Advanced forms of marshaling and unmarshaling be used (See <a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a> and <a href='#Unmarshalingadvancedforms'>3.2&nbsp;-&nbsp;Unmarshaling (advanced forms)</a>).

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='DebuggingSupport'></a>
<h3>3.16.5&nbsp;-&nbsp;Debugging Support</h3>
<p>
The common error handling functions provided by LMX aid debugging support.  Setting a break point in the above-mentioned functions can facilitate detecting problems during parsing, writing or accessing the class members.  It is then a simple matter of tracing back through the stack to see why the error is being reported.
<p>
LMX also aids the development process when your code accesses the generated classes.  You can choose whether facet validation is done when you write data to a generated member functions by defining the compiler definition <code>LMX_USER_VALIDATE</code> in the <code>USER: CTRL_DEFS</code> section of the lmxuser.h file.  If this directive is defined, any such errors that occur will first be reported to the <code>lmx_error</code> function in lmxuser.h, and then optionally the return code of that function is returned to the caller.  Alternatively, an exception can be thrown, or an <code>assert</code> statement can be added to <code>lmx_error</code>.  This feature supports the 'fail fast' paradigm and allows errors to be detected close to where they occur.
<p>
LMX also generates functions called <code>is_occurs_ok()</code> and <code>check()</code> for each class.  These test whether the minimum cardinality requirements for the class have been satisfied.  They thus allow you to test whether you have set a sufficient number of the class members for the class to be valid.  They test the cardinality constraints for both elements and attributes.  One way to use these functions is in an <code>assert</code> statement once you have set all the appropriate members, e.g.:
<pre class='code'>
    c_NAME & name_ref = top.get_NAME();
    name_ref.set_CHILD( 12 );
    name_ref.set_CHILD2( 1.2 );

    assert( name_ref.is_occurs_ok() );
</pre>
See <a href='#RuntimeChecking'>2.5.15&nbsp;-&nbsp;Run-time Checking</a> for more information.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AddingExternalCharacterSetTranscoders'></a>
<h2>3.17&nbsp;-&nbsp;Adding External Character Set Transcoders</h2>
<p>
The LMX XML parser natively supports UTF-8, UTF-16 (BE & LE), UCS2 (BE & LE), ISO-8859-1 and US-ASCII.  If support for additional character sets is required, then these can be configured externally.
<p>
Examples of how to configure external transcoders are shown in the installed files <code>include/lmx-transcoder-example.h</code> and <code>src/lmx-transcoder-example.cpp</code>.
<p>
There are two interface classes used to support external transcoders:
<p>
A <code>const</code> instance of a class implementing the <code>lmx::c_external_transcoder_factory</code> interface is used to create instances of the classes that actually do the character transcoding.  When a new transcoder object is required LMX calls the interface's <code>get_transcoder( c_read & r_reader_in, c_error & r_error_in, c_get_as_utf8::e_encoding_mode initial_encoding_mode_in, const char * p_encoding_name_in )</code> method.  This should return a pointer to a transcoder object, or <code>NULL</code> if no suitable transcoder is found.  LMX will delete the returned transcoder object when it is no longer required.
<p>
The class implementing the <code>lmx::c_external_transcoder_factory</code> interface can be specified to LMX on a permanent basis using the static <code>c_xml_reader::set_default_external_transcoder_factory()</code> method or on a per-parsing session basis by calling the <code>set_external_transcoder_factory()</code> method on the relevant instance of the <code>c_xml_reader</code> class (or derivative thereof).
<p>
Each transcoder should implement the <code>lmx::c_external_transcoder</code> interface class and implement the <code>c_external_transcoder::s_result read()</code> method.  The <code>c_external_transcoder::s_result</code> object includes the character just read in the <code>c</code> member variable, and optionally a pointer to a NULL-terminated array of UTF-8 encoded bytes that LMX should read before asking the transcoder for new characters in the <code>mp_utf8_expansion</code> member variable.  If no such additional UTF-8 bytes are present then <code>s_result.mp_utf8_expansion</code> should be set to NULL.  If there is no input available then the transcoder class should return <code>c_read::k_eof</code> in <code>s_result.c</code>.  If an error occurs then this should be signaled to the <code>c_error</code> error class referenced by <code>r_error_in</code> and <code>c_read::k_eof</code> returned in <code>s_result.c</code>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AddingExtraNamespaceInformation'></a>
<h2>3.18&nbsp;-&nbsp;Adding Extra Namespace Information</h2>
<p>
When a document contains <code>xs:anyAttribute</code> or <code>xs:any</code>, it may be necessary to provide extra namespace information to the unmarshaling and marshaling operations.
<p>
If a section of xs:any XML has been extracted while unmarshaling it is possible that the start tag of the value part of the instance does not include appropriate namespace information.  Without suitable namespace information it is not possible to unmarshal its contents using another module of unmarshaling code.  To remedy this, <code>c_xml_reader</code> allows additional namespace information to be added to it prior to initiating unmarshaling. The functions that support this are:
<pre class='proto'>
    <span class='ckw'>void</span> c_xml_reader::add_namespace_mappings( <span class='ckw'>const</span> c_any_info & r_any_info );
    <span class='ckw'>void</span> c_xml_reader::add_namespace_mappings( <span class='ckw'>const</span> c_namespace_context & r_namespace_context );
    <span class='ckw'>void</span> c_xml_reader::add_namespace_mapping( <span class='ckw'>const</span> std::string & r_ns_prefix, <span class='ckw'>const</span> std::string & r_namespace );
    <span class='ckw'>void</span> c_xml_reader::add_default_namespace_mapping( <span class='ckw'>const</span> std::string & r_namespace );
</pre>
Where:
<dl>
<dt><code>r_ns_prefix</code></dt><dd>is the namespace prefix to be assigned to the namespace.</dd>
<p>
<dt><code>r_namespace</code></dt><dd>is the actual namespace URI, e.g. "http://codalogic.com/example".</dd>
<p>
</dl>
<code>add_default_namespace_mapping( namespace );</code> is effectively an alias for <code>add_namespace_mapping( "", namespace );</code>.
<p>
An example of adding extra namespace information is:
<pre class='code'>
        lmx::c_xml_reader l_reader( l_low_reader );
        l_reader.add_namespace_mapping( "alt", "http://codalogic.com/example" );
        c_MyElement l_item;
        lmx::elmx_error l_error = l_item.unmarshal( l_reader );
</pre>
<p>
Equally, when writing XML that contains <code>xs:anyAttribute</code> or <code>xs:any</code> additional namespace information may need to be added to the <code>c_xml_writer</code> class.  This is supported by the following methods:
<pre class='proto'>
	<span class='ckw'>void</span> c_xml_writer::add_namespace( <span class='ckw'>const</span> std::string & r_ns_prefix, <span class='ckw'>const</span> std::string & r_namespace );
	<span class='ckw'>void</span> c_xml_writer::add_default_namespace( <span class='ckw'>const</span> std::string & r_namespace );
</pre>
Where:
<dl>
<dt><code>ar_ns_prefix</code></dt><dd>is the namespace prefix to be assigned to the namespace.</dd>
<p>
<dt><code>ar_namespace</code></dt><dd>is the actual namespace URI, e.g. "http://codalogic.com/example".</dd>
<p>
</dl>
Again, <code>add_default_namespace( namespace );</code> is an alias for <code>add_namespace( "", namespace );</code>.
<p>
An example of their use is:
<pre class='code'>
    lmx::c_xml_writer l_writer( l_out_stream );
    l_writer.add_namespace( "alt", "http://codalogic.com/example" );
		    
    l_item.marshal( l_writer );
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AddingSchemaLocationInformation'></a>
<h2>3.19&nbsp;-&nbsp;Adding Schema Location Information</h2>
<p>
You can specify to the <code>c_xml_writer</code> class that you want schema location information to be output in the generated XML.  This will cause either the <code>xsi:schemaLocation</code> or <code>xsi:noNamespaceSchemaLocation</code> attributes to be output in the marshaled code.  This is done using the following methods:
<pre class='proto'>
    <span class='ckw'>void</span> c_xml_writer::add_schema_location( <span class='ckw'>const</span> std::string & r_ns_uri, <span class='ckw'>const</span> std::string & r_location );
    <span class='ckw'>void</span> c_xml_writer::add_no_namespace_schema_location( <span class='ckw'>const</span> std::string & r_location );
</pre>
Where:
<dl>
<dt><code>ar_ns_uri</code></dt><dd> is the namespace URI associated with the schema, e.g. "http://codalogic.com/example".</dd>
<p>
<dt><code>ar_location</code></dt><dd> is the location hint for the actual schema file, e.g. "http://codalogic.com/schemas/example.xsd".</dd>
<p>
</dl>
<code>add_schema_location()</code> specifies the location for a schema that has a namespace URI associated with it.  
<p>
<code>add_no_namespace_schema_location()</code> specifies the location of a schema that has no namespace associated with it.  
<p>
Multiple calls can be made to <code>add_schema_location()</code> to specify the locations of multiple schemas with namespaces.  
<p>
Only one call to <code>add_no_namespace_schema_location()</code> may be made.
<p>
If <code>add_schema_location()</code> is called, then <code>add_no_namespace_schema_location()</code> must not be called, and vice versa.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='DisablingOutputofXMLNamespaces'></a>
<h2>3.20&nbsp;-&nbsp;Disabling Output of XML Namespaces</h2>
<p>
When generating XML fragments that will be inserted by other means into other XML instances it may be appropriate to not have the generated XML include the <code>xmlns</code> namespace attributes.  This can be achieved by calling the <code>disable_ns_map_output()</code> method on an instance of a <code>c_xml_writer</code> object.  For example:
<pre class='code'>
    c_MyObject myObject;
    std::ostringstream sos;
    lmx::c_xml_writer writer( sos );
    writer.disable_ns_map_output();   <span class='ccom'>// N.B.</span>
    myObject.marshal( writer );
</pre>
This requires using the advanced forms of marshalling as described in <a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AddinganXMLDecltotheXMLoutput'></a>
<h2>3.21&nbsp;-&nbsp;Adding an XMLDecl to the XML output</h2>
<p>
By default when using the Convenience methods for marshalling (<a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a>), the XMLDecl is output (the part that looks like <code>&lt;?xml version="1.0"?&gt;</code>).  This can be configured on a global basis using the <code>c_xml_writer::set_convenience_options( t_writer_options )</code> and <code>c_xml_writer::get_convenience_options()</code> methods, where.
<code>t_writer_options</code> is defined as:
<pre class='proto'>
    <span class='ckw'>typedef</span> <span class='ckw'>int</span> t_writer_options;
    <span class='ckw'>static</span> <span class='ckw'>const</span> t_writer_options include_xml_decl;
    <span class='ckw'>static</span> <span class='ckw'>const</span> t_writer_options include_standalone;
</pre>
The <code>t_writer_options</code> can be combined by using the C++ OR operator (e.g. <code>include_xml_decl | include_standalone</code>).  An XMLDecl is output when the <code>include_xml_decl</code> option is included.  The standalone attribute can be included in the XMLDecl by specifying the <code>include_standalone</code> option.  Use of the <code>include_standalone</code> option implies <code>include_xml_decl</code>, and so it is not necessary to specify <code>include_xml_decl</code> when selecting the standalone attribute.  To disable output of an XMLDecl, use <code>set_convenience_options( 0 )</code>.
<p>
To enable instance by instance configuration of whether the XMLDecl is output it is recommended to use the advanced forms of marshalling (<a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a>) rather than the above methods.
<p>
By default <code>c_xml_writer</code> does not output the optional XMLDecl.
<p>
You can instruct <code>c_xml_writer</code> to output the XMLDecl by using the constructor that takes a <code>t_writer_options</code> argument.  This has the form:
<pre class='proto'>
    c_xml_writer( std::ostream &ar_os,
                  t_writer_options a_options,
                  <span class='ckw'>const</span> <span class='ckw'>char</span> *ap_tab = "\t",
                  <span class='ckw'>const</span> <span class='ckw'>char</span> *ap_nl = "\n" );
</pre>
Thus an example of how to construct an instance of <code>c_xml_writer</code> that outputs the XMLDecl is:
<pre class='code'>
    lmx::c_xml_writer l_writer( l_out_stream, 
                                lmx::c_xml_writer::include_xml_decl );
</pre>
An example of selecting an XMLDecl that contains the standalone attribute is:
<pre class='code'>
    lmx::c_xml_writer l_writer( l_out_stream, 
                                lmx::c_xml_writer::include_standalone );
</pre>


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='HandlingMultipleSchemas'></a>
<h2>3.22&nbsp;-&nbsp;Handling Multiple Schemas</h2>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='HandlingMultipleIndependentSchemas'></a>
<h3>3.22.1&nbsp;-&nbsp;Handling Multiple Independent Schemas</h3>
<p>
If your project includes multiple independent schemas (or independent sets of schema) then we recommend generating the code for each independent schema set separately and instructing LMX to generate the code into separate C++ namespaces using the <code>-cns YYY</code> flag or via the WinLMX "Generated Code C++ Namespace" group box on the "C++ Names & Namespaces" tab.  For example, if you have schemas <code>s1.xsd</code> and <code>s2.xsd</code> you could run LMX and instruct it to generate code for <code>s1.xsd</code> into C++ namespace <code>s1</code> (using  <code>-cns s1</code>) and then run LMX again and instruct it to generate code for <code>s2.xsd</code> into the <code>s2</code> C++ namespace (using  <code>-cns s2</code>).  In your C++ files that #include the generated code you can use statements such as "<code>using namespace s1;</code>" and "<code>using namespace s2;</code>" to avoid qualifying each use of a variable with a namespace prefix.
<p>
While the above is our recommended method for handling this situation, if it is not acceptable in your environment, you can use the <code>-prefix-declash YYY</code> flag to avoid name clashes when you come to link your generated files.  In this scenario you could use <code>-prefix-declash s1_</code> when generating code for <code>s1.xsd</code> and <code>-prefix-declash s2_</code> when generating code for <code>s2.xsd</code>.


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='MultipleSchemasthatShareCommonSchemas'></a>
<h3>3.22.2&nbsp;-&nbsp;Multiple Schemas that Share Common Schemas</h3>
<p>
A common scenario is when two or more schemas share one of more common imported or included schemas.  In this case problems occur if the schemas are compiled separately due to duplicate code being generated.  
<p>
To address this problem, all schemas that share common schemas should have code generated for them in a single LMX compilation operation.  As an example, assume that <code>schema1.xsd</code> and <code>schema2.xsd</code> both share definitions from <code>common.xsd</code>.  Rather than compiling <code>schema1.xsd</code> and <code>schema2.xsd</code> separately, <code>schema1.xsd</code> and <code>schema2.xsd</code> should be compiled together.  Using the command-line interface, this can be done using a DOS command-line such as:
<pre style='cmd'>
    lmx  schema1.xsd  ++  schema2.xsd  +  common.xsd  outbase
</pre>
Or a Linux command-line such as:
<pre style='cmd'>
    linmx  schema1.xsd  ++  schema2.xsd  +  common.xsd  outbase
</pre>
From <a href='#CodeGenerationUsingtheWindowsDOSCommandLineVersion'>2.1.2&nbsp;-&nbsp;Code Generation Using the Windows (DOS) Command Line Version</a> it can be seen that the <code>+</code> sign informs LMX of a schema file that contains additional definitions that need to be imported.  However, global elements in such a schema file are not treated as possible root elements for the XML instances.  The <code>++</code> sign similarly informs LMX of a schema file that contains additional definitions, but in this case the global elements are considered to be possible root elements for a valid XML instance.  Hence, specifying <code>++ schema2.xsd</code> on the command-line will ensure that the global elements in <code>schema2.xsd</code> will be treated as valid XML instance root elements, giving the desired effect.
<p>
The same results can be achieved using WinLMX.  In this case, on the <code>Schema Files</code> tab, enter <code>schema1.xsd</code> in the <code>Base Schema File</code> edit box.  Enter <code>schema2.xsd</code> and <code>common.xsd</code> in the <code>Additional Imported Schema Files</code> section using the relevant <code>Add...</code> button.  Then select 
<code>schema2.xsd</code> in the listview and press the <code>Edit...</code> button.  In the dialog box that appears, check the <code>Treat as Global Schema</code> checkbox and press <code>OK</code>.  When the dialog box closes a small globe symbol will be shown next to <code>schema2.xsd</code>'s name.  This signifies that global elements in the schema will be treated as valid root elements in XML instances.  Compile as usual.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='PatternFacetHandlingCustomization'></a>
<h2>3.23&nbsp;-&nbsp;Pattern Facet Handling Customization</h2>
<p>
LMX includes a default regular expression library for pattern facet validation (which is built into the binaries).
<p>
You can disable testing pattern facets by arranging for the <code>#define LMX_VALIDATE_PATTERNS</code> to be set to <code>0</code>.  In this case all input strings will be considered to be valid against their schema patterns.
<p>
LMX also allows you to specify an alternative pattern-matching library.  This is configured by setting the <code>tc_pattern</code> <code>typedef</code> in lmxuser.h.  Simply modify the <code>typedef</code> statement so that your pattern-matching class is used instead of the default supplied with LMX.  Your pattern-matching class must include as a minimum the following public interfaces:
<pre class='code'>
    <span class='ckw'>class</span> c_my_pattern_class
    {
    <span class='ckw'>public</span>:
        c_my_pattern_class( <span class='ckw'>const</span> <span class='ckw'>char</span> *ap_pattern );
        <span class='ckw'>bool</span> is_match( <span class='ckw'>const</span> std::string &ar_v ) <span class='ckw'>const</span>;
        <span class='ckw'>bool</span> is_match( <span class='ckw'>const</span> std::wstring &ar_v ) <span class='ckw'>const</span>;
    };
</pre>
In both cases the function <code>is_match()</code> should return <code>true</code> if the string in <code>ar_v</code> matches the pattern specified by <code>ap_pattern</code> when the class was constructed, and <code>false</code> otherwise.  The pattern specified by <code>ap_pattern</code> is UTF-8 encoded.
<p>
Note that the <code>is_match( const std::wstring &ar_v )</code> variant is used for facet testing when you set data using the generated classes accessor methods.  If you do not use facet testing in this phase (see <code>LMX_USER_VALIDATE</code> in <a href='#DebuggingSupport'>3.16.5&nbsp;-&nbsp;Debugging Support</a>), then you don't need to implement this member.  Alternatively, if you use accessor side facet testing, but don't want to test pattern facets, you can arrange for this function to always return <code>true</code>.
<p>
A simple approach to implementing the <code>is_match( const std::wstring &ar_v )</code> method is to use LMX's <code>convert()</code> functions to convert the wide string to a narrow string and then call <code>is_match( const std::string &ar_v )</code>.
<p>
If you only have simple pattern facets and you don't want a full regular expression engine in your application (perhaps due to platform constraints), then one approach is to define a class that, based on the string that is passed to it in its constructor (specifying the desired pattern), sets a pointer to a function that will test for matches against that pattern.  The class will then call the function pointed to by the pointer when a test is required.  The code below demonstrates such an example:

<pre class='code'>
    #include &lt;cassert>
    #include &lt;cstdlib>
    #include &lt;iostream>

    <span class='ccom'>// Utility functions called by the match functions</span>
    <span class='ccom'>// (Note: C++'s isdigit() and isupper() are not so good on 8-bit chars...)</span>

    <span class='ccom'>// N.B. A reference to the pointer is passed in so the pointer is updated</span>
    <span class='ccom'>// in the calling function</span>
    size_t scan_digits( <span class='ckw'>const</span> <span class='ckw'>char</span> * & arp_string )
    {
        size_t l_size;
        <span class='ckw'>for</span>( l_size = 0; *arp_string >= '0' && *arp_string &lt;= '9'; ++l_size )
            ++arp_string;
        <span class='ckw'>return</span> l_size;
    }

    size_t scan_upper_letters( <span class='ckw'>const</span> <span class='ckw'>char</span> * & arp_string )
    {
        size_t l_size;
        <span class='ckw'>for</span>( l_size = 0; *arp_string >= 'A' && *arp_string &lt;= 'Z'; ++l_size )
            ++arp_string;
        <span class='ckw'>return</span> l_size;
    }

    size_t scan_range( <span class='ckw'>const</span> <span class='ckw'>char</span> * & arp_string, 
                        size_t (*pf_test)( <span class='ckw'>const</span> <span class='ckw'>char</span> * & arp_string ), 
                        size_t a_min, 
                        size_t a_max=~0 )
    {
        size_t l_n_matches = pf_test( arp_string );
        <span class='ckw'>if</span>( l_n_matches >= a_min && l_n_matches &lt;= a_max )
            <span class='ckw'>return</span> true;
        <span class='ckw'>return</span> false;
    }

    <span class='ccom'>// The functions implementing the matches we want</span>

    <span class='ckw'>bool</span> is_ip_address( <span class='ckw'>const</span> std::string &ar_v )
    {
        <span class='ckw'>const</span> <span class='ckw'>char</span> *lp_v = ar_v.c_str();
        <span class='ckw'>for</span>( size_t l_i=0; l_i&lt;3; ++ l_i )
            {
            <span class='ckw'>if</span>( ! scan_range( lp_v, scan_digits, 1, 3 ) ||
                    *lp_v++ != '.' )
                <span class='ckw'>return</span> false;
            }
        <span class='ckw'>if</span>( ! scan_range( lp_v, scan_digits, 1, 3 ) ||
                *lp_v != '\0' )
            <span class='ckw'>return</span> false;
        <span class='ckw'>return</span> true;
    }

    <span class='ckw'>bool</span> is_sku( <span class='ckw'>const</span> std::string &ar_v )
    {
        <span class='ckw'>const</span> <span class='ckw'>char</span> *lp_v = ar_v.c_str();
        <span class='ckw'>if</span>( scan_range( lp_v, scan_upper_letters, 3, 3 ) &&
                *lp_v++ == '-' &&
                scan_range( lp_v, scan_digits, 2, 2 ) &&
                *lp_v == '\0' )
            <span class='ckw'>return</span> true;
        <span class='ckw'>return</span> false;
    }

    <span class='ccom'>// The actual class doing the matching</span>
    <span class='ckw'>class</span> c_my_simple_patterns
    {
    <span class='ckw'>private</span>:
        <span class='ccom'>// Pointer to function that will do the match</span>
        <span class='ckw'>bool</span> (*pf_matcher)( <span class='ckw'>const</span> std::string &ar_v );

    <span class='ckw'>public</span>:
        c_my_simple_patterns( <span class='ckw'>const</span> <span class='ckw'>char</span> *ap_pattern ) : pf_matcher( 0 )
        {
            <span class='ccom'>// Select the right match function based on the input pattern</span>
            <span class='ckw'>if</span>( strcmp( ap_pattern, "([0-9]{1,3}\\.){3}[0-9]{1,3}" ) == 0 )
                pf_matcher = &is_ip_address;
                
            <span class='ckw'>else</span> <span class='ckw'>if</span>( strcmp( ap_pattern, "[A-Z]{3}-[0-9]{2}" ) == 0 )
                pf_matcher = &is_sku;
                
            <span class='ckw'>else</span>
                assert( 0 );
        }
        <span class='ckw'>bool</span> is_match( <span class='ckw'>const</span> std::string &ar_v ) <span class='ckw'>const</span>
        {
            <span class='ccom'>// Just call the right match function</span>
            <span class='ckw'>if</span>( pf_matcher )
                <span class='ckw'>return</span> pf_matcher( ar_v );
            <span class='ckw'>return</span> false;
        }
        <span class='ckw'>bool</span> is_match( <span class='ckw'>const</span> std::wstring &ar_v ) <span class='ckw'>const</span>
        {
            std::string l_narrow_string;
            <span class='ccom'>//lmx::convert( &l_narrow_string, ar_v ); // Include lmxuser.h for this</span>
            <span class='ckw'>return</span> is_match( l_narrow_string );
        }
    };

    <span class='ccom'>// main() function demonstrating usage</span>
    <span class='ccom'>// (Note that LMX usually generates all the code to generate the match class </span>
    <span class='ccom'>// instances and invoke the tests.)</span>
    <span class='ckw'>int</span> main(int argc, <span class='ckw'>char</span>* argv[])
    {
        c_my_simple_patterns l_ip_addr( "([0-9]{1,3}\\.){3}[0-9]{1,3}" );
        std::cout &lt;&lt; "Is IP 10.0.0.1 (true): " &lt;&lt; 
                     l_ip_addr.is_match( "10.0.0.1" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is IP 1000.0.0.1 (false): " &lt;&lt; 
                     l_ip_addr.is_match( "1000.0.0.1" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is IP 10.0.0.1.0 (false): " &lt;&lt; 
                     l_ip_addr.is_match( "10.0.0.1.0" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is IP 10.0.0. (false): " &lt;&lt; 
                     l_ip_addr.is_match( "10.0.0." ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is IP 10.0.0 (false): " &lt;&lt; 
                     l_ip_addr.is_match( "10.0.0" ) &lt;&lt; "\n";
        
        c_my_simple_patterns l_sku( "[A-Z]{3}-[0-9]{2}" );
        std::cout &lt;&lt; "Is SKU ABC-12 (true): " &lt;&lt; 
                     l_sku.is_match( "ABC-12" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is SKU ABCD-12 (false): " &lt;&lt; 
                     l_sku.is_match( "ABCD-12" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is SKU ABC-12A (false): " &lt;&lt; 
                     l_sku.is_match( "ABC-12A" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is SKU ABC.12 (false): " &lt;&lt; 
                     l_sku.is_match( "ABC.12" ) &lt;&lt; "\n";
        std::cout &lt;&lt; "Is SKU 1AB-12 (false): " &lt;&lt; 
                     l_sku.is_match( "1AB-12" ) &lt;&lt; "\n";
        
        <span class='ckw'>return</span> 0;
    }

</pre>

</skip>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='CustomPatternFacetOutputFormatting'></a>
<h2>3.24&nbsp;-&nbsp;Custom Pattern Facet Output Formatting</h2>
<p>
Occasionally an <code>xs:pattern</code> facet implies XML formatting of a data type that differs from the default representation.  For example, an integer type may require leading zeros.
<p>
To accommodate this you can use the <code>-pattern-out</code> flag.  The format of this flag is <code>-pattern-out PATTERN FUNCTION</code>, where <code>PATTERN</code> is the <code>xs:pattern</code> specified in the schema and <code>FUNCTION</code> is the name of the function you have specified to output the type correctly.
<p>
If the data type has multiple <code>xs:pattern</code>s specified for it then all the <code>xs:pattern</code> values should be concatenated together using the <code>|</code> character as a separator into one pattern string to form the flag's <code>PATTERN</code> argument.  This may require quotes to be used on the command-line.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='XMLOutputFormatCustomization'></a>
<h2>3.25&nbsp;-&nbsp;XML Output Format Customization</h2>
<p>
LMX allows you to control the format of the generated XML.  Currently you can control the character(s) used at the end of a 'line', and the character(s) used for indenting.  This capability allows you to control whether you want the most compact XML format, or a format that is more attractive and readable when displayed in a viewer/editor.
<p>
The format can be controlled at compile-time, globally at run-time and per-unmarshalling process at run-time.
<p>
The default format can be defined at compile-time in the <code>USER: XML_WRITER_FORMAT</code> section of <code>lmxuser.h</code> by setting the <code>LMX_WRITER_DEFAULT_TAB</code>, <code>LMX_WRITER_DEFAULT_NL</code>, <code>LMX_WRITER_DEFAULT_ATTRIBUTE_TAB</code> and <code>LMX_WRITER_DEFAULT_ATTRIBUTE_NL</code> #defines to appropriate values.  
<p>
<code>LMX_WRITER_DEFAULT_TAB</code> and <code>LMX_WRITER_DEFAULT_NL</code> control the formatting of elements and <code>LMX_WRITER_DEFAULT_ATTRIBUTE_TAB</code> and <code>LMX_WRITER_DEFAULT_ATTRIBUTE_NL</code> control the formatting of attributes.
<p>
If not explicitly set, the values of <code>LMX_WRITER_DEFAULT_TAB</code> and <code>LMX_WRITER_DEFAULT_NL</code> are defaulted to <code>"\t"</code> and <code>"\n"</code> respectively.
<p>
If not explicitly set, the values of <code>LMX_WRITER_DEFAULT_ATTRIBUTE_TAB</code> and <code>LMX_WRITER_DEFAULT_ATTRIBUTE_NL</code> are defaulted to the values of <code>LMX_WRITER_DEFAULT_TAB</code> and <code>LMX_WRITER_DEFAULT_NL</code> respectively.
<p>
Setting all values to <code>""</code> will result in the smallest XML.  Setting <code>LMX_WRITER_DEFAULT_TAB</code> to <code>"  "</code> and <code>LMX_WRITER_DEFAULT_NL</code> to <code>"\n"</code> will result in shallower nesting.
<p><code></code>
The default format can be defined at run-time using the <code>c_xml_writer</code> static methods <code>c_xml_writer::set_default_tab( const std::string & ar_default_tab )</code>, <code>c_xml_writer::set_default_nl( const std::string & ar_default_nl )</code>, <code>c_xml_writer::set_default_attribute_tab( const std::string & ar_default_ attribute_tab )</code> and <code>c_xml_writer::set_default_attribute_nl( const std::string & ar_default_ attribute_nl )</code> methods.  
<p>
<code>set_default_attribute_tab()</code> and <code>set_default_attribute_nl()</code> control the default formatting of attributes.  For backwards compatibility reasons, if the element and attribute formatting characters are the same when <code>set_default_tab()</code> and <code>set_default_nl()</code> are called, they will alter both the element and attribute formatting characters.  Conversely, if the element and attribute formatting characters are different at the time the methods are called then they will only change the respective element formatting characters.  For this reason it may be appropriate to ensure that <code>set_default_tab()</code> and <code>set_default_nl()</code> are called prior to <code>set_default_attribute_tab()</code> and <code>set_default_attribute_nl()</code> if independent formatting is required.
<p>
If you do not wish to allow these two methods to be effective then you can set the define <code>LMX_WRITER_LOCK_FORMAT</code> to <code>1</code>.
<p>
The formatting is controlled per-unmarshalling process via the constructor of the <code>c_xml_writer</code> class.  This mechanism overrides the defaults set by the above methods.  The prototype for this is:
<pre class='proto'>
      c_xml_writer( std::ostream & ar_os,
                    <span class='ckw'>const</span> <span class='ckw'>char</span> * ap_tab = LMXNULL, 
                    <span class='ckw'>const</span> <span class='ckw'>char</span> * ap_nl = LMXNULL,
                    <span class='ckw'>const</span> <span class='ckw'>char</span> * ap_attribute_tab = LMXNULL, 
                    <span class='ckw'>const</span> <span class='ckw'>char</span> * ap_attribute_nl = LMXNULL );
</pre>
The format is specified by setting <code>ap_tab</code>, <code>ap_nl</code> <code>ap_attribute_tab</code> and <code>ap_attribute_nl</code> to point to suitable character strings.
<p>
If <code>ap_attribute_tab</code> is absent, then, if present, the value of <code>ap_tab</code> is used to control attribute formatting.  If <code>ap_tab</code> is absent, then the default attribute formatting character sequence is used.
<p>
Similarly, if <code>ap_attribute_nl</code> is absent, then, if present, the value of <code>ap_nl</code> is used to control attribute formatting.  If <code>ap_nl</code> is absent, then the default attribute formatting character sequence is used.
<p>
As above, for the most compact representation, you may wish to construct the writer using the arguments:
<pre class='code'>
      c_xml_writer l_writer( os, "", "" );
</pre>
If the tab character nests the XML output too deeply, you might wish to choose the following form:
<pre class='code'>
      c_xml_writer l_writer( os, "  ", "\n" );
</pre>
Note that not all character combinations used in the constructor will result in legal XML being generated.
<p>
To make use of per-unmarshalling process formatting feature you will need to use the advanced forms of unmarshalling as described in <a href='#Marshalingadvancedforms'>3.5&nbsp;-&nbsp;Marshaling (advanced forms)</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SpecifyingMicroFormats'></a>
<h2>3.26&nbsp;-&nbsp;Specifying Micro Formats</h2>
<p>
A micro format is a simple type that has multiple values encoded into a single string.  XML Schema's xs:dateTime family of types are micro formats, encoding multiple integer types such as the year, date of month and hour into a single string.  You might choose to define a GPS coordinate or complex number (with real and imaginary parts) as a micro format.
<p>
You can tell LMX to treat a simpleType xs:string as a micro format using the -micro-format flag.  This has the form:
<ul>
<code>-micro-format PATH  CLASS</code>
</ul>
Here, <code>PATH</code> specifies the item(s) in the schema to which the micro format applies.  It has the format:
<ul>
<code>/? (&lt;name>/)* &lt;name></code>
</ul>
Note that only type specifications, either as an independently defined simpleType or a simpleType definition embedded in an element definition, can be assigned a micro format.  An element that links to a separately defined simpleType can not have a micro format specification that is independent of the simpleType to which it links.
<p>
<code>CLASS</code> is the fully C++ namespace-qualified name of the C++ class used to represent the micro format.
<p>
An example micro format specification might be:
<ul>
<code>-micro-format position  c_gps_coordinate</code>
</ul>
By default, it is assumed that the class that represents the micro format has a static method of the form:
<pre class='proto'>
      <span class='ckw'>static</span> <span class='ckw'>bool</span> is_valid( <span class='ckw'>const</span> std::string & ar_v );
</pre>
This will be used to test whether received XML values conform to the micro format.  If such a method does not exist then you should specify a template specialization for the lmx::s_is_valid< T > template class located in the <code>MICRO_FORMAT_VALIDATORS</code> section of <code>lmxuser.h</code> to do this; for example:
<pre class='code'>
     <span class='ckw'>template</span>&lt;>
     <span class='ckw'>struct</span> s_is_valid&lt; c_gps_coordinate >
     {
         <span class='ckw'>static</span> <span class='ckw'>bool</span> is_valid( <span class='ckw'>const</span> std::string & ar_v )
             { <span class='ckw'>return</span> ...; }
     };
</pre>
You may wish to specify this in a separate <code>.h</code> file in which case you can use the <code>-include-h</code> flag to specify the file.
<p>
It is also assumed by default that that the micro format class has an assignment operator (<code>operator =</code>) that takes a <code>const std::string</code> reference to convert the XML input into the object, and an output stream operator (<code>operator &lt;&lt;</code> or non-class equivalent) that will generate appropriate XML.  If this is not the case then see <a href='#InputOutputConverters'>3.13.1.2&nbsp;-&nbsp;Input/Output Converters</a>.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='AllowingUnknownItemsinanXMLInstance'></a>
<h2>3.27&nbsp;-&nbsp;Allowing Unknown Items in an XML Instance</h2>
<p>
A commonly requested feature is to allow auto-versioning of XML schemas.  This allows code generated using older versions of an XML schema to accept XML instances that contain attributes and elements specified in a newer version of an XML schema, without generating errors.  This enables the XML format to be extended, or versioned, over time as a product�s feature set grows, in a simple and effective way.
<p>
LMX can generate code using two modes of versioning:
<p>
The first mode is enabled using the <code>-autover</code> flag.  This will ignore any unknown attributes.  In the case of an <code>xs:sequence</code> construct it will ignore any unknown child elements appended to the end of a sequence of elements.  However, it will not ignore unknown elements positioned within the known set of elements.  In the case of an <code>xs:choice</code> construct, an unknown element is allowed (and ignored) in place of the elements specified in the original XML schema.
<p>
The second mode is enabled using the <code>-autover2</code> flag (and is accessible in the GUI interfaces under the <code>Advanced -> Non-Standard Features...</code> menu option).  This mode enhances the first mode by removing the restriction that the unknown elements must be located at the end of an <code>xs:sequence</code> construct, so that any unknown child element within an <code>xs:sequence</code> construct will be ignored.  Its behavior when handling attributes and <code>xs:choice</code> constructs is the same as for the first mode.
<p>
To enable the code to be selective about which attributes and elements it ignores, the <code>c_xml_reader</code> class has the following two virtual functions, which are called when an unknown attribute or element is found when one of the auto-versioning modes is enabled:
<pre class='proto'>
    virtual elmx_error user_found_unknown_attribute(
                           <span class='ckw'>const</span> std::string & r_attribute_name_in,
                           <span class='ckw'>const</span> c_string_stack & r_element_name_stack_in,
                           <span class='ckw'>const</span> <span class='ckw'>char</span> * p_prog_file_in,
                           <span class='ckw'>int</span> prog_line_in )
</pre>
and:
<pre class='proto'>
    virtual elmx_error user_found_unknown_element(
                           <span class='ckw'>const</span> std::string & r_element_name_in,
                           <span class='ckw'>const</span> c_string_stack & r_element_name_stack_in,
                           <span class='ckw'>const</span> <span class='ckw'>char</span> * p_prog_file_in,
                           <span class='ckw'>int</span> prog_line_in )
</pre>
Where:
<dl>
<dt><code>r_attribute_name_in</code></dt><dd>The name of the unknown attribute, including namespace prefix.</dd>
<p>
<dt><code>r_element_name_in</code></dt><dd>The name of the unknown element, including namespace prefix.</dd>
<p>
<dt><code>r_element_name_stack_in</code></dt><dd>Reference to a class that contains the name of the element in which the unknown attribute or element is located.  To convert this into a string like "/foo/bar", do: <code>r_element_name_stack_in.to_string()</code>.</dd>
<p>
<dt><code>p_prog_file_in</code></dt><dd>The name of the C++ program file associated with the unknown attribute or element.</dd>
<p>
<dt><code>prog_line_in</code></dt><dd>The line number within the C++ program file associated with the unknown attribute or element.</dd>
<p>
</dl>
Parsing will continue if <code>ELMX_OK</code> is returned, and terminate (yielding the specified error code) if any other error code is returned.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='mustUnderstandComprehensionRequired'></a>
<h2>3.28&nbsp;-&nbsp;mustUnderstand / Comprehension Required</h2>
<p>
Some specifications allow extensions to specify that they must be understood, or the XML instance should not be parsed.  There are a number of ways to do this.  One way is to include an attribute in the extension indicating that such comprehension is required.  SOAP takes this approach.  To accommodate this approach, LMX provides the <code>has_must_understand</code> function.  The prototype for this function is:
<pre class='proto'>
    elmx_must_understand has_must_understand( c_xml_reader & ar_reader,
               <span class='ckw'>const</span> std::string &ar_must_understand_namespace, 
               <span class='ckw'>const</span> std::string &ar_must_understand_name,
               t_must_understand_test_function a_function = bool_must_understand );
</pre>
The return code for the function is of the type:-
<pre class='proto'>
    <span class='ckw'>enum</span> elmx_must_understand { EMU_OK, EMU_ERROR, EMU_MUST_UNDERSTAND };
</pre>
Where:-
<dl>
<dt>EMU_OK</dt><dd>indicates that a must understand attribute was not found, and no errors were encountered</dd>
<p>
<dt>EMU_ERROR</dt><dd>indicates that an error was encountered during parsing</dd>
<p>
<dt>EMU_MUST_UNDERSTAND</dt><dd>indicates that an attribute specifying that understanding is required was found.</dd>
<p>
</dl>
The parameters to <code>has_must_understand</code> have the following meaning:-
<dl>
<dt>ar_reader</dt><dd>is a low level reader object as used in <a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a></dd>
<p>
<dt>ar_must_understand_namespace</dt><dd>is the namespace of the attribute specifying must understand</dd>
<p>
<dt>ar_must_understand_name</dt><dd>is the local name of the attribute specifying must understand</dd>
<p>
<dt>a_function</dt><dd>is an optional pointer to a function that indicates whether the attribute value specifies that comprehension is required or not.  If this parameter is not present, then it is assumed that the attribute value is of type xs:boolean.  The prototype for this function is: <p><ul>elmx_must_understand &lt;must understand function name>( const std::string & ar_value );</ul><p>  It should return <code>EMU_MUST_UNDERSTAND</code> if the extension must be understood and <code>EMU_OK</code> otherwise.</dd>
<p>
</dl>
An example for SOAP might be:-
<pre class='code'>
    <span class='ckw'>if</span>( has_must_understand( reader,
               "http://www.w3.org/2002/12/soap-envelope", 
               "mustUnderstand" ) == EMU_OK )
        <span class='ccom'>// Process the block</span>
</pre>
Note that it is very important to call the <code>has_must_understand()</code> function at the correct place during XML instance processing, otherwise undesired results will occur.  The blocks that contain <code>mustUnderstand()</code> attributes are expected to occur as part of <code>xs:any</code> elements contained in an instance.  If information about an instance fragment contained in <code>xs:any</code> is understood, then it should be parsed without calling <code>has_must_understand()</code>, even if it has further <code>xs:any</code> elements that may not be understood.  When a fragment from an <code>xs:any</code> element is found which is not understood, then <code>has_must_understand()</code> can be called to determine whether it must be understood.  If it must be understood, then the whole XML instance must be discarded, otherwise the fragment can be ignored and processing can continue.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='FindinganXMLInstancesNamespace'></a>
<h2>3.29&nbsp;-&nbsp;Finding an XML Instance's Namespace</h2>
<p>
If your code must interpret XML instances from multiple schemas, you may wish to find the namespace of the root element of the XML instance in order to determine which parser needs to be used to unmarshal the instance.  LMX provides the <code>get_instance_namespace</code> function for this purpose.  The function has the following prototype:-
<pre class='proto'>
    <span class='ckw'>bool</span> get_instance_namespace( c_xml_reader & ar_reader, std::string *ap_namespace_out );
</pre>
Where:
<dl>
<dt>ar_reader</dt><dd>is a low level reader object created as in the unmarshaling examples above (see <a href='#Unmarshalingsimpleform'>2.3&nbsp;-&nbsp;Unmarshaling (simple form)</a>)</dd>
<p>
<dt>ap_namespace_out</dt><dd>is a pointer to a string where the namespace is to be placed if it is found.</dd>
<p>
</dl>
The function returns <code>true</code> if the namespace is found, and <code>false</code> otherwise.
<p>
For example:-
<pre class='code'>
    std::string instance_namespace;
    <span class='ckw'>if</span>( lmx::get_instance_namespace( reader, &instance_namespace ) )
    {
        std::cout &lt;&lt; "The instance namespace is: " &lt;&lt; instance_namespace &lt;&lt; "\n";
    }
</pre>

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='SettingaDecimalValueWithaFloat'></a>
<h2>3.30&nbsp;-&nbsp;Setting a Decimal Value With a Float</h2>
<p>
C++ provides no native support for the XML schema <code>xs:decimal</code> type.  A convenient way to interface with such values is via C++ float values (although note that rounding errors may cause undesirable results in some situations).  The LMX <code>c_decimal</code> class provides methods to read decimal values as floats.  However, using a float to set a <code>c_decimal</code> type may require knowledge of the fraction digits facet which an instance of <code>c_decimal</code> will not have.  To allow setting a <code>c_decimal</code> value with a fraction digits facet via a float LMX generates an extra function in this case of the form:-
<pre class='proto'>
    set_NAME( <span class='ckw'>double</span> in );
</pre>
As such a method may not be required in all builds, the code for this is generated in a conditionally compiled block.  The code is included in the compilation if the #define:
<pre class='proto'>
    LMX_WANT_DECIMAL_FLOAT_SET
</pre> 
is set to 1 in the <code>USER: CTRL_DEFS</code> section of <code>lmxuser.h</code> (the default case) and excluded otherwise.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='TestFrameworkGeneration'></a>
<h2>3.31&nbsp;-&nbsp;Test Framework Generation</h2>
<p>
To help with evaluation and testing, LMX can generate a separate .cpp file containing code to exercise the generated marshaling and unmarshaling code and a <code>main</code> function.  The name of this file is <code>&lt;output root>-main.cpp</code>.  The generated test code unmarshals to objects a specified XML instance from a file, assigns the object to a new object (using both assignment and construction) and then marshals the result back out to a named file.  If run under Windows, the test code will also check for memory leaks that occur during the test process - there should be none though.  You can then compare the two files to check that the round tripping has been successful.  For XML instances that do not use multiple namespaces or entity substitutions, the <code>xmlcomp.exe</code> program supplied in the evaluation support suite can be used to automate the comparison.

<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='StrategiesforIncreasingCodeFlexibility'></a>
<h2>3.32&nbsp;-&nbsp;Strategies for Increasing Code Flexibility</h2>
<p>
One aspect of using LMX generated code is that the code you write can end up being very sensitive to changes in the re-generated code after making small changes to a schema.  This section describes some ways to write code that is more flexible.
<p>
One option is to generate code using the <code>-no-nested-classes</code> flag.  If a schema has nested complex types, this effectively flattens it out.  So rather than ending up with classes like:
<pre class='code'>
    <span class='ckw'>class</span> c_foo {
        <span class='ckw'>class</span> c_bar {
            <span class='ckw'>class</span> c_baz {};
    }; };
</pre>

you end up with classes like:
<pre class='code'>
    <span class='ckw'>class</span> c_baz {};
    <span class='ckw'>class</span> c_bar {};
    <span class='ckw'>class</span> c_foo {};
</pre>

This avoids naming types such as <code>c_foo::c_bar::c_baz</code>.
<p>
Avoiding long chains of accessors also helps.  Instead, first taking a pointer to a type at the end of a long chain of accessors makes the code easier to maintain.  So instead of:
<pre class='code'>
    item.get_foo().get_bar().get_baz( 0 );
    item.get_foo().get_bar().get_baz( 1 );
</pre>

do:
<pre class='code'>
    c_bar * p_bar = &item.get_foo().get_bar();
    p_bar->get_baz( 0 );
    p_bar->get_baz( 1 );
</pre>

Even better is to put the 'baz' code in a separate function, e.g.:
<pre class='code'>
    handle_baz( item.get_foo().get_bar() );
</pre>

Making handle_baz() a template can make the code even more generic.  For example:
<pre class='code'>
    <span class='ckw'>template</span>&lt; <span class='ckw'>class</span> T >
    <span class='ckw'>void</span> handle_baz( T * p_t )
    {
        p_t->get_baz( 0 );
        p_t->get_baz( 1 );
    }
</pre>

Then it doesn't matter what type handle_baz() is called with.


<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='LMXExtensions'></a>
<h2>3.33&nbsp;-&nbsp;LMX Extensions</h2>
<p>
LMX supports some additional built-in data types.  These types are defined in the namespace <code>http://codalogic.com/xsdtypes</code>.  Note that use of these additional built-in types is suitable for internal proprietary schema, but is not recommended for schema that are made public.
<p>
The type <code>asciiString</code> defines a string that consists only of ASCII characters, and by default is mapped to std::string.  The existence of this type allows easy co-existence of Unicode and ASCII values using a more natural representation in C++ code.  An example of how to define the type is:
<pre class='schema'>
    &lt;<span class='xtag'>xs:attribute</span> <span class='xattr'>xmlns:clt</span>="http://codalogic.com/xsdtypes" 
                      <span class='xattr'>name</span>="OwnerName" <span class='xattr'>type</span>="clt:asciiString"/>
</pre>

</skip>

<!--MAINEND-->

<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='Reference'></a>
<h1>4&nbsp;-&nbsp;Reference</h1>
<a name='LMX_Compound_Types'></a>
<!-- NEED 5cm -->
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a> <a href='#contents'>[Contents]</a></font></p>
<a name='LMXCompoundTypes'></a>
<h2>4.1&nbsp;-&nbsp;LMX Compound Types</h2>
<a href='#section-ct_c_big_int'>c_big_int</a><br>
<a href='#section-ct_c_decimal'>c_decimal</a><br>
<a href='#section-ct_c_duration'>c_duration</a><br>
<a href='#section-ct_c_datetime'>c_datetime</a><br>
<a href='#section-ct_c_time'>c_time</a><br>
<a href='#section-ct_c_date'>c_date</a><br>
<a href='#section-ct_c_gyearmonth'>c_gyearmonth</a><br>
<a href='#section-ct_c_gyear'>c_gyear</a><br>
<a href='#section-ct_c_gmonthday'>c_gmonthday</a><br>
<a href='#section-ct_c_gday'>c_gday</a><br>
<a href='#section-ct_c_gmonth'>c_gmonth</a><br>
<a href='#section-ct_c_binary'>c_binary</a><br>
<a href='#section-ct_ct_qname'>ct_qname</a><br><p>

<a name='section-ct_c_big_int'></a>
<a name='ct_c_big_int'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_big_int</h1>
<table class='synop'>
<tr><td>Stores and compares arbitrary sized integers.  
<p>
c_big_int stores the integer data in a 
std::string object, and as such can throw an out of memory exception.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_big_int</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs an empty c_big_int.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_big_int</td><td class='args'>( const c_big_int &amp; ar_big_int );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_big_int from a reference to another c_big_int.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_big_int</td><td class='args'>( const char * ap_string );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_big_int from a char string containing a printable representation of the
integer (e.g. "123").
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_big_int</td><td class='args'>( const std::string &amp;ar_string );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_big_int from a std::string object containing a printable representation of the
integer (e.g. "123").
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_big_int</td><td class='args'>( long a_long );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_big_int from a <code>long</code> value.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_big_int&nbsp;&amp;</td><td class='fname'>operator&nbsp;=</td><td class='args'>( const c_big_int &amp; ar_big_int );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assign the value in the c_big_int object references by ar_big_int to the current object.
If an exception is thrown the orignal value in this object will be preserved.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_big_int&nbsp;&amp;</td><td class='fname'>operator&nbsp;=</td><td class='args'>( const char * ap_string );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assign the value described in the char string ap_string to the current object.  
The representation of the integer in the input string is the form that would be used
to print the integer in text form (e.g. "123").
If an exception is thrown the orignal value in this object will be preserved.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_big_int&nbsp;&amp;</td><td class='fname'>operator&nbsp;=</td><td class='args'>( const std::string &amp;ar_string );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assign the value in the std::string object referenced by ar_string to the current object.
The representation of the integer in the input string is the form that would be used
to print the integer in text form (e.g. "123").
If an exception is thrown the orignal value in this object will be preserved.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_big_int&nbsp;&amp;</td><td class='fname'>operator&nbsp;=</td><td class='args'>( long a_long );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assign the value in the c_big_int object references by ar_big_int to the current object.
If an exception is thrown the original value in this object will be preserved.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>swap</td><td class='args'>( c_big_int &amp; ar_big_int );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Swap the contents of the current c_big_int with another.  This is a non-throwing operation.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>double</td><td class='fname'>get_as_float</td><td class='args'>() const;</td></tr><tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr>
<tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>long</td><td class='fname'>get</td><td class='args'>( bool *ap_is_overflowed = NULL ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Return the value contained in the object as a long.  If the optional parameter 
ap_is_overflowed is set, then if the value stored in the object is too
large to store in a long, the bool value pointed to by ap_is_overflowed will be set to
<code>true</code>, otherwise it will be set to <code>false</code>.
<p>
<b>N.B.:</b>This function does not allow conversion of the value to the most negative value of a 
long.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const char *ap_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Tests whether the integer defined by ar_lhs is numerically equal to the integer defined by
ar_rhs.  
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const char *ap_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically different to that defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const char *ap_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than the integer defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const char *ap_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const char *ap_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const char *ap_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const std::string &amp;ar_value );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically equal to the integer defined by
ar_rhs.  
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const std::string &amp;ar_value );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically different to that defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const std::string &amp;ar_value );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than the integer defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const std::string &amp;ar_value );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const std::string &amp;ar_value );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const std::string &amp;ar_value );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const std::string &amp;ar_value, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically equal to the integer defined by
ar_rhs.  
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const std::string &amp;ar_value, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically different to that defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const std::string &amp;ar_value, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than the integer defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const std::string &amp;ar_value, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const std::string &amp;ar_value, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const std::string &amp;ar_value, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const char *ap_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically equal to the integer defined by
ar_rhs.  
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const char *ap_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically different to that defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const char *ap_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than the integer defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const char *ap_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const char *ap_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const char *ap_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically equal to the integer defined by
ar_rhs.  
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically different to that defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than the integer defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically greater than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_big_int &amp;ar_lhs, const c_big_int &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Tests whether the integer defined by ar_lhs is numerically less than or equal to the integer 
defined by ar_rhs.
<p>
A number of comparison operators are defined taking different types in-order
to prevent the need for the construction of tempory c_big_int objects.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp;ar_os, const c_big_int &amp;ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Outputs the c_big_int object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>



<a name='section-ct_c_decimal'></a>
<a name='ct_c_decimal'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_decimal</h1>
<table class='synop'>
<tr><td>c_decimal holds an arbitrarily sized decimal value.  A decimal value has an integral part and a 
fractional part.
<p>
c_decimal stores information using  
std::string objects, and as such can throw an out of memory exception.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_decimal</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs an empty c_decimal object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_decimal</td><td class='args'>( const c_decimal &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_decimal object from another c_decimal object.
<p>
This function can throw an exception if it is not able to allocate sufficient dynamic
memory to store the input value using internal std::string objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_decimal</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_decimal object from a std::string containing a text representation of
a decimal number, e.g. "123.456".
<p>
This function can throw an exception if it is not able to allocate sufficient dynamic
memory to store the input value using internal std::string objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_decimal</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_decimal object from a  char string containing a text representation of
a decimal number, e.g. "123.456".
<p>
This function can throw an exception if it is not able to allocate sufficient dynamic
memory to store the input value using internal std::string objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Tests whether a value stored in a std::string is a valid format to be converted to
a c_decimal object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_decimal&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const c_decimal &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assigns the value in the input c_decimal object to the current object.
<p>
This function can throw an exception if it is not able to allocate sufficient dynamic
memory to store the input value using internal std::string objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_decimal&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assigns the value represented by the input char string to the object.
<p>
This function can throw an exception if it is not able to allocate sufficient dynamic
memory to store the input value using internal std::string objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_decimal&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; ar_s );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assigns the value represented by the input ar_s std::string to the object.
<p>
This function can throw an exception if it is not able to allocate sufficient dynamic
memory to store the input value using internal std::string objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>swap</td><td class='args'>( c_decimal &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Swaps the c_decimal value in the current object with the value specified in the input
operation.
<p>
This function does not throw.
</td></tr>

<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>double</td><td class='fname'>get_as_float</td><td class='args'>() const;</td></tr>

<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>long</td><td class='fname'>get_integral</td><td class='args'>( bool *ap_is_overflowed = NULL ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the integer part of the c_decimal value as a <code>long</code>.  If the optional
<code>ap_is_overflowed</code> parameter is included, then the <code>bool</code> that it points
to is set to <code>true</code> if the stored value is too big to be represented in a
<code>long</code> value, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_integral</td><td class='args'>( long a_v );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the integer part of the c_decimal value to the value specified by the <code>long</code> 
<code>a_v</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;long</td><td class='fname'>get_fractional</td><td class='args'>( int a_precision, bool *ap_is_overflowed = NULL ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the fractional part of the c_decimal value (the part to the right of the decimal point)
as a <code>long</code> value.  The conversion effectively involves ignoring the integer part of the
c_decimal value, multiplying the fractional part by 10<sup>a_precision</sup>, and returning the
integer part of the result.  For example, with the stored value of "12.054", calling 
get_fractional( 2 ) would return 5, and calling get_fractional( 4 ) would return 540.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_fractional</td><td class='args'>( unsigned long a_v, size_t a_precision );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the fractional part of the c_decimal object to the <code>unsigned long</code> value specified
by <code>a_v</code>.  The conversion effectively converts a_v to an integer, and then divides it by
10<sup>a_precision</sup>.  For example, set_fractional( 5, 2 ) would result in the fractional
part being set to '05'.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>long</td><td class='fname'>get_scaled</td><td class='args'>( int a_scale, bool *ap_is_overflowed = NULL ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the c_decimal value as a scaled <code>long</code> value.  Effectively the 
decimal value (both integral and fractional) is multiplied by 10<sup>a_scale</sup> and the
resultant integer part converted to a <code>long</code> value.  For example, with the stored
value of "12.054", the function get_scaled( 2 ) would return 1205.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_scaled</td><td class='args'>( long a_v, int a_scale = 0 );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the c_decimal object to the value specified by the <code>long</code> value specified by
<code>a_v</code> scaled by <code>a_scale</code>.  The value <code>a_v</code> is effectively 
divided by 10<sup>a_scale</sup> before being converted to a c_decimal value.  For example,
set_scaled( 1205, 2 ) would store the decimal value equivilent to "12.05".
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_decimal &amp; ar_lhs, const c_decimal &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value of c_decimal object referenced by ar_lhs is equal to the 
value of the c_decimal object referenced by ar_rhs, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_decimal &amp; ar_lhs, const c_decimal &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value of c_decimal object referenced by ar_lhs is not equal to the 
value of the c_decimal object referenced by ar_rhs, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_decimal &amp; ar_lhs, const c_decimal &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value of c_decimal object referenced by ar_lhs is greater than the 
value of the c_decimal object referenced by ar_rhs, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_decimal &amp; ar_lhs, const c_decimal &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value of c_decimal object referenced by ar_lhs is greater 
than or equal to the value of the c_decimal object referenced by ar_rhs, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_decimal &amp; ar_lhs, const c_decimal &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value of c_decimal object referenced by ar_lhs is less than the 
value of the c_decimal object referenced by ar_rhs, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_decimal &amp; ar_lhs, const c_decimal &amp; ar_rhs );</td></tr>

<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value of c_decimal object referenced by ar_lhs is less than or 
equal to the value of the c_decimal object referenced by ar_rhs, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_decimal &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_decimal object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>



<a name='section-ct_c_duration'></a>
<a name='ct_c_duration'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_duration</h1>
<table class='synop'>
<tr><td>Stores and compares a duration in terms of years, months, days, hours, minutes and fractional
seconds.
<p>
This class does not throw any exceptions.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_duration</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constraucts an empty c_duration object.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_duration</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_duration object from a std::string containing a valid ISO 8601 duration string.
Results are unpredictable if
the string is not a valid ISO 8601 string.  Strings can be tested to see whether they 
are valid by first calling the static <code>is_valid</code> function.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_duration</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_duration object from a char string containing a valid ISO 8601 duration string.
Results are unpredictable if
the string is not a valid ISO 8601 string.  Strings can be tested to see whether they 
are valid by first calling the static <code>is_valid</code> function.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> is the char string contains a valid ISO 8601 duration string, and
<code>false</code> otherwise.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; ar_s );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> is the std::string contains a valid ISO 8601 duration string, and
<code>false</code> otherwise.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_duration&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assigns the duration specified in char string to the object.  Results are unpredictable if
the string is not a valid ISO 8601 string.  Strings can be tested to see whether they 
are valid by first calling the static <code>is_valid</code> function.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_duration&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; ar_s );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assigns the duration specified in std::string to the object.  Results are unpredictable if
the string is not a valid ISO 8601 string.  Strings can be tested to see whether they 
are valid by first calling the static <code>is_valid</code> function.
<p>
This function does not throw any exceptions.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>bool</td><td class='fname'>get_is_neg</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the duration is negative and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_years</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the years field of the duration.  This is not normalized in anyway.  Values are always
postive.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_months</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the months field of the duration.  This is not normalized in anyway.  Values are always
postive, and can be greater than 12.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_days</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the days field of the duration.  This is not normalized in anyway.  Values are always
postive, and can be greater than 31.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_hours</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the hours field of the duration.  This is not normalized in anyway.  Values are always
postive, and can be greater than 23.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the minutes field of the duration.  This is not normalized in anyway.  Values are always
postive, and can be greater than 59.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>float</td><td class='fname'>get_secs</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the seconds field of the duration.  This is not normalized in anyway.  Values are always
postive, and can be greater than 60.  Fractional values are allowed.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_neg</td><td class='args'>( bool a_is_neg );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>If set to <code>true</code> specifies that the duration is negative (e.g. more in the past).  
If set to <code>false</code> it specifies that the duration is positive (e.g. more in the future).
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_years</td><td class='args'>( unsigned int a_years );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the years field of the duration.  Values are always postive and need not be normalized.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_months</td><td class='args'>( unsigned int a_months );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the months field of the duration.  Values are always postive.  Values need not be normalized and
can be greater than 12.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_days</td><td class='args'>( unsigned int a_days );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the days field of the duration.  Values are always postive.  Values need not be normalized and
can be greater than 31.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_hours</td><td class='args'>( unsigned int a_hours );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the hours field of the duration.  Values are always postive.  Values need not be normalized and
can be greater than 23.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_mins</td><td class='args'>( unsigned int a_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the minutes field of the duration.  Values are always postive.  Values need not be normalized and
can be greater than 59.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_secs</td><td class='args'>( float a_secs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the seconds field of the duration.  Values are always postive.  Values need not be normalized and
can be greater than 12.  Fractional seconds are allowed.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_duration &amp; ar_lhs, const c_duration &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the two c_duration objects specify the same duration, and
<code>false</code> otherwise.  
<p>
Indeterminant comparisons (e.g. 30 days vs. 1 month) return <code>false</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_duration &amp; ar_lhs, const c_duration &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the two c_duration objects specify different durations, and
<code>false</code> otherwise.  
<p>
Indeterminant comparisons (e.g. 30 days vs. 1 month) return <code>false</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_duration &amp; ar_lhs, const c_duration &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the duration specified by ar_lhs is greater than the duration 
specified by ar_rhs, and <code>false</code> otherwise.  
<p>
Indeterminant comparisons (e.g. 30 days vs. 1 month) return <code>false</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_duration &amp; ar_lhs, const c_duration &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the duration specified by ar_lhs is greater than or equal to the duration 
specified by ar_rhs, and <code>false</code> otherwise.  
<p>
Indeterminant comparisons (e.g. 30 days vs. 1 month) return <code>false</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_duration &amp; ar_lhs, const c_duration &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the duration specified by ar_lhs is less than the duration 
specified by ar_rhs, and <code>false</code> otherwise.  
<p>
Indeterminant comparisons (e.g. 30 days vs. 1 month) return <code>false</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_duration &amp; ar_lhs, const c_duration &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the duration specified by ar_lhs is less than or equal to the duration 
specified by ar_rhs, and <code>false</code> otherwise.  
<p>
Indeterminant comparisons (e.g. 30 days vs. 1 month) return <code>false</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_duration &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_duration object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_datetime'></a>
<a name='ct_c_datetime'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_datetime</h1>
<table class='synop'>
<tr><td>Stores date, time and time-zone.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_datetime</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_datetime object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_datetime</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_datetime object from a char string containing a valid ISO 8601 datetime string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_datetime</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_datetime object from a std:string containing a valid ISO 8601 datetime string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 datetime string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_datetime&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 datetime specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_datetime&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 datetime specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>int</td><td class='fname'>get_year</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the year as an integer.  There is no offset applied to the year, so the year 2004 
is return as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_month</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_day</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_hours</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the hour of the day in 24 hour format.  The valid range is 0-23.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the minutes in the hour.  The valid range is 0-59.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>float</td><td class='fname'>get_secs</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the seconds within the minute.  Fractional seconds are allowed.  The valid range
is 0.0-59.999999999999.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_year</td><td class='args'>( int a_year );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the year.  There is no offset applied to the year, so the year 2004 
is set as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_month</td><td class='args'>( unsigned int a_month );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_day</td><td class='args'>( unsigned int a_day );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_hours</td><td class='args'>( unsigned int a_hours );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the hour of the day in 24 hour format.  The valid range is 0-23.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_mins</td><td class='args'>( unsigned int a_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the minutes in the hour.  The valid range is 0-59.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_secs</td><td class='args'>( float a_secs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the seconds within the minute.  Fractional seconds are allowed.  The valid range
is 0.0-59.999999999999.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_datetime &amp; ar_lhs, const c_datetime &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_datetime object referenced by ar_lhs is equal to the 
value of the c_datetime object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_datetime &amp; ar_lhs, const c_datetime &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_datetime object referenced by ar_lhs is not equal to the 
value of the c_datetime object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_datetime &amp; ar_lhs, const c_datetime &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_datetime object referenced by ar_lhs is greater than the 
value of the c_datetime object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_datetime &amp; ar_lhs, const c_datetime &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_datetime object referenced by ar_lhs is greater 
than or equal to the value of the c_datetime object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_datetime &amp; ar_lhs, const c_datetime &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_datetime object referenced by ar_lhs is less than the 
value of the c_datetime object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_datetime &amp; ar_lhs, const c_datetime &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_datetime object referenced by ar_lhs is less than or 
equal to the value of the c_datetime object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_datetime &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_datetime object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_time'></a>
<a name='ct_c_time'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_time</h1>
<table class='synop'>
<tr><td>Stores a time, including hours, minutes, seconds and timezone.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_time</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_time object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_time</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_time object from a char string containing a valid ISO 8601 time string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_time</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_time object from a std:string containing a valid ISO 8601 time string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 time string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_time&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 time specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_time&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 time specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_hours</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the hour of the day in 24 hour format.  The valid range is 0-23.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the minutes in the hour.  The valid range is 0-59.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>float</td><td class='fname'>get_secs</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the seconds within the minute.  Fractional seconds are allowed.  The valid range
is 0.0-59.999999999999.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_hours</td><td class='args'>( unsigned int a_hours );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the hour of the day in 24 hour format.  The valid range is 0-23.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_mins</td><td class='args'>( unsigned int a_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the minutes in the hour.  The valid range is 0-59.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_secs</td><td class='args'>( float a_secs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the seconds within the minute.  Fractional seconds are allowed.  The valid range
is 0.0-59.999999999999.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_time &amp; ar_lhs, const c_time &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_time object referenced by ar_lhs is equal to the 
value of the c_time object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_time &amp; ar_lhs, const c_time &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_time object referenced by ar_lhs is not equal to the 
value of the c_time object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_time &amp; ar_lhs, const c_time &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_time object referenced by ar_lhs is greater than the 
value of the c_time object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_time &amp; ar_lhs, const c_time &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_time object referenced by ar_lhs is greater 
than or equal to the value of the c_time object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_time &amp; ar_lhs, const c_time &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_time object referenced by ar_lhs is less than the 
value of the c_time object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_time &amp; ar_lhs, const c_time &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_time object referenced by ar_lhs is less than or 
equal to the value of the c_time object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_time &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Outputs the c_time object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_date'></a>
<a name='ct_c_date'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_date</h1>
<table class='synop'>
<tr><td>Stores a date, including year, month, day of month and timezone according to the Gregorian calendar.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_date</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_date object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_date</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_date object from a char string containing a valid ISO 8601 date string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_date</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_date object from a std:string containing a valid ISO 8601 date string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 date string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_date&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 date specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_date&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 date specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>int</td><td class='fname'>get_year</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the year as an integer.  There is no offset applied to the year, so the year 2004 
is return as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_month</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_day</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_year</td><td class='args'>( int a_year );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the year.  There is no offset applied to the year, so the year 2004 
is set as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_month</td><td class='args'>( unsigned int a_month );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_day</td><td class='args'>( unsigned int a_day );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_date &amp; ar_lhs, const c_date &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_date object referenced by ar_lhs is equal to the 
value of the c_date object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_date &amp; ar_lhs, const c_date &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_date object referenced by ar_lhs is not equal to the 
value of the c_date object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_date &amp; ar_lhs, const c_date &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_date object referenced by ar_lhs is greater than the 
value of the c_date object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_date &amp; ar_lhs, const c_date &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_date object referenced by ar_lhs is greater 
than or equal to the value of the c_date object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_date &amp; ar_lhs, const c_date &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_date object referenced by ar_lhs is less than the 
value of the c_date object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_date &amp; ar_lhs, const c_date &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_date object referenced by ar_lhs is less than or 
equal to the value of the c_date object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_date &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_date object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_gyearmonth'></a>
<a name='ct_c_gyearmonth'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_gyearmonth</h1>
<table class='synop'>
<tr><td>Store a year, month and timezone of the Gregorian calendar.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_gyearmonth</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_gyearmonth object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gyearmonth</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gyearmonth object from a char string containing a valid ISO 8601 gyearmonth string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gyearmonth</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gyearmonth object from a std:string containing a valid ISO 8601 gyearmonth string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 gyearmonth string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gyearmonth&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gyearmonth specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gyearmonth&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gyearmonth specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>int</td><td class='fname'>get_year</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the year as an integer.  There is no offset applied to the year, so the year 2004 
is return as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_month</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_year</td><td class='args'>( int a_year );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the year.  There is no offset applied to the year, so the year 2004 
is set as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_month</td><td class='args'>( unsigned int a_month );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_gyearmonth &amp; ar_lhs, const c_gyearmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyearmonth object referenced by ar_lhs is equal to the 
value of the c_gyearmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_gyearmonth &amp; ar_lhs, const c_gyearmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyearmonth object referenced by ar_lhs is not equal to the 
value of the c_gyearmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_gyearmonth &amp; ar_lhs, const c_gyearmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyearmonth object referenced by ar_lhs is greater than the 
value of the c_gyearmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_gyearmonth &amp; ar_lhs, const c_gyearmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyearmonth object referenced by ar_lhs is greater 
than or equal to the value of the c_gyearmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_gyearmonth &amp; ar_lhs, const c_gyearmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyearmonth object referenced by ar_lhs is less than the 
value of the c_gyearmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_gyearmonth &amp; ar_lhs, const c_gyearmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyearmonth object referenced by ar_lhs is less than or 
equal to the value of the c_gyearmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_gyearmonth &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_gyearmonth object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_gyear'></a>
<a name='ct_c_gyear'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_gyear</h1>
<table class='synop'>
<tr><td>Stores a Gregorian year and timezone.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_gyear</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_gyear object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gyear</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gyear object from a char string containing a valid ISO 8601 gyear string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gyear</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gyear object from a std:string containing a valid ISO 8601 gyear string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 gyear string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gyear&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gyear specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gyear&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gyear specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>int</td><td class='fname'>get_year</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the year as an integer.  There is no offset applied to the year, so the year 2004 
is return as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_year</td><td class='args'>( int a_year );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the year.  There is no offset applied to the year, so the year 2004 
is set as 2004.  Negative valued years and years greater than 9999 are allowed.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc )</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_gyear &amp; ar_lhs, const c_gyear &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyear object referenced by ar_lhs is equal to the 
value of the c_gyear object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_gyear &amp; ar_lhs, const c_gyear &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyear object referenced by ar_lhs is not equal to the 
value of the c_gyear object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_gyear &amp; ar_lhs, const c_gyear &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyear object referenced by ar_lhs is greater than the 
value of the c_gyear object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_gyear &amp; ar_lhs, const c_gyear &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyear object referenced by ar_lhs is greater 
than or equal to the value of the c_gyear object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_gyear &amp; ar_lhs, const c_gyear &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyear object referenced by ar_lhs is less than the 
value of the c_gyear object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_gyear &amp; ar_lhs, const c_gyear &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gyear object referenced by ar_lhs is less than or 
equal to the value of the c_gyear object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_gyear &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_gyear object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_gmonthday'></a>
<a name='ct_c_gmonthday'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_gmonthday</h1>
<table class='synop'>
<tr><td>Stores a month, day and timezone according to the Gregorian calendar.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_gmonthday</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_gmonthday object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gmonthday</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gmonthday object from a char string containing a valid ISO 8601 gmonthday string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gmonthday</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gmonthday object from a std:string containing a valid ISO 8601 gmonthday string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 gmonthday string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gmonthday&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gmonthday specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gmonthday&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gmonthday specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_month</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_day</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_month</td><td class='args'>( unsigned int a_month );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_day</td><td class='args'>( unsigned int a_day );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==</td><td class='args'>( const c_gmonthday &amp; ar_lhs, const c_gmonthday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonthday object referenced by ar_lhs is equal to the 
value of the c_gmonthday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=</td><td class='args'>( const c_gmonthday &amp; ar_lhs, const c_gmonthday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonthday object referenced by ar_lhs is not equal to the 
value of the c_gmonthday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;></td><td class='args'>( const c_gmonthday &amp; ar_lhs, const c_gmonthday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonthday object referenced by ar_lhs is greater than the 
value of the c_gmonthday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=</td><td class='args'>( const c_gmonthday &amp; ar_lhs, const c_gmonthday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonthday object referenced by ar_lhs is greater 
than or equal to the value of the c_gmonthday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;</td><td class='args'>( const c_gmonthday &amp; ar_lhs, const c_gmonthday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonthday object referenced by ar_lhs is less than the 
value of the c_gmonthday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=</td><td class='args'>( const c_gmonthday &amp; ar_lhs, const c_gmonthday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonthday object referenced by ar_lhs is less than or 
equal to the value of the c_gmonthday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_gmonthday &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_gmonthday object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_gday'></a>
<a name='ct_c_gday'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_gday</h1>
<table class='synop'>
<tr><td>Stores a day and timezone from the Gregorian calendar.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_gday</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_gday object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gday</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gday object from a char string containing a valid ISO 8601 gday string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gday</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gday object from a std:string containing a valid ISO 8601 gday string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 gday string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gday&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gday specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gday&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gday specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_day</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>void</td><td class='fname'>set_day</td><td class='args'>( unsigned int a_day );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the day of the month in the range 1-31.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_gday &amp; ar_lhs, const c_gday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gday object referenced by ar_lhs is equal to the 
value of the c_gday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_gday &amp; ar_lhs, const c_gday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gday object referenced by ar_lhs is not equal to the 
value of the c_gday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>&nbsp;</td><td class='args'>( const c_gday &amp; ar_lhs, const c_gday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gday object referenced by ar_lhs is greater than the 
value of the c_gday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=&nbsp;</td><td class='args'>( const c_gday &amp; ar_lhs, const c_gday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gday object referenced by ar_lhs is greater 
than or equal to the value of the c_gday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;&nbsp;</td><td class='args'>( const c_gday &amp; ar_lhs, const c_gday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gday object referenced by ar_lhs is less than the 
value of the c_gday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=&nbsp;</td><td class='args'>( const c_gday &amp; ar_lhs, const c_gday &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gday object referenced by ar_lhs is less than or 
equal to the value of the c_gday object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_gday &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_gday object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_gmonth'></a>
<a name='ct_c_gmonth'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_gmonth</h1>
<table class='synop'>
<tr><td>Stores a month and timezone from the Gregorian calendar.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_gmonth</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs an empty c_gmonth object.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gmonth</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gmonth object from a char string containing a valid ISO 8601 gmonth string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_gmonth</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Constructs a c_gmonth object from a std:string containing a valid ISO 8601 gmonth string.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the std::string object contains a valid ISO 8601 gmonth string,
and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gmonth&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const char * );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gmonth specified in the char string to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_gmonth&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const std::string &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Assigns the ISO 8601 gmonth specified in the std::string object to the object.
<p>
Results are indeterminat if the input string is not in a valid format.  If necessary use the 
static <code>is_valid</code> function to test whether the string is in the right format.
<p>
This function does not throw any exceptions.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>std::string</td><td class='fname'>get_as_string</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'></td></tr>
<tr><td class='ret'>unsigned&nbsp;int</td><td class='fname'>get_month</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>int</td><td class='fname'>get_total_offset_mins</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns the total number of minutes the current timezone is offset from UTC.  It is effectively
offset hours * 60 + offset minutes.
<p>
Local time is implied by this function returning <code>0</code>, and <code>get_is_utc</code> 
returning <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>get_is_utc</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the date and time are set to UTC, and <code>false</code> otherwise.
<p>
Local time is implied by this function returning <code>false</code>, and 
<code>get_total_offset_mins</code> returning <code>0</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_month</td><td class='args'>( unsigned int a_month );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the month number in the range 1-12.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_total_offset_mins</td><td class='args'>( int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the total number of minutes the current timezone is offset from UTC.  The offset effectively
becomes offset hours * 60 + offset minutes.
<p>
Local time is implied by setting this function to <code>0</code>, and setting <code>set_is_utc</code> 
to <code>false</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_offset</td><td class='args'>( int a_off_hours, unsigned int a_off_mins );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Sets the timezone offset in terms of hours and minutes.  The sign of the minutes offset is effective
inherited from the hours offset.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_is_utc</td><td class='args'>( bool a_is_utc );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Set to <code>true</code> if the timezone is UTC, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==</td><td class='args'>( const c_gmonth &amp; ar_lhs, const c_gmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonth object referenced by ar_lhs is equal to the 
value of the c_gmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=</td><td class='args'>( const c_gmonth &amp; ar_lhs, const c_gmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonth object referenced by ar_lhs is not equal to the 
value of the c_gmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;></td><td class='args'>( const c_gmonth &amp; ar_lhs, const c_gmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonth object referenced by ar_lhs is greater than the 
value of the c_gmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;>=</td><td class='args'>( const c_gmonth &amp; ar_lhs, const c_gmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonth object referenced by ar_lhs is greater 
than or equal to the value of the c_gmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;</td><td class='args'>( const c_gmonth &amp; ar_lhs, const c_gmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonth object referenced by ar_lhs is less than the 
value of the c_gmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;&lt;=</td><td class='args'>( const c_gmonth &amp; ar_lhs, const c_gmonth &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Returns <code>true</code> if the value of c_gmonth object referenced by ar_lhs is less than or 
equal to the value of the c_gmonth object referenced by ar_rhs, and <code>false</code> otherwise.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>( std::ostream &amp; ar_os, const c_gmonth &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_gmonth object defined by <code>ar_out</code> to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


<a name='section-ct_c_binary'></a>
<a name='ct_c_binary'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class c_binary</h1>
<table class='synop'>
<tr><td>Stores a binary value as a collection of bytes.  Can be represented in XML as either hex or
base64.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>c_binary</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs an empty c_binary object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_binary</td><td class='args'>( const c_binary &amp; ar_v );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_binary object by copying the value stored in the c_binary object
specified by <code>ar_v</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>c_binary</td><td class='args'>( const unsigned char *ap_v, int a_len );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a c_binary object from an array of <code>unsigned char</code>
bytes pointed to by <code>ap_v</code>, and of length <code>a_len</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>c_binary&nbsp;&amp;</td><td class='fname'>operator&nbsp;=&nbsp;</td><td class='args'>( const c_binary &amp; );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Assigns the value stored in the specified c_binary object to the current object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>swap</td><td class='args'>( c_binary &amp; ar_v );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Swaps the contents of the current c_binary object with that of the c_binary object
defined by <code>ar_v</code>.  This is a non-throwing operation.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set</td><td class='args'>( const unsigned char *ap_v, int a_len );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the value of the object from an array of <code>unsigned char</code>
bytes pointed to by <code>ap_v</code>, and of length <code>a_len</code>.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid_hex</td><td class='args'>( const std::string &amp; ar_v );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value contained in <code>ar_v</code> is a valid hex
representation of a binary value, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>static&nbsp;bool</td><td class='fname'>is_valid_base64</td><td class='args'>( const std::string &amp; ar_v );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the value contained in <code>ar_v</code> is a valid Base64
representation of a binary value, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>from_hex</td><td class='args'>( const std::string &amp; ar_src );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Converts the hex encoded value stored in <code>ar_src</code> and stores the result in the
object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>from_base64</td><td class='args'>( const std::string &amp; ar_src );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Converts the Base64 encoded value stored in <code>ar_src</code> and stores the result in the
object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;char</td><td class='fname'>operator[]&nbsp;</td><td class='args'>( int a_i ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the byte (<code>unsigned char</code>) at index <code>a_i</code> of the stored binary 
value.  The first byte corresponds to index <code>a_i</code> = 0.  Results are unpredictable
if an attempt is made to read a byte corresponding to a index greater than the total number
of stored bytes.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>unsigned&nbsp;char&nbsp;&amp;</td><td class='fname'>operator[]&nbsp;</td><td class='args'>( int a_i );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns a reference to the byte (<code>unsigned char</code>) at index <code>a_i</code> of the 
stored binary value.  The first byte corresponds to index <code>a_i</code> = 0.  This method
allows both reading and writing of bytes.  Results are unpredictable if an attempt is made 
to read or write a byte corresponding to a index greater than the total number
of stored bytes.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>append</td><td class='args'>( unsigned char a_c );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Appends the <code>unsigned char</code> value specified by <code>a_c</code> to the end of the 
stored binary value.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>operator&nbsp;+=&nbsp;</td><td class='args'>( unsigned char a_c );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Appends the <code>unsigned char</code> value specified by <code>a_c</code> to the end of the 
stored binary value.  (Same as <code>append</code>.)
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>size_t</td><td class='fname'>size</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns the total number of bytes stored in the binary sequence.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>out_hex</td><td class='args'>( std::ostream &amp; ar_os ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Outputs the binary data to the stream defined by <code>ar_os</code> in hex format.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>out_base64</td><td class='args'>( std::ostream &amp; ar_os ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Outputs the binary data to the stream defined by <code>ar_os</code> in Base64 format.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>equal</td><td class='args'>( const unsigned char ac_rhs[], int a_rhs_len ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the binary content of the current object matches the binary
sequence specified by the array of bytes (<code>unsigned char</code>) located at <code>ac_rhs</code>
and of length <code>a_rhs_len</code>, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const c_binary &amp; ar_lhs, const c_binary &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the c_binary object specified by <code>ar_lhs</code> has the same 
content as the c_binary object specified by <code>ar_rhs</code>, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const c_binary &amp; ar_lhs, const c_binary &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Returns <code>true</code> if the c_binary object specified by <code>ar_lhs</code> has different 
content to the c_binary object specified by <code>ar_rhs</code>, and <code>false</code> otherwise.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>friend&nbsp;std::ostream&nbsp;&amp;</td><td class='fname'>operator&nbsp;&lt;&lt;&nbsp;</td><td class='args'>(  std::ostream &amp; ar_os, const c_binary &amp; ar_out );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>	Outputs the c_binary object defined by <code>ar_out</code> as raw binary data to the stream defined by 
<code>ar_os</code>, and returns a reference to <code>ar_os</code>.  Use <code>os &lt;&lt; lmx::as_base64( my_binary ) &lt;&lt; lmx::as_hex( my_binary ); to output encoded binary data.

</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>



<a name='section-ct_ct_qname'></a>
<a name='ct_ct_qname'></a>
<table class='desc'><tr><td class='synop'>
<!--NoNum--><h1>class ct_qname</h1>
<table class='synop'>
<tr><td>Template class storing a QName, including namespace URI and local name.
</td></tr>
</table>
</td></tr><tr><td class='flist'>
<table>
<tr><td class='ret'></td><td class='fname'>ct_qname</td><td class='args'>();</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs an empty ct_qname object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'></td><td class='fname'>ct_qname</td><td class='args'>( const ct_qname&lt; Tstring > &amp;ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Constructs a ct_qname object by copying the contents of ar_rhs.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>swap</td><td class='args'>( ct_qname&lt; Tstring > &amp; ar_rhs );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Swaps the contents of two ct_qname objects.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set</td><td class='args'>( const std::string &amp;ar_namespace, const Tstring &amp;ar_local_name );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Set the namespace and local name that is stored by the object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_local_name</td><td class='args'>( const Tstring &amp;ar_local_name );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Set the local name stored in the object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>const&nbsp;Tstring&nbsp;&amp;</td><td class='fname'>get_local_name</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Retrieves the local name that is stored in the object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_namespace</td><td class='args'>( const std::string &amp;ar_namespace );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the namespace stored in the object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>void</td><td class='fname'>set_namespace</td><td class='args'>( const char *ap_namespace );</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Sets the namespace stored in the object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>const&nbsp;std::string&nbsp;&amp;</td><td class='fname'>get_namespace</td><td class='args'>() const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Retrieves the namespace stored in the object.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>operator&nbsp;==&nbsp;</td><td class='args'>( const ct_qname&lt; Tstring > &amp;ar_rhs ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Tests whether two ct_qname objects store the same namespace and local name.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr><tr><td class='ret'>bool</td><td class='fname'>operator&nbsp;!=&nbsp;</td><td class='args'>( const ct_qname&lt; Tstring > &amp;ar_rhs ) const;</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td class='doc'>Tests whether two ct_qname objects store different namespaces or local names.
</td></tr>
<tr><td class='ret'>&nbsp</td><td class='ret'>&nbsp</td><td>&nbsp;</td></tr></table>
<p>
</td></tr></table>
<p align=right><font face=arial size=-1><a href='#top'>[Top]</a>
<a href='#LMX_Compound_Types'>[Reference]</a>
</font></p>


</body>

</html>
