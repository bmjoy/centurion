//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2020 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// Generated: Sat Feb 29 18:30:56 2020
// TargetNamepsace: 
// Source File: C:\Users\utente\source\repos\centurion\centurion-utils\lmx\Params.xsd
// LMX Version: 7.4
// Compile options: "C:\Users\utente\source\repos\centurion\centurion-utils\lmx\Params.xsd"
//      "C:\Users\utente\source\repos\centurion\centurion-utils\lmx\output\Params"
//      

// *********** Code generated in evaluation mode ************
// *********** Must not be supplied to a customer ***********


#if defined( _MSC_VER ) && _MSC_VER > 1000
#pragma warning (disable:4786)  // Disable truncated debug info warning
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#pragma warning (disable:4702)  // Disable unreachable code
#endif

#include <algorithm>
#include <memory>
#ifndef LMX_GEN_SOURCE
#define LMX_GEN_SOURCE
#endif

#include "Params.h"
#include "lmxparse.h"

#if defined( _MSC_VER ) && _MSC_VER <= 1200
using namespace lmx;
#endif

const lmx::s_ns_map ns_map_reader[] =
{
    { 0,    LMXNULL,    LMXNULL }
};

const lmx::s_ns_map ns_map_writer_1[] =
{
    { 0,    LMXNULL,    LMXNULL }
};

const lmx::s_event_map c_params::attr_event_map[] =
{
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

const lmx::s_event_map c_params::elem_event_map[] =
{
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tc_big_int & r_value, const char * p_name )
{
    LMX_NO_WARN_UNUSED( r_value );
    LMX_NO_WARN_UNUSED( p_name );
    return lmx::ELMX_OK;
}
#endif // LMX_USER_VALIDATE

lmx::elmx_error lexical_validator_1( lmx::c_xml_reader & r_reader, const std::string & r_value )
{
    lmx::elmx_error error = lmx::ELMX_OK;
    if( ! lmx::is_valid_integer( r_value ) &&
            (error = r_reader.handle_error( lmx::ELMX_VALUE_BAD_FORMAT )) != lmx::ELMX_OK )
        return error;
    return lmx::ELMX_OK;
}

lmx::elmx_error value_validator_1( lmx::c_xml_reader & r_reader, const lmx::tc_big_int & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

const lmx::ct_typed_validation_spec< lmx::tc_big_int > validation_spec_1(
                lmx::EXWS_COLLAPSE,     // Whitespace handling
                "",                     // Default value (if any)
                &lexical_validator_1,   // Lexical validator function
                &value_validator_1,     // Value validator function
                &lmx::v_to_o< lmx::tc_big_int >, // Lexical to object converter
                &lmx::o_to_v< lmx::tc_big_int > ); // Object to lexical converter

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const bool & r_value, const char * p_name )
{
    LMX_NO_WARN_UNUSED( r_value );
    LMX_NO_WARN_UNUSED( p_name );
    return lmx::ELMX_OK;
}
#endif // LMX_USER_VALIDATE

lmx::elmx_error lexical_validator_2( lmx::c_xml_reader & r_reader, const std::string & r_value )
{
    lmx::elmx_error error = lmx::ELMX_OK;
    if( ! lmx::is_valid_bool( r_value ) &&
            (error = r_reader.handle_error( lmx::ELMX_VALUE_BAD_FORMAT )) != lmx::ELMX_OK )
        return error;
    return lmx::ELMX_OK;
}

lmx::elmx_error value_validator_2( lmx::c_xml_reader & r_reader, const bool & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

const lmx::ct_typed_validation_spec< bool > validation_spec_2(
                lmx::EXWS_COLLAPSE,     // Whitespace handling
                "",                     // Default value (if any)
                &lexical_validator_2,   // Lexical validator function
                &value_validator_2,     // Value validator function
                &lmx::v_to_o< bool >,   // Lexical to object converter
                &lmx::o_to_v< bool > ); // Object to lexical converter

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tc_decimal & r_value, const char * p_name )
{
    LMX_NO_WARN_UNUSED( r_value );
    LMX_NO_WARN_UNUSED( p_name );
    return lmx::ELMX_OK;
}
#endif // LMX_USER_VALIDATE

lmx::elmx_error lexical_validator_3( lmx::c_xml_reader & r_reader, const std::string & r_value )
{
    lmx::elmx_error error = lmx::ELMX_OK;
    if( ! lmx::c_decimal::is_valid( r_value ) &&
            (error = r_reader.handle_error( lmx::ELMX_VALUE_BAD_FORMAT )) != lmx::ELMX_OK )
        return error;
    return lmx::ELMX_OK;
}

lmx::elmx_error value_validator_3( lmx::c_xml_reader & r_reader, const lmx::tc_decimal & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

const lmx::ct_typed_validation_spec< lmx::tc_decimal > validation_spec_3(
                lmx::EXWS_COLLAPSE,     // Whitespace handling
                "",                     // Default value (if any)
                &lexical_validator_3,   // Lexical validator function
                &value_validator_3,     // Value validator function
                &lmx::v_to_o< lmx::tc_decimal >, // Lexical to object converter
                &lmx::o_to_v< lmx::tc_decimal > ); // Object to lexical converter

c_params::c_params()
{
    init();
}

c_params::c_params( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( r_reader );
}

c_params::c_params( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( c_file_name, p_debug_error );
}

#if LMX_WANT_WIDE_FILE_NAMES == 1
c_params::c_params( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( c_file_name, p_debug_error );
}
#endif

c_params::c_params( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( p_memory, memory_size, p_debug_error );
}

c_params::c_params( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( r_string.data(), r_string.size(), p_debug_error );
}

c_params::c_params( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( r_any_info, p_debug_error );
}

void c_params::init()
{
}

void c_params::reset()
{
    c_params l_temp;
    swap( l_temp );
}

c_params::~c_params()
{
}

c_params::c_params( const c_params & r_rhs )
{
    LMX_NO_WARN_UNUSED( r_rhs );
    init();
    m_anon_xPosition = r_rhs.m_anon_xPosition;
}

void c_params::swap( c_params & r_rhs )
{
    m_anon_xPosition.swap( r_rhs.m_anon_xPosition );
}

c_params & c_params::operator = ( const c_params & r_rhs )
{
    c_params l_temp( r_rhs );
    swap( l_temp );
    return *this;
}

c_params * c_params::clone() const
{
    return new c_params( *this );
}

// Note: Class 'anon_xPosition' code not generated due to license restrictions.
//       See http://www.xml2cpp.com for upgrade information.

const c_params::c_anon_xPosition & c_params::get_anon_xPosition( size_t index ) const // For read access
{
    return m_anon_xPosition.get( index );
}

lmx::elmx_error c_params::append_anon_xPosition()            // For write access
{
    return append_anon_xPosition( new c_anon_xPosition );
}

lmx::elmx_error c_params::append_anon_xPosition( c_anon_xPosition * p_value ) // For write access
{
    lmx::uniq_ptr< c_anon_xPosition >::type auto_p_value( p_value );
    m_anon_xPosition.append( auto_p_value );
    return lmx::ELMX_OK;
}

c_params::c_anon_xPosition & c_params::back_anon_xPosition() // For write access
{
    return m_anon_xPosition.back();
}

lmx::elmx_error c_params::insert_anon_xPosition( size_t index ) // For write access
{
    return insert_anon_xPosition( index, new c_anon_xPosition );
}

lmx::elmx_error c_params::insert_anon_xPosition( size_t index, c_anon_xPosition * p_value ) // For write access
{
    lmx::uniq_ptr< c_anon_xPosition >::type auto_p_value( p_value );
    m_anon_xPosition.insert( index, auto_p_value );
    return lmx::ELMX_OK;
}

c_params::c_anon_xPosition & c_params::get_anon_xPosition( size_t index ) // For read/write access
{
    return m_anon_xPosition.get( index );
}

void c_params::delete_anon_xPosition( size_t index )
{
    lmx_assert( index < m_anon_xPosition.size() );
    m_anon_xPosition.erase( index );
}

void c_params::clear_anon_xPosition()
{
    m_anon_xPosition.clear();
}

c_params::c_anon_xPosition & c_params::assign_anon_xPosition( size_t index, const c_anon_xPosition & value ) // Deep Copy
{
    return get_anon_xPosition( index ) = value;
}

c_params::c_anon_xPosition & c_params::assign_anon_xPosition( size_t index, c_anon_xPosition * p )
{
    return m_anon_xPosition.assign( index, p );
}

size_t c_params::size_anon_xPosition() const
{
    return m_anon_xPosition.size();
}

bool c_params::is_occurs_ok( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/ ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in );
    if( check_tracker.named_check( ! m_anon_xPosition.is_occurs_ok( 1 ),  "" ) )
        return check_tracker.report( __FILE__, __LINE__ );
    return true;
}

bool c_params::check( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/, const char * p_name_in ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in, p_name_in );
    if( ! is_occurs_ok( &check_tracker ) )
        return false;
    {
        for( size_t i=0; i<m_anon_xPosition.size(); ++i )
            if( ! m_anon_xPosition.get( i ).check( &check_tracker, "" ) )
                return false;
        }
    return true;
}

lmx::elmx_error c_params::marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, c_file_name, p_debug_error );
}

#if defined( _MSC_VER ) && _MSC_VER >= 1400
lmx::elmx_error c_params::marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, c_file_name, p_debug_error );
}
#endif

lmx::elmx_error c_params::marshal( std::string * p_string, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, p_string, p_debug_error );
}

lmx::elmx_error c_params::marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, r_sos, p_debug_error );
}

lmx::elmx_error c_params::marshal( lmx::c_xml_writer & r_writer, const char * p_name ) const
{
    lmx_assert_is_occurs_ok( is_occurs_ok() );
    lmx::c_xml_writer_local l_xml_writer_local( r_writer );
    r_writer.start_element( p_name );
    r_writer.conditionally_select_ns_map( ns_map_writer_1 );
    r_writer.conditionally_write_ns_attrs( false );
    lmx::elmx_error error;
    if( (error = marshal_child_elements( r_writer )) != lmx::ELMX_OK )
        return error;
    r_writer.end_element( p_name );
    return lmx::ELMX_OK;
}

lmx::elmx_error c_params::marshal_child_elements( lmx::c_xml_writer & r_writer ) const
{
    LMX_NO_WARN_UNUSED( r_writer );
    lmx::elmx_error error = lmx::ELMX_OK;
    {
    for( size_t i=0; i<m_anon_xPosition.size(); ++i )
    {
        if( (error = m_anon_xPosition.get( i ).marshal( r_writer, "" )) != lmx::ELMX_OK )
            return error;
    }
    }
    return error;
}

lmx::elmx_error c_params::unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, c_file_name, p_debug_error );
}

#if LMX_WANT_WIDE_FILE_NAMES == 1
lmx::elmx_error c_params::unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, c_file_name, p_debug_error );
}
#endif

lmx::elmx_error c_params::unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, p_memory, memory_size, p_debug_error );
}

lmx::elmx_error c_params::unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, r_any_info, p_debug_error );
}

lmx::elmx_error c_params::unmarshal( lmx::c_xml_reader & r_reader )
{
    r_reader.set_code_file( __FILE__ );
    r_reader.set_ns_map( ns_map_reader );
    lmx::elmx_error error = lmx::ELMX_OK;
    lmx::c_xml_reader_local l_reader_local( &r_reader );
    r_reader.get_element_event( &error );
    if( error != lmx::ELMX_OK && (error = r_reader.handle_error( error, __LINE__ )) != lmx::ELMX_OK )
        return error;
    if( (r_reader.get_element_ns_id() != lmx::EXKN_NONE || r_reader.get_local_name() != "params") && (error = r_reader.handle_error( lmx::ELMX_ELEMENT_NOT_FOUND, "params", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return error;
    error = unmarshal( r_reader, r_reader.name );
    return error;
}

lmx::elmx_error c_params::unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name )
{
    if( &r_reader.name != &r_name )
        r_reader.name = r_name;
    lmx::elmx_error error;
    class c_params_unmarshal_helper : public lmx::c_unmarshal_helper
    {
    private:
        c_params * p_parent;
        lmx::c_xml_reader & r_reader;
    public:
        c_params_unmarshal_helper( c_params * p_parent_in, lmx::c_xml_reader & r_reader_in )
            : lmx::c_unmarshal_helper( r_reader_in ), p_parent( p_parent_in ), r_reader( r_reader_in ) {}
        virtual bool unmarshal_an_attribute( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_attributes( r_reader, p_error ); }
        virtual lmx::elmx_error unmarshal_attributes_check()
            { return p_parent->unmarshal_attributes_check( r_reader ); }
        virtual bool unmarshal_complex_body( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_body( r_reader, p_error ); }
    };
    // If your compiler generates errors concerning access to private/protected methods not allowed, 
    // compile schema using LMX's -no-local-classes flag.
    c_params_unmarshal_helper helper( this, r_reader );
    error = helper.unmarshal_complex_content( __FILE__, __LINE__ );
    return error;
}

bool c_params::unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( p_error );
    return false;
}

lmx::elmx_error c_params::unmarshal_attributes_check( lmx::c_xml_reader & r_reader )
{
    LMX_NO_WARN_UNUSED( r_reader );
    return lmx::ELMX_OK;
}

bool c_params::unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    r_reader.tokenise( elem_event_map, lmx::EXNT_ELEM );
    if( c_anon_xPosition::is_member( r_reader ) )
    {
        while( c_anon_xPosition::is_member( r_reader ) )
        {
            r_reader.set_code_line( __LINE__ );
            m_anon_xPosition.append();
            m_anon_xPosition.back().unmarshal( r_reader, p_error );
            if( *p_error != lmx::ELMX_OK )
                return false;
            r_reader.tokenise( &elem_event_map[0], lmx::EXNT_ELEM );
        }
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    if( ((m_anon_xPosition.size() < 1)) &&
            (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    return true;
}

