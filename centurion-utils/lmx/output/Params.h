//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2020 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// Generated: Sat Feb 29 18:30:56 2020
// TargetNamepsace: 
// Source File: C:\Users\utente\source\repos\centurion\centurion-utils\lmx\Params.xsd
// LMX Version: 7.4
// Compile options: "C:\Users\utente\source\repos\centurion\centurion-utils\lmx\Params.xsd"
//      "C:\Users\utente\source\repos\centurion\centurion-utils\lmx\output\Params"
//      

// *********** Code generated in evaluation mode ************
// *********** Must not be supplied to a customer ***********


#ifndef __PARAMS_H__
#define __PARAMS_H__

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (push)
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#endif

#include "lmxuser.h"

// To help MS intellisense
#ifndef LMX_GDECL
#define LMX_GDECL
#endif

LMX_GDECL extern const lmx::s_ns_map ns_map_reader[];
LMX_GDECL extern const lmx::s_ns_map ns_map_writer_1[];

enum
{
    e_error = lmx::EXE_LAST_XML_EVENT,
    e_NONE_params,
    e_NONE_xPosition,
    e_NONE_yPosition,
    e_NONE_scrollValue,
    e_NONE_xLeftClick,
    e_NONE_xRightClick,
    e_NONE_y2dPosition,
    e_NONE_y2dRightClick,
    e_NONE_yLeftClick,
    e_NONE_yRightClick,
    e_NONE_leftClick,
    e_NONE_leftHold,
    e_NONE_release,
    e_NONE_rightClick,
    e_NONE_scrollBool,
    e_NONE_heightZoomed,
    e_NONE_ratio,
    e_NONE_widthZoomed,
    e_NONE_shouldClose,
    e_NONE_bottomBarHeight,
    e_NONE_topBarHeight,
    e_any
};

enum elmx_enums
{
    e_e_unknown
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tc_big_int &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const bool &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tc_decimal &, const char * );
#endif // LMX_USER_VALIDATE

//-----------------------------------------------------------------------------
// Generated in Evaluation Mode by Codalogic LMX C++ XML Databinder.           |
//     Upgrade to Professional Edition to enable full functionality.           |
//         Visit http://codalogic.com/lmx/buy.php                              |
//-----------------------------------------------------------------------------

// From: C:\Users\utente\source\repos\centurion\centurion-utils\lmx\Params.xsd(4)
class c_params
{
public:
    //-----------------------------------------------------------------------------
    // Generated in Evaluation Mode by Codalogic LMX C++ XML Databinder.           |
    //     Upgrade to Professional Edition to enable full functionality.           |
    //         Visit http://codalogic.com/lmx/buy.php                              |
    //-----------------------------------------------------------------------------

    // From: C:\Users\utente\source\repos\centurion\centurion-utils\lmx\Params.xsd(7)
    class c_anon_xPosition
    {
    public:
        enum elmx_chosen
        {
            e_xPosition = 1000,
            e_yPosition = 1001,
            e_scrollValue = 1002,
            e_xLeftClick = 1003,
            e_xRightClick = 1004,
            e_y2dPosition = 1005,
            e_y2dRightClick = 1006,
            e_yLeftClick = 1007,
            e_yRightClick = 1008,
            e_leftClick = 1009,
            e_leftHold = 1010,
            e_release = 1011,
            e_rightClick = 1012,
            e_scrollBool = 1013,
            e_heightZoomed = 1014,
            e_ratio = 1015,
            e_widthZoomed = 1016,
            e_shouldClose = 1017,
            e_bottomBarHeight = 1018,
            e_topBarHeight = 1019,
            e_choice_not_set = 1020
        };

    private:
        // Element(s)
        elmx_chosen chosen;
        union u_anon_xPosition
        {
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_xPosition;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_yPosition;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_scrollValue;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_xLeftClick;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_xRightClick;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_y2dPosition;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_y2dRightClick;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_yLeftClick;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_yRightClick;
            lmx::ct_simple_pod_single< bool > * m_leftClick;
            lmx::ct_simple_pod_single< bool > * m_leftHold;
            lmx::ct_simple_pod_single< bool > * m_release;
            lmx::ct_simple_pod_single< bool > * m_rightClick;
            lmx::ct_simple_pod_single< bool > * m_scrollBool;
            lmx::ct_simple_non_pod_single< lmx::tc_decimal > * m_heightZoomed;
            lmx::ct_simple_non_pod_single< lmx::tc_decimal > * m_ratio;
            lmx::ct_simple_non_pod_single< lmx::tc_decimal > * m_widthZoomed;
            lmx::ct_simple_pod_single< bool > * m_shouldClose;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_bottomBarHeight;
            lmx::ct_simple_non_pod_single< lmx::tc_big_int > * m_topBarHeight;
            void * null_m;
        } u;

        static const lmx::s_event_map attr_event_map[];
        static const lmx::s_event_map elem_event_map[];

    public:
        LMX_GDECL c_anon_xPosition();
        LMX_GDECL c_anon_xPosition( const c_anon_xPosition & r_rhs );
        LMX_GDECL c_anon_xPosition & operator = ( const c_anon_xPosition & r_rhs );
        LMX_GDECL virtual c_anon_xPosition * clone() const;
        LMX_GDECL void swap( c_anon_xPosition & r_rhs );
        LMX_GDECL virtual ~c_anon_xPosition();

        LMX_GDECL elmx_chosen getchosen() const { return chosen; }

        // Element(s)

        //    xPosition --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_xPosition
        LMX_GDECL const lmx::tc_big_int & get_xPosition() const
        {
            lmx_assert( chosen == e_xPosition );
            return u.m_xPosition->get();
        }
        LMX_GDECL lmx::tc_big_int & get_xPosition()
        {
            select_xPosition();
            return u.m_xPosition->get();
        }
        LMX_GDECL lmx::elmx_error set_xPosition( const lmx::tc_big_int & value )
        {
            select_xPosition();
            return u.m_xPosition->set( value );
        }
        LMX_GDECL void select_xPosition();

        //    yPosition --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_yPosition
        LMX_GDECL const lmx::tc_big_int & get_yPosition() const
        {
            lmx_assert( chosen == e_yPosition );
            return u.m_yPosition->get();
        }
        LMX_GDECL lmx::tc_big_int & get_yPosition()
        {
            select_yPosition();
            return u.m_yPosition->get();
        }
        LMX_GDECL lmx::elmx_error set_yPosition( const lmx::tc_big_int & value )
        {
            select_yPosition();
            return u.m_yPosition->set( value );
        }
        LMX_GDECL void select_yPosition();

        //    scrollValue --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_scrollValue
        LMX_GDECL const lmx::tc_big_int & get_scrollValue() const
        {
            lmx_assert( chosen == e_scrollValue );
            return u.m_scrollValue->get();
        }
        LMX_GDECL lmx::tc_big_int & get_scrollValue()
        {
            select_scrollValue();
            return u.m_scrollValue->get();
        }
        LMX_GDECL lmx::elmx_error set_scrollValue( const lmx::tc_big_int & value )
        {
            select_scrollValue();
            return u.m_scrollValue->set( value );
        }
        LMX_GDECL void select_scrollValue();

        //    xLeftClick --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_xLeftClick
        LMX_GDECL const lmx::tc_big_int & get_xLeftClick() const
        {
            lmx_assert( chosen == e_xLeftClick );
            return u.m_xLeftClick->get();
        }
        LMX_GDECL lmx::tc_big_int & get_xLeftClick()
        {
            select_xLeftClick();
            return u.m_xLeftClick->get();
        }
        LMX_GDECL lmx::elmx_error set_xLeftClick( const lmx::tc_big_int & value )
        {
            select_xLeftClick();
            return u.m_xLeftClick->set( value );
        }
        LMX_GDECL void select_xLeftClick();

        //    xRightClick --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_xRightClick
        LMX_GDECL const lmx::tc_big_int & get_xRightClick() const
        {
            lmx_assert( chosen == e_xRightClick );
            return u.m_xRightClick->get();
        }
        LMX_GDECL lmx::tc_big_int & get_xRightClick()
        {
            select_xRightClick();
            return u.m_xRightClick->get();
        }
        LMX_GDECL lmx::elmx_error set_xRightClick( const lmx::tc_big_int & value )
        {
            select_xRightClick();
            return u.m_xRightClick->set( value );
        }
        LMX_GDECL void select_xRightClick();

        //    y2dPosition --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_y2dPosition
        LMX_GDECL const lmx::tc_big_int & get_y2dPosition() const
        {
            lmx_assert( chosen == e_y2dPosition );
            return u.m_y2dPosition->get();
        }
        LMX_GDECL lmx::tc_big_int & get_y2dPosition()
        {
            select_y2dPosition();
            return u.m_y2dPosition->get();
        }
        LMX_GDECL lmx::elmx_error set_y2dPosition( const lmx::tc_big_int & value )
        {
            select_y2dPosition();
            return u.m_y2dPosition->set( value );
        }
        LMX_GDECL void select_y2dPosition();

        //    y2dRightClick --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_y2dRightClick
        LMX_GDECL const lmx::tc_big_int & get_y2dRightClick() const
        {
            lmx_assert( chosen == e_y2dRightClick );
            return u.m_y2dRightClick->get();
        }
        LMX_GDECL lmx::tc_big_int & get_y2dRightClick()
        {
            select_y2dRightClick();
            return u.m_y2dRightClick->get();
        }
        LMX_GDECL lmx::elmx_error set_y2dRightClick( const lmx::tc_big_int & value )
        {
            select_y2dRightClick();
            return u.m_y2dRightClick->set( value );
        }
        LMX_GDECL void select_y2dRightClick();

        //    yLeftClick --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_yLeftClick
        LMX_GDECL const lmx::tc_big_int & get_yLeftClick() const
        {
            lmx_assert( chosen == e_yLeftClick );
            return u.m_yLeftClick->get();
        }
        LMX_GDECL lmx::tc_big_int & get_yLeftClick()
        {
            select_yLeftClick();
            return u.m_yLeftClick->get();
        }
        LMX_GDECL lmx::elmx_error set_yLeftClick( const lmx::tc_big_int & value )
        {
            select_yLeftClick();
            return u.m_yLeftClick->set( value );
        }
        LMX_GDECL void select_yLeftClick();

        //    yRightClick --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_yRightClick
        LMX_GDECL const lmx::tc_big_int & get_yRightClick() const
        {
            lmx_assert( chosen == e_yRightClick );
            return u.m_yRightClick->get();
        }
        LMX_GDECL lmx::tc_big_int & get_yRightClick()
        {
            select_yRightClick();
            return u.m_yRightClick->get();
        }
        LMX_GDECL lmx::elmx_error set_yRightClick( const lmx::tc_big_int & value )
        {
            select_yRightClick();
            return u.m_yRightClick->set( value );
        }
        LMX_GDECL void select_yRightClick();

        //    leftClick --> xs:boolean
        //    getchosen() == c_params::c_anon_xPosition::e_leftClick
        LMX_GDECL const bool & get_leftClick() const
        {
            lmx_assert( chosen == e_leftClick );
            return u.m_leftClick->get();
        }
        LMX_GDECL lmx::elmx_error set_leftClick( const bool & value )
        {
            select_leftClick();
            return u.m_leftClick->set( value );
        }
        LMX_GDECL void select_leftClick();

        //    leftHold --> xs:boolean
        //    getchosen() == c_params::c_anon_xPosition::e_leftHold
        LMX_GDECL const bool & get_leftHold() const
        {
            lmx_assert( chosen == e_leftHold );
            return u.m_leftHold->get();
        }
        LMX_GDECL lmx::elmx_error set_leftHold( const bool & value )
        {
            select_leftHold();
            return u.m_leftHold->set( value );
        }
        LMX_GDECL void select_leftHold();

        //    release --> xs:boolean
        //    getchosen() == c_params::c_anon_xPosition::e_release
        LMX_GDECL const bool & get_release() const
        {
            lmx_assert( chosen == e_release );
            return u.m_release->get();
        }
        LMX_GDECL lmx::elmx_error set_release( const bool & value )
        {
            select_release();
            return u.m_release->set( value );
        }
        LMX_GDECL void select_release();

        //    rightClick --> xs:boolean
        //    getchosen() == c_params::c_anon_xPosition::e_rightClick
        LMX_GDECL const bool & get_rightClick() const
        {
            lmx_assert( chosen == e_rightClick );
            return u.m_rightClick->get();
        }
        LMX_GDECL lmx::elmx_error set_rightClick( const bool & value )
        {
            select_rightClick();
            return u.m_rightClick->set( value );
        }
        LMX_GDECL void select_rightClick();

        //    scrollBool --> xs:boolean
        //    getchosen() == c_params::c_anon_xPosition::e_scrollBool
        LMX_GDECL const bool & get_scrollBool() const
        {
            lmx_assert( chosen == e_scrollBool );
            return u.m_scrollBool->get();
        }
        LMX_GDECL lmx::elmx_error set_scrollBool( const bool & value )
        {
            select_scrollBool();
            return u.m_scrollBool->set( value );
        }
        LMX_GDECL void select_scrollBool();

        //    heightZoomed --> xs:decimal
        //    getchosen() == c_params::c_anon_xPosition::e_heightZoomed
        LMX_GDECL const lmx::tc_decimal & get_heightZoomed() const
        {
            lmx_assert( chosen == e_heightZoomed );
            return u.m_heightZoomed->get();
        }
        LMX_GDECL lmx::tc_decimal & get_heightZoomed()
        {
            select_heightZoomed();
            return u.m_heightZoomed->get();
        }
        LMX_GDECL lmx::elmx_error set_heightZoomed( const lmx::tc_decimal & value )
        {
            select_heightZoomed();
            return u.m_heightZoomed->set( value );
        }
        LMX_GDECL void select_heightZoomed();

        //    ratio --> xs:decimal
        //    getchosen() == c_params::c_anon_xPosition::e_ratio
        LMX_GDECL const lmx::tc_decimal & get_ratio() const
        {
            lmx_assert( chosen == e_ratio );
            return u.m_ratio->get();
        }
        LMX_GDECL lmx::tc_decimal & get_ratio()
        {
            select_ratio();
            return u.m_ratio->get();
        }
        LMX_GDECL lmx::elmx_error set_ratio( const lmx::tc_decimal & value )
        {
            select_ratio();
            return u.m_ratio->set( value );
        }
        LMX_GDECL void select_ratio();

        //    widthZoomed --> xs:decimal
        //    getchosen() == c_params::c_anon_xPosition::e_widthZoomed
        LMX_GDECL const lmx::tc_decimal & get_widthZoomed() const
        {
            lmx_assert( chosen == e_widthZoomed );
            return u.m_widthZoomed->get();
        }
        LMX_GDECL lmx::tc_decimal & get_widthZoomed()
        {
            select_widthZoomed();
            return u.m_widthZoomed->get();
        }
        LMX_GDECL lmx::elmx_error set_widthZoomed( const lmx::tc_decimal & value )
        {
            select_widthZoomed();
            return u.m_widthZoomed->set( value );
        }
        LMX_GDECL void select_widthZoomed();

        //    shouldClose --> xs:boolean
        //    getchosen() == c_params::c_anon_xPosition::e_shouldClose
        LMX_GDECL const bool & get_shouldClose() const
        {
            lmx_assert( chosen == e_shouldClose );
            return u.m_shouldClose->get();
        }
        LMX_GDECL lmx::elmx_error set_shouldClose( const bool & value )
        {
            select_shouldClose();
            return u.m_shouldClose->set( value );
        }
        LMX_GDECL void select_shouldClose();

        //    bottomBarHeight --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_bottomBarHeight
        LMX_GDECL const lmx::tc_big_int & get_bottomBarHeight() const
        {
            lmx_assert( chosen == e_bottomBarHeight );
            return u.m_bottomBarHeight->get();
        }
        LMX_GDECL lmx::tc_big_int & get_bottomBarHeight()
        {
            select_bottomBarHeight();
            return u.m_bottomBarHeight->get();
        }
        LMX_GDECL lmx::elmx_error set_bottomBarHeight( const lmx::tc_big_int & value )
        {
            select_bottomBarHeight();
            return u.m_bottomBarHeight->set( value );
        }
        LMX_GDECL void select_bottomBarHeight();

        //    topBarHeight --> xs:integer
        //    getchosen() == c_params::c_anon_xPosition::e_topBarHeight
        LMX_GDECL const lmx::tc_big_int & get_topBarHeight() const
        {
            lmx_assert( chosen == e_topBarHeight );
            return u.m_topBarHeight->get();
        }
        LMX_GDECL lmx::tc_big_int & get_topBarHeight()
        {
            select_topBarHeight();
            return u.m_topBarHeight->get();
        }
        LMX_GDECL lmx::elmx_error set_topBarHeight( const lmx::tc_big_int & value )
        {
            select_topBarHeight();
            return u.m_topBarHeight->set( value );
        }
        LMX_GDECL void select_topBarHeight();

        LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

        LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "" ) const;

        // General marshal/unmarshal functions
        LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "" ) const;
        LMX_GDECL bool unmarshal( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
        LMX_GDECL static bool is_member( lmx::c_xml_reader & r_reader );
        LMX_GDECL void reset();

    protected:
        LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
        LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;

    private:
        LMX_GDECL void init();
        LMX_GDECL void release();
        LMX_GDECL void release_choice();
    };


private:
    // Element(s)
    lmx::ct_complex_multi< c_anon_xPosition > m_anon_xPosition;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];

public:
    LMX_GDECL c_params();
    LMX_GDECL c_params( const c_params & r_rhs );
    LMX_GDECL c_params & operator = ( const c_params & r_rhs );
    LMX_GDECL virtual c_params * clone() const;
    LMX_GDECL void swap( c_params & r_rhs );
    LMX_GDECL c_params( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_params( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_params( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_params( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_params( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_params( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_params();

    // Element(s)

    //    {anonymous compositor} --> <anon_xPosition>[1..*]
    LMX_GDECL const c_anon_xPosition & get_anon_xPosition( size_t index ) const; // For read access
    LMX_GDECL lmx::elmx_error append_anon_xPosition();            // For write access
    LMX_GDECL lmx::elmx_error append_anon_xPosition( c_anon_xPosition * p_value ); // For write access
    LMX_GDECL c_anon_xPosition & back_anon_xPosition();           // For write access
    LMX_GDECL lmx::elmx_error insert_anon_xPosition( size_t index ); // For write access
    LMX_GDECL lmx::elmx_error insert_anon_xPosition( size_t index, c_anon_xPosition * p_value ); // For write access
    LMX_GDECL c_anon_xPosition & get_anon_xPosition( size_t index ); // For read/write access
    LMX_GDECL void delete_anon_xPosition( size_t index );
    LMX_GDECL void clear_anon_xPosition();
    LMX_GDECL c_anon_xPosition & assign_anon_xPosition( size_t index, const c_anon_xPosition & value ); // Deep Copy
    LMX_GDECL c_anon_xPosition & assign_anon_xPosition( size_t index, c_anon_xPosition * p );
    LMX_GDECL size_t size_anon_xPosition() const;
    typedef lmx::ct_complex_multi< c_anon_xPosition >::Tconst_range TR_const_anon_xPosition;
    LMX_GDECL TR_const_anon_xPosition  in_anon_xPosition() const { return m_anon_xPosition.const_range_bounds(); };
    typedef lmx::ct_complex_multi< c_anon_xPosition >::Trange TR_anon_xPosition;
    LMX_GDECL TR_anon_xPosition  in_anon_xPosition() { return m_anon_xPosition.range_bounds(); };

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "params" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return ns_map_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "params" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (pop)  // Restore disabled warnings
#endif


#endif      // End of include guard
