//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2020 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// Generated: Wed Feb 26 23:16:04 2020
// TargetNamepsace: 
// Source File: C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd
// LMX Version: 7.4
// Compile options: "C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd"
//      "C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\output\params"
//      

// *********** Code generated in evaluation mode ************
// *********** Must not be supplied to a customer ***********


#if defined( _MSC_VER ) && _MSC_VER > 1000
#pragma warning (disable:4786)  // Disable truncated debug info warning
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#pragma warning (disable:4702)  // Disable unreachable code
#endif

#include <algorithm>
#include <memory>
#ifndef LMX_GEN_SOURCE
#define LMX_GEN_SOURCE
#endif

#include "params.h"
#include "lmxparse.h"

#if defined( _MSC_VER ) && _MSC_VER <= 1200
using namespace lmx;
#endif

const lmx::s_ns_map ns_map_reader[] =
{
    { 0,    LMXNULL,    LMXNULL }
};

const lmx::s_ns_map ns_map_writer_1[] =
{
    { 0,    LMXNULL,    LMXNULL }
};

const lmx::s_event_map c_Params::attr_event_map[] =
{
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

const lmx::s_event_map c_Params::elem_event_map[] =
{
    { lmx::EXKN_NONE,   "Values",                               6,  e_NONE_Values },
    { lmx::EXKN_NONE,   "Booleans",                             8,  e_NONE_Booleans },
    { lmx::EXKN_NONE,   "ErrorCodes",                           10, e_NONE_ErrorCodes },
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tc_big_int & r_value, const char * p_name )
{
    LMX_NO_WARN_UNUSED( r_value );
    LMX_NO_WARN_UNUSED( p_name );
    return lmx::ELMX_OK;
}
#endif // LMX_USER_VALIDATE

lmx::elmx_error lexical_validator_1( lmx::c_xml_reader & r_reader, const std::string & r_value )
{
    lmx::elmx_error error = lmx::ELMX_OK;
    if( ! lmx::is_valid_integer( r_value ) &&
            (error = r_reader.handle_error( lmx::ELMX_VALUE_BAD_FORMAT )) != lmx::ELMX_OK )
        return error;
    return lmx::ELMX_OK;
}

lmx::elmx_error value_validator_1( lmx::c_xml_reader & r_reader, const lmx::tc_big_int & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

const lmx::ct_typed_validation_spec< lmx::tc_big_int > validation_spec_1(
                lmx::EXWS_COLLAPSE,     // Whitespace handling
                "",                     // Default value (if any)
                &lexical_validator_1,   // Lexical validator function
                &value_validator_1,     // Value validator function
                &lmx::v_to_o< lmx::tc_big_int >, // Lexical to object converter
                &lmx::o_to_v< lmx::tc_big_int > ); // Object to lexical converter

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const bool & r_value, const char * p_name )
{
    LMX_NO_WARN_UNUSED( r_value );
    LMX_NO_WARN_UNUSED( p_name );
    return lmx::ELMX_OK;
}
#endif // LMX_USER_VALIDATE

lmx::elmx_error lexical_validator_2( lmx::c_xml_reader & r_reader, const std::string & r_value )
{
    lmx::elmx_error error = lmx::ELMX_OK;
    if( ! lmx::is_valid_bool( r_value ) &&
            (error = r_reader.handle_error( lmx::ELMX_VALUE_BAD_FORMAT )) != lmx::ELMX_OK )
        return error;
    return lmx::ELMX_OK;
}

lmx::elmx_error value_validator_2( lmx::c_xml_reader & r_reader, const bool & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

const lmx::ct_typed_validation_spec< bool > validation_spec_2(
                lmx::EXWS_COLLAPSE,     // Whitespace handling
                "",                     // Default value (if any)
                &lexical_validator_2,   // Lexical validator function
                &value_validator_2,     // Value validator function
                &lmx::v_to_o< bool >,   // Lexical to object converter
                &lmx::o_to_v< bool > ); // Object to lexical converter

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tlmx_unicode_string & r_value, const char * p_name )
{
    LMX_NO_WARN_UNUSED( r_value );
    LMX_NO_WARN_UNUSED( p_name );
    return lmx::ELMX_OK;
}
#endif // LMX_USER_VALIDATE

lmx::elmx_error lexical_validator_3( lmx::c_xml_reader & r_reader, const std::string & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

lmx::elmx_error value_validator_3( lmx::c_xml_reader & r_reader, const lmx::tlmx_unicode_string & r_value )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( r_value );
    return lmx::ELMX_OK;
}

const lmx::ct_typed_validation_spec< lmx::tlmx_unicode_string > validation_spec_3(
                lmx::EXWS_PRESERVE,     // Whitespace handling
                "",                     // Default value (if any)
                &lexical_validator_3,   // Lexical validator function
                &value_validator_3,     // Value validator function
                &lmx::v_to_o< lmx::tlmx_unicode_string >, // Lexical to object converter
                &lmx::o_to_v< lmx::tlmx_unicode_string > ); // Object to lexical converter

c_Params::c_Params()
{
    init();
}

c_Params::c_Params( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( r_reader );
}

c_Params::c_Params( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( c_file_name, p_debug_error );
}

#if LMX_WANT_WIDE_FILE_NAMES == 1
c_Params::c_Params( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( c_file_name, p_debug_error );
}
#endif

c_Params::c_Params( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( p_memory, memory_size, p_debug_error );
}

c_Params::c_Params( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( r_string.data(), r_string.size(), p_debug_error );
}

c_Params::c_Params( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    *p_error = lmx::ELMX_UNDEFINED_ERROR;
    init();
    *p_error = unmarshal( r_any_info, p_debug_error );
}

void c_Params::init()
{
}

void c_Params::reset()
{
    c_Params l_temp;
    swap( l_temp );
}

c_Params::~c_Params()
{
}

c_Params::c_Params( const c_Params & r_rhs )
{
    LMX_NO_WARN_UNUSED( r_rhs );
    init();
    m_Values = r_rhs.m_Values;
    m_Booleans = r_rhs.m_Booleans;
    m_ErrorCodes = r_rhs.m_ErrorCodes;
}

void c_Params::swap( c_Params & r_rhs )
{
    m_Values.swap( r_rhs.m_Values );
    m_Booleans.swap( r_rhs.m_Booleans );
    m_ErrorCodes.swap( r_rhs.m_ErrorCodes );
}

c_Params & c_Params::operator = ( const c_Params & r_rhs )
{
    c_Params l_temp( r_rhs );
    swap( l_temp );
    return *this;
}

c_Params * c_Params::clone() const
{
    return new c_Params( *this );
}

const lmx::s_event_map c_Params::c_Values::attr_event_map[] =
{
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

const lmx::s_event_map c_Params::c_Values::elem_event_map[] =
{
    { lmx::EXKN_NONE,   "CameraXPosition",                      15, e_NONE_CameraXPosition },
    { lmx::EXKN_NONE,   "CameraYPosition",                      15, e_NONE_CameraYPosition },
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

c_Params::c_Values::c_Values()
{
    init();
}

void c_Params::c_Values::init()
{
}

void c_Params::c_Values::reset()
{
    c_Params::c_Values l_temp;
    swap( l_temp );
}

c_Params::c_Values::~c_Values()
{
}

c_Params::c_Values::c_Values( const c_Values & r_rhs )
{
    LMX_NO_WARN_UNUSED( r_rhs );
    init();
    m_CameraXPosition = r_rhs.m_CameraXPosition;
    m_CameraYPosition = r_rhs.m_CameraYPosition;
}

void c_Params::c_Values::swap( c_Params::c_Values & r_rhs )
{
    m_CameraXPosition.swap( r_rhs.m_CameraXPosition );
    m_CameraYPosition.swap( r_rhs.m_CameraYPosition );
}

c_Params::c_Values & c_Params::c_Values::operator = ( const c_Params::c_Values & r_rhs )
{
    c_Params::c_Values l_temp( r_rhs );
    swap( l_temp );
    return *this;
}

c_Params::c_Values * c_Params::c_Values::clone() const
{
    return new c_Params::c_Values( *this );
}

bool c_Params::c_Values::is_occurs_ok( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/ ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in );
    if( check_tracker.named_check( ! m_CameraXPosition.is_occurs_ok( true ), "CameraXPosition" ) ||
            check_tracker.named_check( ! m_CameraYPosition.is_occurs_ok( true ), "CameraYPosition" ) )
        return check_tracker.report( __FILE__, __LINE__ );
    return true;
}

bool c_Params::c_Values::check( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/, const char * p_name_in ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in, p_name_in );
    if( ! is_occurs_ok( &check_tracker ) )
        return false;
    return true;
}

lmx::elmx_error c_Params::c_Values::marshal( lmx::c_xml_writer & r_writer, const char * p_name ) const
{
    lmx_assert_is_occurs_ok( is_occurs_ok() );
    lmx::c_xml_writer_local l_xml_writer_local( r_writer );
    r_writer.start_element( p_name );
    lmx::elmx_error error;
    if( (error = marshal_child_elements( r_writer )) != lmx::ELMX_OK )
        return error;
    r_writer.end_element( p_name );
    return lmx::ELMX_OK;
}

lmx::elmx_error c_Params::c_Values::marshal_child_elements( lmx::c_xml_writer & r_writer ) const
{
    LMX_NO_WARN_UNUSED( r_writer );
    lmx::elmx_error error = lmx::ELMX_OK;
    r_writer.marshal_element( "CameraXPosition", m_CameraXPosition, validation_spec_1 );
    r_writer.marshal_element( "CameraYPosition", m_CameraYPosition, validation_spec_1 );
    return error;
}

lmx::elmx_error c_Params::c_Values::unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name )
{
    if( &r_reader.name != &r_name )
        r_reader.name = r_name;
    lmx::elmx_error error;
    class c_Values_unmarshal_helper : public lmx::c_unmarshal_helper
    {
    private:
        c_Params::c_Values * p_parent;
        lmx::c_xml_reader & r_reader;
    public:
        c_Values_unmarshal_helper( c_Params::c_Values * p_parent_in, lmx::c_xml_reader & r_reader_in )
            : lmx::c_unmarshal_helper( r_reader_in ), p_parent( p_parent_in ), r_reader( r_reader_in ) {}
        virtual bool unmarshal_an_attribute( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_attributes( r_reader, p_error ); }
        virtual lmx::elmx_error unmarshal_attributes_check()
            { return p_parent->unmarshal_attributes_check( r_reader ); }
        virtual bool unmarshal_complex_body( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_body( r_reader, p_error ); }
    };
    // If your compiler generates errors concerning access to private/protected methods not allowed, 
    // compile schema using LMX's -no-local-classes flag.
    c_Values_unmarshal_helper helper( this, r_reader );
    error = helper.unmarshal_complex_content( __FILE__, __LINE__ );
    return error;
}

bool c_Params::c_Values::unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( p_error );
    return false;
}

lmx::elmx_error c_Params::c_Values::unmarshal_attributes_check( lmx::c_xml_reader & r_reader )
{
    LMX_NO_WARN_UNUSED( r_reader );
    return lmx::ELMX_OK;
}

bool c_Params::c_Values::unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    r_reader.tokenise( elem_event_map, lmx::EXNT_ELEM );
    if( r_reader.get_current_event() == e_NONE_CameraXPosition )
    {
        r_reader.set_code_line( __LINE__ );
        *p_error = r_reader.unmarshal_child_element( m_CameraXPosition, validation_spec_1, &elem_event_map[0] );
        if( *p_error != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "CameraXPosition", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    if( r_reader.get_current_event() == e_NONE_CameraYPosition )
    {
        r_reader.set_code_line( __LINE__ );
        *p_error = r_reader.unmarshal_child_element( m_CameraYPosition, validation_spec_1, &elem_event_map[1] );
        if( *p_error != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "CameraYPosition", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    return true;
}

const lmx::s_event_map c_Params::c_Booleans::attr_event_map[] =
{
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

const lmx::s_event_map c_Params::c_Booleans::elem_event_map[] =
{
    { lmx::EXKN_NONE,   "MouseLeft",                            9,  e_NONE_MouseLeft },
    { lmx::EXKN_NONE,   "MouseRight",                           10, e_NONE_MouseRight },
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

c_Params::c_Booleans::c_Booleans()
{
    init();
}

void c_Params::c_Booleans::init()
{
}

void c_Params::c_Booleans::reset()
{
    c_Params::c_Booleans l_temp;
    swap( l_temp );
}

c_Params::c_Booleans::~c_Booleans()
{
}

c_Params::c_Booleans::c_Booleans( const c_Booleans & r_rhs )
{
    LMX_NO_WARN_UNUSED( r_rhs );
    init();
    m_MouseLeft = r_rhs.m_MouseLeft;
    m_MouseRight = r_rhs.m_MouseRight;
}

void c_Params::c_Booleans::swap( c_Params::c_Booleans & r_rhs )
{
    m_MouseLeft.swap( r_rhs.m_MouseLeft );
    m_MouseRight.swap( r_rhs.m_MouseRight );
}

c_Params::c_Booleans & c_Params::c_Booleans::operator = ( const c_Params::c_Booleans & r_rhs )
{
    c_Params::c_Booleans l_temp( r_rhs );
    swap( l_temp );
    return *this;
}

c_Params::c_Booleans * c_Params::c_Booleans::clone() const
{
    return new c_Params::c_Booleans( *this );
}

bool c_Params::c_Booleans::is_occurs_ok( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/ ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in );
    if( check_tracker.named_check( ! m_MouseLeft.is_occurs_ok( true ), "MouseLeft" ) ||
            check_tracker.named_check( ! m_MouseRight.is_occurs_ok( true ), "MouseRight" ) )
        return check_tracker.report( __FILE__, __LINE__ );
    return true;
}

bool c_Params::c_Booleans::check( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/, const char * p_name_in ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in, p_name_in );
    if( ! is_occurs_ok( &check_tracker ) )
        return false;
    return true;
}

lmx::elmx_error c_Params::c_Booleans::marshal( lmx::c_xml_writer & r_writer, const char * p_name ) const
{
    lmx_assert_is_occurs_ok( is_occurs_ok() );
    lmx::c_xml_writer_local l_xml_writer_local( r_writer );
    r_writer.start_element( p_name );
    lmx::elmx_error error;
    if( (error = marshal_child_elements( r_writer )) != lmx::ELMX_OK )
        return error;
    r_writer.end_element( p_name );
    return lmx::ELMX_OK;
}

lmx::elmx_error c_Params::c_Booleans::marshal_child_elements( lmx::c_xml_writer & r_writer ) const
{
    LMX_NO_WARN_UNUSED( r_writer );
    lmx::elmx_error error = lmx::ELMX_OK;
    r_writer.marshal_element( "MouseLeft", m_MouseLeft, validation_spec_2 );
    r_writer.marshal_element( "MouseRight", m_MouseRight, validation_spec_2 );
    return error;
}

lmx::elmx_error c_Params::c_Booleans::unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name )
{
    if( &r_reader.name != &r_name )
        r_reader.name = r_name;
    lmx::elmx_error error;
    class c_Booleans_unmarshal_helper : public lmx::c_unmarshal_helper
    {
    private:
        c_Params::c_Booleans * p_parent;
        lmx::c_xml_reader & r_reader;
    public:
        c_Booleans_unmarshal_helper( c_Params::c_Booleans * p_parent_in, lmx::c_xml_reader & r_reader_in )
            : lmx::c_unmarshal_helper( r_reader_in ), p_parent( p_parent_in ), r_reader( r_reader_in ) {}
        virtual bool unmarshal_an_attribute( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_attributes( r_reader, p_error ); }
        virtual lmx::elmx_error unmarshal_attributes_check()
            { return p_parent->unmarshal_attributes_check( r_reader ); }
        virtual bool unmarshal_complex_body( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_body( r_reader, p_error ); }
    };
    // If your compiler generates errors concerning access to private/protected methods not allowed, 
    // compile schema using LMX's -no-local-classes flag.
    c_Booleans_unmarshal_helper helper( this, r_reader );
    error = helper.unmarshal_complex_content( __FILE__, __LINE__ );
    return error;
}

bool c_Params::c_Booleans::unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( p_error );
    return false;
}

lmx::elmx_error c_Params::c_Booleans::unmarshal_attributes_check( lmx::c_xml_reader & r_reader )
{
    LMX_NO_WARN_UNUSED( r_reader );
    return lmx::ELMX_OK;
}

bool c_Params::c_Booleans::unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    r_reader.tokenise( elem_event_map, lmx::EXNT_ELEM );
    if( r_reader.get_current_event() == e_NONE_MouseLeft )
    {
        r_reader.set_code_line( __LINE__ );
        *p_error = r_reader.unmarshal_child_element( m_MouseLeft, validation_spec_2, &elem_event_map[0] );
        if( *p_error != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "MouseLeft", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    if( r_reader.get_current_event() == e_NONE_MouseRight )
    {
        r_reader.set_code_line( __LINE__ );
        *p_error = r_reader.unmarshal_child_element( m_MouseRight, validation_spec_2, &elem_event_map[1] );
        if( *p_error != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "MouseRight", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    return true;
}

const lmx::s_event_map c_Params::c_ErrorCodes::attr_event_map[] =
{
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

const lmx::s_event_map c_Params::c_ErrorCodes::elem_event_map[] =
{
    { lmx::EXKN_NONE,   "Audio",                                5,  e_NONE_Audio },
    { lmx::EXKN_NONE,   "NotFound",                             8,  e_NONE_NotFound },
    { 0,                LMXNULL,                                0,  lmx::EXE_UNKNOWN }
};

c_Params::c_ErrorCodes::c_ErrorCodes()
{
    init();
}

void c_Params::c_ErrorCodes::init()
{
}

void c_Params::c_ErrorCodes::reset()
{
    c_Params::c_ErrorCodes l_temp;
    swap( l_temp );
}

c_Params::c_ErrorCodes::~c_ErrorCodes()
{
}

c_Params::c_ErrorCodes::c_ErrorCodes( const c_ErrorCodes & r_rhs )
{
    LMX_NO_WARN_UNUSED( r_rhs );
    init();
    m_Audio = r_rhs.m_Audio;
    m_NotFound = r_rhs.m_NotFound;
}

void c_Params::c_ErrorCodes::swap( c_Params::c_ErrorCodes & r_rhs )
{
    m_Audio.swap( r_rhs.m_Audio );
    m_NotFound.swap( r_rhs.m_NotFound );
}

c_Params::c_ErrorCodes & c_Params::c_ErrorCodes::operator = ( const c_Params::c_ErrorCodes & r_rhs )
{
    c_Params::c_ErrorCodes l_temp( r_rhs );
    swap( l_temp );
    return *this;
}

c_Params::c_ErrorCodes * c_Params::c_ErrorCodes::clone() const
{
    return new c_Params::c_ErrorCodes( *this );
}

bool c_Params::c_ErrorCodes::is_occurs_ok( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/ ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in );
    if( check_tracker.named_check( ! m_Audio.is_occurs_ok( true ), "Audio" ) ||
            check_tracker.named_check( ! m_NotFound.is_occurs_ok( true ), "NotFound" ) )
        return check_tracker.report( __FILE__, __LINE__ );
    return true;
}

bool c_Params::c_ErrorCodes::check( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/, const char * p_name_in ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in, p_name_in );
    if( ! is_occurs_ok( &check_tracker ) )
        return false;
    return true;
}

lmx::elmx_error c_Params::c_ErrorCodes::marshal( lmx::c_xml_writer & r_writer, const char * p_name ) const
{
    lmx_assert_is_occurs_ok( is_occurs_ok() );
    lmx::c_xml_writer_local l_xml_writer_local( r_writer );
    r_writer.start_element( p_name );
    lmx::elmx_error error;
    if( (error = marshal_child_elements( r_writer )) != lmx::ELMX_OK )
        return error;
    r_writer.end_element( p_name );
    return lmx::ELMX_OK;
}

lmx::elmx_error c_Params::c_ErrorCodes::marshal_child_elements( lmx::c_xml_writer & r_writer ) const
{
    LMX_NO_WARN_UNUSED( r_writer );
    lmx::elmx_error error = lmx::ELMX_OK;
    r_writer.marshal_element( "Audio", m_Audio, validation_spec_3 );
    r_writer.marshal_element( "NotFound", m_NotFound, validation_spec_3 );
    return error;
}

lmx::elmx_error c_Params::c_ErrorCodes::unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name )
{
    if( &r_reader.name != &r_name )
        r_reader.name = r_name;
    lmx::elmx_error error;
    class c_ErrorCodes_unmarshal_helper : public lmx::c_unmarshal_helper
    {
    private:
        c_Params::c_ErrorCodes * p_parent;
        lmx::c_xml_reader & r_reader;
    public:
        c_ErrorCodes_unmarshal_helper( c_Params::c_ErrorCodes * p_parent_in, lmx::c_xml_reader & r_reader_in )
            : lmx::c_unmarshal_helper( r_reader_in ), p_parent( p_parent_in ), r_reader( r_reader_in ) {}
        virtual bool unmarshal_an_attribute( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_attributes( r_reader, p_error ); }
        virtual lmx::elmx_error unmarshal_attributes_check()
            { return p_parent->unmarshal_attributes_check( r_reader ); }
        virtual bool unmarshal_complex_body( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_body( r_reader, p_error ); }
    };
    // If your compiler generates errors concerning access to private/protected methods not allowed, 
    // compile schema using LMX's -no-local-classes flag.
    c_ErrorCodes_unmarshal_helper helper( this, r_reader );
    error = helper.unmarshal_complex_content( __FILE__, __LINE__ );
    return error;
}

bool c_Params::c_ErrorCodes::unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( p_error );
    return false;
}

lmx::elmx_error c_Params::c_ErrorCodes::unmarshal_attributes_check( lmx::c_xml_reader & r_reader )
{
    LMX_NO_WARN_UNUSED( r_reader );
    return lmx::ELMX_OK;
}

bool c_Params::c_ErrorCodes::unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    r_reader.tokenise( elem_event_map, lmx::EXNT_ELEM );
    if( r_reader.get_current_event() == e_NONE_Audio )
    {
        r_reader.set_code_line( __LINE__ );
        *p_error = r_reader.unmarshal_child_element( m_Audio, validation_spec_3, &elem_event_map[0] );
        if( *p_error != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "Audio", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    if( r_reader.get_current_event() == e_NONE_NotFound )
    {
        r_reader.set_code_line( __LINE__ );
        *p_error = r_reader.unmarshal_child_element( m_NotFound, validation_spec_3, &elem_event_map[1] );
        if( *p_error != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "NotFound", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    return true;
}

const c_Params::c_Values & c_Params::get_Values() const
{
    return m_Values.get();
}

c_Params::c_Values & c_Params::get_Values() // For read/write access
{
    return m_Values.get();
}

c_Params::c_Values & c_Params::assign_Values( const c_Values & value )
{
    return (get_Values() = value);
}

c_Params::c_Values & c_Params::assign_Values( c_Values * p )
{
    return m_Values.assign( p );
}

const c_Params::c_Booleans & c_Params::get_Booleans() const
{
    return m_Booleans.get();
}

c_Params::c_Booleans & c_Params::get_Booleans() // For read/write access
{
    return m_Booleans.get();
}

c_Params::c_Booleans & c_Params::assign_Booleans( const c_Booleans & value )
{
    return (get_Booleans() = value);
}

c_Params::c_Booleans & c_Params::assign_Booleans( c_Booleans * p )
{
    return m_Booleans.assign( p );
}

const c_Params::c_ErrorCodes & c_Params::get_ErrorCodes() const
{
    return m_ErrorCodes.get();
}

c_Params::c_ErrorCodes & c_Params::get_ErrorCodes() // For read/write access
{
    return m_ErrorCodes.get();
}

c_Params::c_ErrorCodes & c_Params::assign_ErrorCodes( const c_ErrorCodes & value )
{
    return (get_ErrorCodes() = value);
}

c_Params::c_ErrorCodes & c_Params::assign_ErrorCodes( c_ErrorCodes * p )
{
    return m_ErrorCodes.assign( p );
}

bool c_Params::is_occurs_ok( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/ ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in );
    if( check_tracker.named_check( ! m_Values.is_occurs_ok( true ), "Values" ) ||
            check_tracker.named_check( ! m_Booleans.is_occurs_ok( true ), "Booleans" ) ||
            check_tracker.named_check( ! m_ErrorCodes.is_occurs_ok( true ), "ErrorCodes" ) )
        return check_tracker.report( __FILE__, __LINE__ );
    return true;
}

bool c_Params::check( lmx::c_check_tracker * p_tracker_in /*= LMXNULL*/, const char * p_name_in ) const
{
    lmx::c_check_tracker check_tracker( p_tracker_in, p_name_in );
    if( ! is_occurs_ok( &check_tracker ) )
        return false;
    if( ! m_Values.get().check( &check_tracker, "Values" ) )
        return false;
    if( ! m_Booleans.get().check( &check_tracker, "Booleans" ) )
        return false;
    if( ! m_ErrorCodes.get().check( &check_tracker, "ErrorCodes" ) )
        return false;
    return true;
}

lmx::elmx_error c_Params::marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, c_file_name, p_debug_error );
}

#if defined( _MSC_VER ) && _MSC_VER >= 1400
lmx::elmx_error c_Params::marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, c_file_name, p_debug_error );
}
#endif

lmx::elmx_error c_Params::marshal( std::string * p_string, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, p_string, p_debug_error );
}

lmx::elmx_error c_Params::marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ ) const
{
    return lmx::marshal( *this, r_sos, p_debug_error );
}

lmx::elmx_error c_Params::marshal( lmx::c_xml_writer & r_writer, const char * p_name ) const
{
    lmx_assert_is_occurs_ok( is_occurs_ok() );
    lmx::c_xml_writer_local l_xml_writer_local( r_writer );
    r_writer.start_element( p_name );
    r_writer.conditionally_select_ns_map( ns_map_writer_1 );
    r_writer.conditionally_write_ns_attrs( false );
    lmx::elmx_error error;
    if( (error = marshal_child_elements( r_writer )) != lmx::ELMX_OK )
        return error;
    r_writer.end_element( p_name );
    return lmx::ELMX_OK;
}

lmx::elmx_error c_Params::marshal_child_elements( lmx::c_xml_writer & r_writer ) const
{
    LMX_NO_WARN_UNUSED( r_writer );
    lmx::elmx_error error = lmx::ELMX_OK;
    if( (error = m_Values.get().marshal( r_writer, "Values" )) != lmx::ELMX_OK )
        return error;
    if( (error = m_Booleans.get().marshal( r_writer, "Booleans" )) != lmx::ELMX_OK )
        return error;
    if( (error = m_ErrorCodes.get().marshal( r_writer, "ErrorCodes" )) != lmx::ELMX_OK )
        return error;
    return error;
}

lmx::elmx_error c_Params::unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, c_file_name, p_debug_error );
}

#if LMX_WANT_WIDE_FILE_NAMES == 1
lmx::elmx_error c_Params::unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, c_file_name, p_debug_error );
}
#endif

lmx::elmx_error c_Params::unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, p_memory, memory_size, p_debug_error );
}

lmx::elmx_error c_Params::unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error /*= LMXNULL*/ )
{
    return lmx::unmarshal( this, r_any_info, p_debug_error );
}

lmx::elmx_error c_Params::unmarshal( lmx::c_xml_reader & r_reader )
{
    r_reader.set_code_file( __FILE__ );
    r_reader.set_ns_map( ns_map_reader );
    lmx::elmx_error error = lmx::ELMX_OK;
    lmx::c_xml_reader_local l_reader_local( &r_reader );
    r_reader.get_element_event( &error );
    if( error != lmx::ELMX_OK && (error = r_reader.handle_error( error, __LINE__ )) != lmx::ELMX_OK )
        return error;
    if( (r_reader.get_element_ns_id() != lmx::EXKN_NONE || r_reader.get_local_name() != "Params") && (error = r_reader.handle_error( lmx::ELMX_ELEMENT_NOT_FOUND, "Params", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return error;
    error = unmarshal( r_reader, r_reader.name );
    return error;
}

lmx::elmx_error c_Params::unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name )
{
    if( &r_reader.name != &r_name )
        r_reader.name = r_name;
    lmx::elmx_error error;
    class c_Params_unmarshal_helper : public lmx::c_unmarshal_helper
    {
    private:
        c_Params * p_parent;
        lmx::c_xml_reader & r_reader;
    public:
        c_Params_unmarshal_helper( c_Params * p_parent_in, lmx::c_xml_reader & r_reader_in )
            : lmx::c_unmarshal_helper( r_reader_in ), p_parent( p_parent_in ), r_reader( r_reader_in ) {}
        virtual bool unmarshal_an_attribute( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_attributes( r_reader, p_error ); }
        virtual lmx::elmx_error unmarshal_attributes_check()
            { return p_parent->unmarshal_attributes_check( r_reader ); }
        virtual bool unmarshal_complex_body( lmx::elmx_error * p_error )
            { return p_parent->unmarshal_body( r_reader, p_error ); }
    };
    // If your compiler generates errors concerning access to private/protected methods not allowed, 
    // compile schema using LMX's -no-local-classes flag.
    c_Params_unmarshal_helper helper( this, r_reader );
    error = helper.unmarshal_complex_content( __FILE__, __LINE__ );
    return error;
}

bool c_Params::unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    LMX_NO_WARN_UNUSED( r_reader );
    LMX_NO_WARN_UNUSED( p_error );
    return false;
}

lmx::elmx_error c_Params::unmarshal_attributes_check( lmx::c_xml_reader & r_reader )
{
    LMX_NO_WARN_UNUSED( r_reader );
    return lmx::ELMX_OK;
}

bool c_Params::unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error )
{
    r_reader.tokenise( elem_event_map, lmx::EXNT_ELEM );
    if( r_reader.get_current_event() == e_NONE_Values )
    {
        r_reader.set_code_line( __LINE__ );
        if( (*p_error = m_Values.get().unmarshal( r_reader, r_reader.name ) ) != lmx::ELMX_OK )
            return false;
        r_reader.get_element_event( &elem_event_map[0], p_error );
        if( *p_error != lmx::ELMX_OK && (*p_error = r_reader.handle_error( *p_error, __LINE__ )) != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "Values", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    if( r_reader.get_current_event() == e_NONE_Booleans )
    {
        r_reader.set_code_line( __LINE__ );
        if( (*p_error = m_Booleans.get().unmarshal( r_reader, r_reader.name ) ) != lmx::ELMX_OK )
            return false;
        r_reader.get_element_event( &elem_event_map[1], p_error );
        if( *p_error != lmx::ELMX_OK && (*p_error = r_reader.handle_error( *p_error, __LINE__ )) != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "Booleans", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    if( r_reader.get_current_event() == e_NONE_ErrorCodes )
    {
        r_reader.set_code_line( __LINE__ );
        if( (*p_error = m_ErrorCodes.get().unmarshal( r_reader, r_reader.name ) ) != lmx::ELMX_OK )
            return false;
        r_reader.get_element_event( &elem_event_map[2], p_error );
        if( *p_error != lmx::ELMX_OK && (*p_error = r_reader.handle_error( *p_error, __LINE__ )) != lmx::ELMX_OK )
            return false;
    }
    else if( (*p_error = r_reader.handle_error( lmx::ELMX_MANDATORY_ELEMENT_MISSING, "ErrorCodes", __FILE__, __LINE__ )) != lmx::ELMX_OK )
        return false;
    return true;
}

