//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2020 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// Generated: Wed Feb 26 23:16:04 2020
// TargetNamepsace: 
// Source File: C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd
// LMX Version: 7.4
// Compile options: "C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd"
//      "C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\output\params"
//      

// *********** Code generated in evaluation mode ************
// *********** Must not be supplied to a customer ***********


#ifndef __PARAMS_H__
#define __PARAMS_H__

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (push)
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#endif

#include "lmxuser.h"

// To help MS intellisense
#ifndef LMX_GDECL
#define LMX_GDECL
#endif

LMX_GDECL extern const lmx::s_ns_map ns_map_reader[];
LMX_GDECL extern const lmx::s_ns_map ns_map_writer_1[];

enum
{
    e_error = lmx::EXE_LAST_XML_EVENT,
    e_NONE_Params,
    e_NONE_Values,
    e_NONE_CameraXPosition,
    e_NONE_CameraYPosition,
    e_NONE_Booleans,
    e_NONE_MouseLeft,
    e_NONE_MouseRight,
    e_NONE_ErrorCodes,
    e_NONE_Audio,
    e_NONE_NotFound,
    e_any
};

enum elmx_enums
{
    e_e_unknown
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tc_big_int &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const bool &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

//-----------------------------------------------------------------------------
// Generated in Evaluation Mode by Codalogic LMX C++ XML Databinder.           |
//     Upgrade to Professional Edition to enable full functionality.           |
//         Visit http://codalogic.com/lmx/buy.php                              |
//-----------------------------------------------------------------------------

// From: C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd(4)
class c_Params
{
public:
    //-----------------------------------------------------------------------------
    // Generated in Evaluation Mode by Codalogic LMX C++ XML Databinder.           |
    //     Upgrade to Professional Edition to enable full functionality.           |
    //         Visit http://codalogic.com/lmx/buy.php                              |
    //-----------------------------------------------------------------------------

    // From: C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd(7)
    class c_Values
    {
    private:
        // Element(s)
        lmx::ct_simple_non_pod_single< lmx::tc_big_int > m_CameraXPosition;
        lmx::ct_simple_non_pod_single< lmx::tc_big_int > m_CameraYPosition;

        static const lmx::s_event_map attr_event_map[];
        static const lmx::s_event_map elem_event_map[];

    public:
        LMX_GDECL c_Values();
        LMX_GDECL c_Values( const c_Values & r_rhs );
        LMX_GDECL c_Values & operator = ( const c_Values & r_rhs );
        LMX_GDECL virtual c_Values * clone() const;
        LMX_GDECL void swap( c_Values & r_rhs );
        LMX_GDECL virtual ~c_Values();

        // Element(s)

        //    CameraXPosition --> xs:integer
        LMX_GDECL const lmx::tc_big_int & get_CameraXPosition() const { return m_CameraXPosition.get(); }
        LMX_GDECL lmx::tc_big_int & get_CameraXPosition() { return m_CameraXPosition.get(); }
        LMX_GDECL lmx::elmx_error set_CameraXPosition( const lmx::tc_big_int & value ) { return m_CameraXPosition.set( value ); }

        //    CameraYPosition --> xs:integer
        LMX_GDECL const lmx::tc_big_int & get_CameraYPosition() const { return m_CameraYPosition.get(); }
        LMX_GDECL lmx::tc_big_int & get_CameraYPosition() { return m_CameraYPosition.get(); }
        LMX_GDECL lmx::elmx_error set_CameraYPosition( const lmx::tc_big_int & value ) { return m_CameraYPosition.set( value ); }

        LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

        LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Values" ) const;

        // General marshal/unmarshal functions
        LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Values" ) const;
        LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
        LMX_GDECL void reset();

    protected:
        LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
        LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
        LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
        LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
        LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

    private:
        LMX_GDECL void init();
        LMX_GDECL void release();
    };

    //-----------------------------------------------------------------------------
    // Generated in Evaluation Mode by Codalogic LMX C++ XML Databinder.           |
    //     Upgrade to Professional Edition to enable full functionality.           |
    //         Visit http://codalogic.com/lmx/buy.php                              |
    //-----------------------------------------------------------------------------

    // From: C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd(15)
    class c_Booleans
    {
    private:
        // Element(s)
        lmx::ct_simple_pod_single< bool > m_MouseLeft;
        lmx::ct_simple_pod_single< bool > m_MouseRight;

        static const lmx::s_event_map attr_event_map[];
        static const lmx::s_event_map elem_event_map[];

    public:
        LMX_GDECL c_Booleans();
        LMX_GDECL c_Booleans( const c_Booleans & r_rhs );
        LMX_GDECL c_Booleans & operator = ( const c_Booleans & r_rhs );
        LMX_GDECL virtual c_Booleans * clone() const;
        LMX_GDECL void swap( c_Booleans & r_rhs );
        LMX_GDECL virtual ~c_Booleans();

        // Element(s)

        //    MouseLeft --> xs:boolean
        LMX_GDECL const bool & get_MouseLeft() const { return m_MouseLeft.get(); }
        LMX_GDECL lmx::elmx_error set_MouseLeft( const bool & value ) { return m_MouseLeft.set( value ); }

        //    MouseRight --> xs:boolean
        LMX_GDECL const bool & get_MouseRight() const { return m_MouseRight.get(); }
        LMX_GDECL lmx::elmx_error set_MouseRight( const bool & value ) { return m_MouseRight.set( value ); }

        LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

        LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Booleans" ) const;

        // General marshal/unmarshal functions
        LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Booleans" ) const;
        LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
        LMX_GDECL void reset();

    protected:
        LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
        LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
        LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
        LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
        LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

    private:
        LMX_GDECL void init();
        LMX_GDECL void release();
    };

    //-----------------------------------------------------------------------------
    // Generated in Evaluation Mode by Codalogic LMX C++ XML Databinder.           |
    //     Upgrade to Professional Edition to enable full functionality.           |
    //         Visit http://codalogic.com/lmx/buy.php                              |
    //-----------------------------------------------------------------------------

    // From: C:\Users\utente\Documents\github rattlesmake\centurion\centurion-utils\lmx\params.xsd(23)
    class c_ErrorCodes
    {
    private:
        // Element(s)
        lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_Audio;
        lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_NotFound;

        static const lmx::s_event_map attr_event_map[];
        static const lmx::s_event_map elem_event_map[];

    public:
        LMX_GDECL c_ErrorCodes();
        LMX_GDECL c_ErrorCodes( const c_ErrorCodes & r_rhs );
        LMX_GDECL c_ErrorCodes & operator = ( const c_ErrorCodes & r_rhs );
        LMX_GDECL virtual c_ErrorCodes * clone() const;
        LMX_GDECL void swap( c_ErrorCodes & r_rhs );
        LMX_GDECL virtual ~c_ErrorCodes();

        // Element(s)

        //    Audio --> xs:string
        LMX_GDECL const lmx::tlmx_unicode_string & get_Audio() const { return m_Audio.get(); }
        LMX_GDECL lmx::elmx_error set_Audio( const lmx::tlmx_unicode_string & value ) { return m_Audio.set( value ); }

        //    NotFound --> xs:string
        LMX_GDECL const lmx::tlmx_unicode_string & get_NotFound() const { return m_NotFound.get(); }
        LMX_GDECL lmx::elmx_error set_NotFound( const lmx::tlmx_unicode_string & value ) { return m_NotFound.set( value ); }

        LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

        LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ErrorCodes" ) const;

        // General marshal/unmarshal functions
        LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ErrorCodes" ) const;
        LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
        LMX_GDECL void reset();

    protected:
        LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
        LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
        LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
        LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
        LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

    private:
        LMX_GDECL void init();
        LMX_GDECL void release();
    };


private:
    // Element(s)
    lmx::ct_complex_single< c_Values > m_Values;
    lmx::ct_complex_single< c_Booleans > m_Booleans;
    lmx::ct_complex_single< c_ErrorCodes > m_ErrorCodes;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];

public:
    LMX_GDECL c_Params();
    LMX_GDECL c_Params( const c_Params & r_rhs );
    LMX_GDECL c_Params & operator = ( const c_Params & r_rhs );
    LMX_GDECL virtual c_Params * clone() const;
    LMX_GDECL void swap( c_Params & r_rhs );
    LMX_GDECL c_Params( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_Params( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_Params( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_Params( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_Params( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_Params( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_Params();

    // Element(s)

    //    Values --> Values
    LMX_GDECL const c_Values & get_Values() const;
    LMX_GDECL c_Values & get_Values(); // For read/write access
    LMX_GDECL c_Values & assign_Values( const c_Values & value );
    LMX_GDECL c_Values & assign_Values( c_Values * p );

    //    Booleans --> Booleans
    LMX_GDECL const c_Booleans & get_Booleans() const;
    LMX_GDECL c_Booleans & get_Booleans(); // For read/write access
    LMX_GDECL c_Booleans & assign_Booleans( const c_Booleans & value );
    LMX_GDECL c_Booleans & assign_Booleans( c_Booleans * p );

    //    ErrorCodes --> ErrorCodes
    LMX_GDECL const c_ErrorCodes & get_ErrorCodes() const;
    LMX_GDECL c_ErrorCodes & get_ErrorCodes(); // For read/write access
    LMX_GDECL c_ErrorCodes & assign_ErrorCodes( const c_ErrorCodes & value );
    LMX_GDECL c_ErrorCodes & assign_ErrorCodes( c_ErrorCodes * p );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Params" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return ns_map_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Params" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (pop)  // Restore disabled warnings
#endif


#endif      // End of include guard
