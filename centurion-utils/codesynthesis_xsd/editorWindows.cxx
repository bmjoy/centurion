// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "editorWindows.hxx"

// c_editorWindows
// 

const c_editorWindows::c_editorWindow_sequence& c_editorWindows::
c_editorWindow () const
{
  return this->c_editorWindow_;
}

c_editorWindows::c_editorWindow_sequence& c_editorWindows::
c_editorWindow ()
{
  return this->c_editorWindow_;
}

void c_editorWindows::
c_editorWindow (const c_editorWindow_sequence& s)
{
  this->c_editorWindow_ = s;
}


// c_editorWindow
// 

const c_editorWindow::conditionScript_type& c_editorWindow::
conditionScript () const
{
  return this->conditionScript_.get ();
}

c_editorWindow::conditionScript_type& c_editorWindow::
conditionScript ()
{
  return this->conditionScript_.get ();
}

void c_editorWindow::
conditionScript (const conditionScript_type& x)
{
  this->conditionScript_.set (x);
}

void c_editorWindow::
conditionScript (::std::auto_ptr< conditionScript_type > x)
{
  this->conditionScript_.set (x);
}

const c_editorWindow::openingScript_type& c_editorWindow::
openingScript () const
{
  return this->openingScript_.get ();
}

c_editorWindow::openingScript_type& c_editorWindow::
openingScript ()
{
  return this->openingScript_.get ();
}

void c_editorWindow::
openingScript (const openingScript_type& x)
{
  this->openingScript_.set (x);
}

void c_editorWindow::
openingScript (::std::auto_ptr< openingScript_type > x)
{
  this->openingScript_.set (x);
}

const c_editorWindow::simpleText_sequence& c_editorWindow::
simpleText () const
{
  return this->simpleText_;
}

c_editorWindow::simpleText_sequence& c_editorWindow::
simpleText ()
{
  return this->simpleText_;
}

void c_editorWindow::
simpleText (const simpleText_sequence& s)
{
  this->simpleText_ = s;
}

const c_editorWindow::scriptText_optional& c_editorWindow::
scriptText () const
{
  return this->scriptText_;
}

c_editorWindow::scriptText_optional& c_editorWindow::
scriptText ()
{
  return this->scriptText_;
}

void c_editorWindow::
scriptText (const scriptText_type& x)
{
  this->scriptText_.set (x);
}

void c_editorWindow::
scriptText (const scriptText_optional& x)
{
  this->scriptText_ = x;
}

void c_editorWindow::
scriptText (::std::auto_ptr< scriptText_type > x)
{
  this->scriptText_.set (x);
}

const c_editorWindow::image_sequence& c_editorWindow::
image () const
{
  return this->image_;
}

c_editorWindow::image_sequence& c_editorWindow::
image ()
{
  return this->image_;
}

void c_editorWindow::
image (const image_sequence& s)
{
  this->image_ = s;
}

const c_editorWindow::button_sequence& c_editorWindow::
button () const
{
  return this->button_;
}

c_editorWindow::button_sequence& c_editorWindow::
button ()
{
  return this->button_;
}

void c_editorWindow::
button (const button_sequence& s)
{
  this->button_ = s;
}

const c_editorWindow::textList_sequence& c_editorWindow::
textList () const
{
  return this->textList_;
}

c_editorWindow::textList_sequence& c_editorWindow::
textList ()
{
  return this->textList_;
}

void c_editorWindow::
textList (const textList_sequence& s)
{
  this->textList_ = s;
}

const c_editorWindow::id_type& c_editorWindow::
id () const
{
  return this->id_.get ();
}

c_editorWindow::id_type& c_editorWindow::
id ()
{
  return this->id_.get ();
}

void c_editorWindow::
id (const id_type& x)
{
  this->id_.set (x);
}

const c_editorWindow::name_type& c_editorWindow::
name () const
{
  return this->name_.get ();
}

c_editorWindow::name_type& c_editorWindow::
name ()
{
  return this->name_.get ();
}

void c_editorWindow::
name (const name_type& x)
{
  this->name_.set (x);
}

void c_editorWindow::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const c_editorWindow::iframe_type& c_editorWindow::
iframe () const
{
  return this->iframe_.get ();
}

c_editorWindow::iframe_type& c_editorWindow::
iframe ()
{
  return this->iframe_.get ();
}

void c_editorWindow::
iframe (const iframe_type& x)
{
  this->iframe_.set (x);
}

void c_editorWindow::
iframe (::std::auto_ptr< iframe_type > x)
{
  this->iframe_.set (x);
}

const c_editorWindow::x_type& c_editorWindow::
x () const
{
  return this->x_.get ();
}

c_editorWindow::x_type& c_editorWindow::
x ()
{
  return this->x_.get ();
}

void c_editorWindow::
x (const x_type& x)
{
  this->x_.set (x);
}

const c_editorWindow::y_type& c_editorWindow::
y () const
{
  return this->y_.get ();
}

c_editorWindow::y_type& c_editorWindow::
y ()
{
  return this->y_.get ();
}

void c_editorWindow::
y (const y_type& x)
{
  this->y_.set (x);
}

const c_editorWindow::width_type& c_editorWindow::
width () const
{
  return this->width_.get ();
}

c_editorWindow::width_type& c_editorWindow::
width ()
{
  return this->width_.get ();
}

void c_editorWindow::
width (const width_type& x)
{
  this->width_.set (x);
}

const c_editorWindow::height_type& c_editorWindow::
height () const
{
  return this->height_.get ();
}

c_editorWindow::height_type& c_editorWindow::
height ()
{
  return this->height_.get ();
}

void c_editorWindow::
height (const height_type& x)
{
  this->height_.set (x);
}

const c_editorWindow::isOpened_type& c_editorWindow::
isOpened () const
{
  return this->isOpened_.get ();
}

c_editorWindow::isOpened_type& c_editorWindow::
isOpened ()
{
  return this->isOpened_.get ();
}

void c_editorWindow::
isOpened (const isOpened_type& x)
{
  this->isOpened_.set (x);
}


// conditionScript
// 

const conditionScript::function_type& conditionScript::
function () const
{
  return this->function_.get ();
}

conditionScript::function_type& conditionScript::
function ()
{
  return this->function_.get ();
}

void conditionScript::
function (const function_type& x)
{
  this->function_.set (x);
}

void conditionScript::
function (::std::auto_ptr< function_type > x)
{
  this->function_.set (x);
}


// simpleText
// 

const simpleText::color_type& simpleText::
color () const
{
  return this->color_.get ();
}

simpleText::color_type& simpleText::
color ()
{
  return this->color_.get ();
}

void simpleText::
color (const color_type& x)
{
  this->color_.set (x);
}

void simpleText::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const simpleText::text_type& simpleText::
text () const
{
  return this->text_.get ();
}

simpleText::text_type& simpleText::
text ()
{
  return this->text_.get ();
}

void simpleText::
text (const text_type& x)
{
  this->text_.set (x);
}

void simpleText::
text (::std::auto_ptr< text_type > x)
{
  this->text_.set (x);
}

const simpleText::xOffset_type& simpleText::
xOffset () const
{
  return this->xOffset_.get ();
}

simpleText::xOffset_type& simpleText::
xOffset ()
{
  return this->xOffset_.get ();
}

void simpleText::
xOffset (const xOffset_type& x)
{
  this->xOffset_.set (x);
}

const simpleText::yOffset_type& simpleText::
yOffset () const
{
  return this->yOffset_.get ();
}

simpleText::yOffset_type& simpleText::
yOffset ()
{
  return this->yOffset_.get ();
}

void simpleText::
yOffset (const yOffset_type& x)
{
  this->yOffset_.set (x);
}

const simpleText::font_type& simpleText::
font () const
{
  return this->font_.get ();
}

simpleText::font_type& simpleText::
font ()
{
  return this->font_.get ();
}

void simpleText::
font (const font_type& x)
{
  this->font_.set (x);
}

void simpleText::
font (::std::auto_ptr< font_type > x)
{
  this->font_.set (x);
}


// scriptText
// 

const scriptText::color_type& scriptText::
color () const
{
  return this->color_.get ();
}

scriptText::color_type& scriptText::
color ()
{
  return this->color_.get ();
}

void scriptText::
color (const color_type& x)
{
  this->color_.set (x);
}

void scriptText::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const scriptText::src_type& scriptText::
src () const
{
  return this->src_.get ();
}

scriptText::src_type& scriptText::
src ()
{
  return this->src_.get ();
}

void scriptText::
src (const src_type& x)
{
  this->src_.set (x);
}

void scriptText::
src (::std::auto_ptr< src_type > x)
{
  this->src_.set (x);
}

const scriptText::xOffset_type& scriptText::
xOffset () const
{
  return this->xOffset_.get ();
}

scriptText::xOffset_type& scriptText::
xOffset ()
{
  return this->xOffset_.get ();
}

void scriptText::
xOffset (const xOffset_type& x)
{
  this->xOffset_.set (x);
}

const scriptText::yOffset_type& scriptText::
yOffset () const
{
  return this->yOffset_.get ();
}

scriptText::yOffset_type& scriptText::
yOffset ()
{
  return this->yOffset_.get ();
}

void scriptText::
yOffset (const yOffset_type& x)
{
  this->yOffset_.set (x);
}

const scriptText::font_type& scriptText::
font () const
{
  return this->font_.get ();
}

scriptText::font_type& scriptText::
font ()
{
  return this->font_.get ();
}

void scriptText::
font (const font_type& x)
{
  this->font_.set (x);
}

void scriptText::
font (::std::auto_ptr< font_type > x)
{
  this->font_.set (x);
}


// image
// 

const image::image_name_type& image::
image_name () const
{
  return this->image_name_.get ();
}

image::image_name_type& image::
image_name ()
{
  return this->image_name_.get ();
}

void image::
image_name (const image_name_type& x)
{
  this->image_name_.set (x);
}

void image::
image_name (::std::auto_ptr< image_name_type > x)
{
  this->image_name_.set (x);
}

const image::xOffset_type& image::
xOffset () const
{
  return this->xOffset_.get ();
}

image::xOffset_type& image::
xOffset ()
{
  return this->xOffset_.get ();
}

void image::
xOffset (const xOffset_type& x)
{
  this->xOffset_.set (x);
}

const image::yOffset_type& image::
yOffset () const
{
  return this->yOffset_.get ();
}

image::yOffset_type& image::
yOffset ()
{
  return this->yOffset_.get ();
}

void image::
yOffset (const yOffset_type& x)
{
  this->yOffset_.set (x);
}

const image::onclick_type& image::
onclick () const
{
  return this->onclick_.get ();
}

image::onclick_type& image::
onclick ()
{
  return this->onclick_.get ();
}

void image::
onclick (const onclick_type& x)
{
  this->onclick_.set (x);
}

void image::
onclick (::std::auto_ptr< onclick_type > x)
{
  this->onclick_.set (x);
}


// button
// 

const button::name_type& button::
name () const
{
  return this->name_.get ();
}

button::name_type& button::
name ()
{
  return this->name_.get ();
}

void button::
name (const name_type& x)
{
  this->name_.set (x);
}

void button::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const button::image_name_type& button::
image_name () const
{
  return this->image_name_.get ();
}

button::image_name_type& button::
image_name ()
{
  return this->image_name_.get ();
}

void button::
image_name (const image_name_type& x)
{
  this->image_name_.set (x);
}

void button::
image_name (::std::auto_ptr< image_name_type > x)
{
  this->image_name_.set (x);
}

const button::xOffset_type& button::
xOffset () const
{
  return this->xOffset_.get ();
}

button::xOffset_type& button::
xOffset ()
{
  return this->xOffset_.get ();
}

void button::
xOffset (const xOffset_type& x)
{
  this->xOffset_.set (x);
}

const button::yOffset_type& button::
yOffset () const
{
  return this->yOffset_.get ();
}

button::yOffset_type& button::
yOffset ()
{
  return this->yOffset_.get ();
}

void button::
yOffset (const yOffset_type& x)
{
  this->yOffset_.set (x);
}

const button::onclick_type& button::
onclick () const
{
  return this->onclick_.get ();
}

button::onclick_type& button::
onclick ()
{
  return this->onclick_.get ();
}

void button::
onclick (const onclick_type& x)
{
  this->onclick_.set (x);
}

void button::
onclick (::std::auto_ptr< onclick_type > x)
{
  this->onclick_.set (x);
}


// textList
// 

const textList::text_type& textList::
text () const
{
  return this->text_.get ();
}

textList::text_type& textList::
text ()
{
  return this->text_.get ();
}

void textList::
text (const text_type& x)
{
  this->text_.set (x);
}

void textList::
text (::std::auto_ptr< text_type > x)
{
  this->text_.set (x);
}

const textList::text_background_type& textList::
text_background () const
{
  return this->text_background_.get ();
}

textList::text_background_type& textList::
text_background ()
{
  return this->text_background_.get ();
}

void textList::
text_background (const text_background_type& x)
{
  this->text_background_.set (x);
}

void textList::
text_background (::std::auto_ptr< text_background_type > x)
{
  this->text_background_.set (x);
}

const textList::textListId_type& textList::
textListId () const
{
  return this->textListId_.get ();
}

textList::textListId_type& textList::
textListId ()
{
  return this->textListId_.get ();
}

void textList::
textListId (const textListId_type& x)
{
  this->textListId_.set (x);
}

const textList::xOffset_type& textList::
xOffset () const
{
  return this->xOffset_.get ();
}

textList::xOffset_type& textList::
xOffset ()
{
  return this->xOffset_.get ();
}

void textList::
xOffset (const xOffset_type& x)
{
  this->xOffset_.set (x);
}

const textList::yOffset_type& textList::
yOffset () const
{
  return this->yOffset_.get ();
}

textList::yOffset_type& textList::
yOffset ()
{
  return this->yOffset_.get ();
}

void textList::
yOffset (const yOffset_type& x)
{
  this->yOffset_.set (x);
}


// color
// 

const color::r_type& color::
r () const
{
  return this->r_.get ();
}

color::r_type& color::
r ()
{
  return this->r_.get ();
}

void color::
r (const r_type& x)
{
  this->r_.set (x);
}

const color::g_type& color::
g () const
{
  return this->g_.get ();
}

color::g_type& color::
g ()
{
  return this->g_.get ();
}

void color::
g (const g_type& x)
{
  this->g_.set (x);
}

const color::b_type& color::
b () const
{
  return this->b_.get ();
}

color::b_type& color::
b ()
{
  return this->b_.get ();
}

void color::
b (const b_type& x)
{
  this->b_.set (x);
}


// text
// 

const text::font_type& text::
font () const
{
  return this->font_.get ();
}

text::font_type& text::
font ()
{
  return this->font_.get ();
}

void text::
font (const font_type& x)
{
  this->font_.set (x);
}

void text::
font (::std::auto_ptr< font_type > x)
{
  this->font_.set (x);
}

const text::r_type& text::
r () const
{
  return this->r_.get ();
}

text::r_type& text::
r ()
{
  return this->r_.get ();
}

void text::
r (const r_type& x)
{
  this->r_.set (x);
}

const text::g_type& text::
g () const
{
  return this->g_.get ();
}

text::g_type& text::
g ()
{
  return this->g_.get ();
}

void text::
g (const g_type& x)
{
  this->g_.set (x);
}

const text::b_type& text::
b () const
{
  return this->b_.get ();
}

text::b_type& text::
b ()
{
  return this->b_.get ();
}

void text::
b (const b_type& x)
{
  this->b_.set (x);
}


// text_background
// 

const text_background::r_type& text_background::
r () const
{
  return this->r_.get ();
}

text_background::r_type& text_background::
r ()
{
  return this->r_.get ();
}

void text_background::
r (const r_type& x)
{
  this->r_.set (x);
}

const text_background::g_type& text_background::
g () const
{
  return this->g_.get ();
}

text_background::g_type& text_background::
g ()
{
  return this->g_.get ();
}

void text_background::
g (const g_type& x)
{
  this->g_.set (x);
}

const text_background::b_type& text_background::
b () const
{
  return this->b_.get ();
}

text_background::b_type& text_background::
b ()
{
  return this->b_.get ();
}

void text_background::
b (const b_type& x)
{
  this->b_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// c_editorWindows
//

c_editorWindows::
c_editorWindows ()
: ::xml_schema::type (),
  c_editorWindow_ (this)
{
}

c_editorWindows::
c_editorWindows (const c_editorWindows& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  c_editorWindow_ (x.c_editorWindow_, f, this)
{
}

c_editorWindows::
c_editorWindows (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  c_editorWindow_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void c_editorWindows::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // c_editorWindow
    //
    if (n.name () == "c_editorWindow" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< c_editorWindow_type > r (
        c_editorWindow_traits::create (i, f, this));

      this->c_editorWindow_.push_back (r);
      continue;
    }

    break;
  }
}

c_editorWindows* c_editorWindows::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class c_editorWindows (*this, f, c);
}

c_editorWindows& c_editorWindows::
operator= (const c_editorWindows& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->c_editorWindow_ = x.c_editorWindow_;
  }

  return *this;
}

c_editorWindows::
~c_editorWindows ()
{
}

// c_editorWindow
//

c_editorWindow::
c_editorWindow (const conditionScript_type& conditionScript,
                const openingScript_type& openingScript,
                const id_type& id,
                const name_type& name,
                const iframe_type& iframe,
                const x_type& x,
                const y_type& y,
                const width_type& width,
                const height_type& height,
                const isOpened_type& isOpened)
: ::xml_schema::type (),
  conditionScript_ (conditionScript, this),
  openingScript_ (openingScript, this),
  simpleText_ (this),
  scriptText_ (this),
  image_ (this),
  button_ (this),
  textList_ (this),
  id_ (id, this),
  name_ (name, this),
  iframe_ (iframe, this),
  x_ (x, this),
  y_ (y, this),
  width_ (width, this),
  height_ (height, this),
  isOpened_ (isOpened, this)
{
}

c_editorWindow::
c_editorWindow (::std::auto_ptr< conditionScript_type > conditionScript,
                const openingScript_type& openingScript,
                const id_type& id,
                const name_type& name,
                const iframe_type& iframe,
                const x_type& x,
                const y_type& y,
                const width_type& width,
                const height_type& height,
                const isOpened_type& isOpened)
: ::xml_schema::type (),
  conditionScript_ (conditionScript, this),
  openingScript_ (openingScript, this),
  simpleText_ (this),
  scriptText_ (this),
  image_ (this),
  button_ (this),
  textList_ (this),
  id_ (id, this),
  name_ (name, this),
  iframe_ (iframe, this),
  x_ (x, this),
  y_ (y, this),
  width_ (width, this),
  height_ (height, this),
  isOpened_ (isOpened, this)
{
}

c_editorWindow::
c_editorWindow (const c_editorWindow& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  conditionScript_ (x.conditionScript_, f, this),
  openingScript_ (x.openingScript_, f, this),
  simpleText_ (x.simpleText_, f, this),
  scriptText_ (x.scriptText_, f, this),
  image_ (x.image_, f, this),
  button_ (x.button_, f, this),
  textList_ (x.textList_, f, this),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  iframe_ (x.iframe_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  width_ (x.width_, f, this),
  height_ (x.height_, f, this),
  isOpened_ (x.isOpened_, f, this)
{
}

c_editorWindow::
c_editorWindow (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  conditionScript_ (this),
  openingScript_ (this),
  simpleText_ (this),
  scriptText_ (this),
  image_ (this),
  button_ (this),
  textList_ (this),
  id_ (this),
  name_ (this),
  iframe_ (this),
  x_ (this),
  y_ (this),
  width_ (this),
  height_ (this),
  isOpened_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void c_editorWindow::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // conditionScript
    //
    if (n.name () == "conditionScript" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< conditionScript_type > r (
        conditionScript_traits::create (i, f, this));

      if (!conditionScript_.present ())
      {
        this->conditionScript_.set (r);
        continue;
      }
    }

    // openingScript
    //
    if (n.name () == "openingScript" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< openingScript_type > r (
        openingScript_traits::create (i, f, this));

      if (!openingScript_.present ())
      {
        this->openingScript_.set (r);
        continue;
      }
    }

    // simpleText
    //
    if (n.name () == "simpleText" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< simpleText_type > r (
        simpleText_traits::create (i, f, this));

      this->simpleText_.push_back (r);
      continue;
    }

    // scriptText
    //
    if (n.name () == "scriptText" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scriptText_type > r (
        scriptText_traits::create (i, f, this));

      if (!this->scriptText_)
      {
        this->scriptText_.set (r);
        continue;
      }
    }

    // image
    //
    if (n.name () == "image" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_type > r (
        image_traits::create (i, f, this));

      this->image_.push_back (r);
      continue;
    }

    // button
    //
    if (n.name () == "button" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< button_type > r (
        button_traits::create (i, f, this));

      this->button_.push_back (r);
      continue;
    }

    // textList
    //
    if (n.name () == "textList" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< textList_type > r (
        textList_traits::create (i, f, this));

      this->textList_.push_back (r);
      continue;
    }

    break;
  }

  if (!conditionScript_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "conditionScript",
      "");
  }

  if (!openingScript_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "openingScript",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "iframe" && n.namespace_ ().empty ())
    {
      this->iframe_.set (iframe_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "isOpened" && n.namespace_ ().empty ())
    {
      this->isOpened_.set (isOpened_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!iframe_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iframe",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }

  if (!isOpened_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "isOpened",
      "");
  }
}

c_editorWindow* c_editorWindow::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class c_editorWindow (*this, f, c);
}

c_editorWindow& c_editorWindow::
operator= (const c_editorWindow& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->conditionScript_ = x.conditionScript_;
    this->openingScript_ = x.openingScript_;
    this->simpleText_ = x.simpleText_;
    this->scriptText_ = x.scriptText_;
    this->image_ = x.image_;
    this->button_ = x.button_;
    this->textList_ = x.textList_;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->iframe_ = x.iframe_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->width_ = x.width_;
    this->height_ = x.height_;
    this->isOpened_ = x.isOpened_;
  }

  return *this;
}

c_editorWindow::
~c_editorWindow ()
{
}

// conditionScript
//

conditionScript::
conditionScript (const function_type& function)
: ::xml_schema::string (),
  function_ (function, this)
{
}

conditionScript::
conditionScript (const char* _xsd_string_base,
                 const function_type& function)
: ::xml_schema::string (_xsd_string_base),
  function_ (function, this)
{
}

conditionScript::
conditionScript (const ::std::string& _xsd_string_base,
                 const function_type& function)
: ::xml_schema::string (_xsd_string_base),
  function_ (function, this)
{
}

conditionScript::
conditionScript (const ::xml_schema::string& _xsd_string_base,
                 const function_type& function)
: ::xml_schema::string (_xsd_string_base),
  function_ (function, this)
{
}

conditionScript::
conditionScript (const conditionScript& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  function_ (x.function_, f, this)
{
}

conditionScript::
conditionScript (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  function_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void conditionScript::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "function" && n.namespace_ ().empty ())
    {
      this->function_.set (function_traits::create (i, f, this));
      continue;
    }
  }

  if (!function_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "function",
      "");
  }
}

conditionScript* conditionScript::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class conditionScript (*this, f, c);
}

conditionScript& conditionScript::
operator= (const conditionScript& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->function_ = x.function_;
  }

  return *this;
}

conditionScript::
~conditionScript ()
{
}

// simpleText
//

simpleText::
simpleText (const color_type& color,
            const text_type& text,
            const xOffset_type& xOffset,
            const yOffset_type& yOffset,
            const font_type& font)
: ::xml_schema::type (),
  color_ (color, this),
  text_ (text, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this),
  font_ (font, this)
{
}

simpleText::
simpleText (::std::auto_ptr< color_type > color,
            const text_type& text,
            const xOffset_type& xOffset,
            const yOffset_type& yOffset,
            const font_type& font)
: ::xml_schema::type (),
  color_ (color, this),
  text_ (text, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this),
  font_ (font, this)
{
}

simpleText::
simpleText (const simpleText& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  color_ (x.color_, f, this),
  text_ (x.text_, f, this),
  xOffset_ (x.xOffset_, f, this),
  yOffset_ (x.yOffset_, f, this),
  font_ (x.font_, f, this)
{
}

simpleText::
simpleText (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  color_ (this),
  text_ (this),
  xOffset_ (this),
  yOffset_ (this),
  font_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void simpleText::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // color
    //
    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      if (!color_.present ())
      {
        this->color_.set (r);
        continue;
      }
    }

    break;
  }

  if (!color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "color",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "text" && n.namespace_ ().empty ())
    {
      this->text_.set (text_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xOffset" && n.namespace_ ().empty ())
    {
      this->xOffset_.set (xOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yOffset" && n.namespace_ ().empty ())
    {
      this->yOffset_.set (yOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "font" && n.namespace_ ().empty ())
    {
      this->font_.set (font_traits::create (i, f, this));
      continue;
    }
  }

  if (!text_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "text",
      "");
  }

  if (!xOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xOffset",
      "");
  }

  if (!yOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yOffset",
      "");
  }

  if (!font_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "font",
      "");
  }
}

simpleText* simpleText::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simpleText (*this, f, c);
}

simpleText& simpleText::
operator= (const simpleText& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->color_ = x.color_;
    this->text_ = x.text_;
    this->xOffset_ = x.xOffset_;
    this->yOffset_ = x.yOffset_;
    this->font_ = x.font_;
  }

  return *this;
}

simpleText::
~simpleText ()
{
}

// scriptText
//

scriptText::
scriptText (const color_type& color,
            const src_type& src,
            const xOffset_type& xOffset,
            const yOffset_type& yOffset,
            const font_type& font)
: ::xml_schema::type (),
  color_ (color, this),
  src_ (src, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this),
  font_ (font, this)
{
}

scriptText::
scriptText (::std::auto_ptr< color_type > color,
            const src_type& src,
            const xOffset_type& xOffset,
            const yOffset_type& yOffset,
            const font_type& font)
: ::xml_schema::type (),
  color_ (color, this),
  src_ (src, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this),
  font_ (font, this)
{
}

scriptText::
scriptText (const scriptText& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  color_ (x.color_, f, this),
  src_ (x.src_, f, this),
  xOffset_ (x.xOffset_, f, this),
  yOffset_ (x.yOffset_, f, this),
  font_ (x.font_, f, this)
{
}

scriptText::
scriptText (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  color_ (this),
  src_ (this),
  xOffset_ (this),
  yOffset_ (this),
  font_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void scriptText::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // color
    //
    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      if (!color_.present ())
      {
        this->color_.set (r);
        continue;
      }
    }

    break;
  }

  if (!color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "color",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "src" && n.namespace_ ().empty ())
    {
      this->src_.set (src_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xOffset" && n.namespace_ ().empty ())
    {
      this->xOffset_.set (xOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yOffset" && n.namespace_ ().empty ())
    {
      this->yOffset_.set (yOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "font" && n.namespace_ ().empty ())
    {
      this->font_.set (font_traits::create (i, f, this));
      continue;
    }
  }

  if (!src_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "src",
      "");
  }

  if (!xOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xOffset",
      "");
  }

  if (!yOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yOffset",
      "");
  }

  if (!font_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "font",
      "");
  }
}

scriptText* scriptText::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class scriptText (*this, f, c);
}

scriptText& scriptText::
operator= (const scriptText& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->color_ = x.color_;
    this->src_ = x.src_;
    this->xOffset_ = x.xOffset_;
    this->yOffset_ = x.yOffset_;
    this->font_ = x.font_;
  }

  return *this;
}

scriptText::
~scriptText ()
{
}

// image
//

image::
image (const image_name_type& image_name,
       const xOffset_type& xOffset,
       const yOffset_type& yOffset,
       const onclick_type& onclick)
: ::xml_schema::type (),
  image_name_ (image_name, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this),
  onclick_ (onclick, this)
{
}

image::
image (const image& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  image_name_ (x.image_name_, f, this),
  xOffset_ (x.xOffset_, f, this),
  yOffset_ (x.yOffset_, f, this),
  onclick_ (x.onclick_, f, this)
{
}

image::
image (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  image_name_ (this),
  xOffset_ (this),
  yOffset_ (this),
  onclick_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void image::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "image_name" && n.namespace_ ().empty ())
    {
      this->image_name_.set (image_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xOffset" && n.namespace_ ().empty ())
    {
      this->xOffset_.set (xOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yOffset" && n.namespace_ ().empty ())
    {
      this->yOffset_.set (yOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "onclick" && n.namespace_ ().empty ())
    {
      this->onclick_.set (onclick_traits::create (i, f, this));
      continue;
    }
  }

  if (!image_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "image_name",
      "");
  }

  if (!xOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xOffset",
      "");
  }

  if (!yOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yOffset",
      "");
  }

  if (!onclick_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "onclick",
      "");
  }
}

image* image::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class image (*this, f, c);
}

image& image::
operator= (const image& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->image_name_ = x.image_name_;
    this->xOffset_ = x.xOffset_;
    this->yOffset_ = x.yOffset_;
    this->onclick_ = x.onclick_;
  }

  return *this;
}

image::
~image ()
{
}

// button
//

button::
button (const name_type& name,
        const image_name_type& image_name,
        const xOffset_type& xOffset,
        const yOffset_type& yOffset,
        const onclick_type& onclick)
: ::xml_schema::type (),
  name_ (name, this),
  image_name_ (image_name, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this),
  onclick_ (onclick, this)
{
}

button::
button (const button& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  image_name_ (x.image_name_, f, this),
  xOffset_ (x.xOffset_, f, this),
  yOffset_ (x.yOffset_, f, this),
  onclick_ (x.onclick_, f, this)
{
}

button::
button (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  image_name_ (this),
  xOffset_ (this),
  yOffset_ (this),
  onclick_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void button::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "image_name" && n.namespace_ ().empty ())
    {
      this->image_name_.set (image_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xOffset" && n.namespace_ ().empty ())
    {
      this->xOffset_.set (xOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yOffset" && n.namespace_ ().empty ())
    {
      this->yOffset_.set (yOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "onclick" && n.namespace_ ().empty ())
    {
      this->onclick_.set (onclick_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!image_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "image_name",
      "");
  }

  if (!xOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xOffset",
      "");
  }

  if (!yOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yOffset",
      "");
  }

  if (!onclick_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "onclick",
      "");
  }
}

button* button::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class button (*this, f, c);
}

button& button::
operator= (const button& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->image_name_ = x.image_name_;
    this->xOffset_ = x.xOffset_;
    this->yOffset_ = x.yOffset_;
    this->onclick_ = x.onclick_;
  }

  return *this;
}

button::
~button ()
{
}

// textList
//

textList::
textList (const text_type& text,
          const text_background_type& text_background,
          const textListId_type& textListId,
          const xOffset_type& xOffset,
          const yOffset_type& yOffset)
: ::xml_schema::type (),
  text_ (text, this),
  text_background_ (text_background, this),
  textListId_ (textListId, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this)
{
}

textList::
textList (::std::auto_ptr< text_type > text,
          ::std::auto_ptr< text_background_type > text_background,
          const textListId_type& textListId,
          const xOffset_type& xOffset,
          const yOffset_type& yOffset)
: ::xml_schema::type (),
  text_ (text, this),
  text_background_ (text_background, this),
  textListId_ (textListId, this),
  xOffset_ (xOffset, this),
  yOffset_ (yOffset, this)
{
}

textList::
textList (const textList& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  text_ (x.text_, f, this),
  text_background_ (x.text_background_, f, this),
  textListId_ (x.textListId_, f, this),
  xOffset_ (x.xOffset_, f, this),
  yOffset_ (x.yOffset_, f, this)
{
}

textList::
textList (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  text_ (this),
  text_background_ (this),
  textListId_ (this),
  xOffset_ (this),
  yOffset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void textList::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // text
    //
    if (n.name () == "text" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< text_type > r (
        text_traits::create (i, f, this));

      if (!text_.present ())
      {
        this->text_.set (r);
        continue;
      }
    }

    // text_background
    //
    if (n.name () == "text_background" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< text_background_type > r (
        text_background_traits::create (i, f, this));

      if (!text_background_.present ())
      {
        this->text_background_.set (r);
        continue;
      }
    }

    break;
  }

  if (!text_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "text",
      "");
  }

  if (!text_background_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "text_background",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "textListId" && n.namespace_ ().empty ())
    {
      this->textListId_.set (textListId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xOffset" && n.namespace_ ().empty ())
    {
      this->xOffset_.set (xOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yOffset" && n.namespace_ ().empty ())
    {
      this->yOffset_.set (yOffset_traits::create (i, f, this));
      continue;
    }
  }

  if (!textListId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "textListId",
      "");
  }

  if (!xOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xOffset",
      "");
  }

  if (!yOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yOffset",
      "");
  }
}

textList* textList::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class textList (*this, f, c);
}

textList& textList::
operator= (const textList& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->text_ = x.text_;
    this->text_background_ = x.text_background_;
    this->textListId_ = x.textListId_;
    this->xOffset_ = x.xOffset_;
    this->yOffset_ = x.yOffset_;
  }

  return *this;
}

textList::
~textList ()
{
}

// color
//

color::
color (const r_type& r,
       const g_type& g,
       const b_type& b)
: ::xml_schema::type (),
  r_ (r, this),
  g_ (g, this),
  b_ (b, this)
{
}

color::
color (const color& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  r_ (x.r_, f, this),
  g_ (x.g_, f, this),
  b_ (x.b_, f, this)
{
}

color::
color (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  r_ (this),
  g_ (this),
  b_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void color::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "g" && n.namespace_ ().empty ())
    {
      this->g_.set (g_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }

  if (!g_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "g",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }
}

color* color::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class color (*this, f, c);
}

color& color::
operator= (const color& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->r_ = x.r_;
    this->g_ = x.g_;
    this->b_ = x.b_;
  }

  return *this;
}

color::
~color ()
{
}

// text
//

text::
text (const font_type& font,
      const r_type& r,
      const g_type& g,
      const b_type& b)
: ::xml_schema::type (),
  font_ (font, this),
  r_ (r, this),
  g_ (g, this),
  b_ (b, this)
{
}

text::
text (const text& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  font_ (x.font_, f, this),
  r_ (x.r_, f, this),
  g_ (x.g_, f, this),
  b_ (x.b_, f, this)
{
}

text::
text (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  font_ (this),
  r_ (this),
  g_ (this),
  b_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void text::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "font" && n.namespace_ ().empty ())
    {
      this->font_.set (font_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "g" && n.namespace_ ().empty ())
    {
      this->g_.set (g_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }
  }

  if (!font_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "font",
      "");
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }

  if (!g_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "g",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }
}

text* text::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class text (*this, f, c);
}

text& text::
operator= (const text& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->font_ = x.font_;
    this->r_ = x.r_;
    this->g_ = x.g_;
    this->b_ = x.b_;
  }

  return *this;
}

text::
~text ()
{
}

// text_background
//

text_background::
text_background (const r_type& r,
                 const g_type& g,
                 const b_type& b)
: ::xml_schema::type (),
  r_ (r, this),
  g_ (g, this),
  b_ (b, this)
{
}

text_background::
text_background (const text_background& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  r_ (x.r_, f, this),
  g_ (x.g_, f, this),
  b_ (x.b_, f, this)
{
}

text_background::
text_background (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  r_ (this),
  g_ (this),
  b_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void text_background::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "g" && n.namespace_ ().empty ())
    {
      this->g_.set (g_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }

  if (!g_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "g",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }
}

text_background* text_background::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class text_background (*this, f, c);
}

text_background& text_background::
operator= (const text_background& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->r_ = x.r_;
    this->g_ = x.g_;
    this->b_ = x.b_;
  }

  return *this;
}

text_background::
~text_background ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::c_editorWindows > (
    ::c_editorWindows_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::c_editorWindows > (
    ::c_editorWindows_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::c_editorWindows > (
    ::c_editorWindows_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::c_editorWindows_ (isrc, f, p);
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::c_editorWindows_ (isrc, h, f, p);
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::c_editorWindows_ (isrc, h, f, p);
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::c_editorWindows_ (isrc, f, p);
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::c_editorWindows_ (isrc, h, f, p);
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::c_editorWindows_ (isrc, h, f, p);
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::c_editorWindows > (
    ::c_editorWindows_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::c_editorWindows > (
    ::c_editorWindows_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::c_editorWindows > (
    ::c_editorWindows_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::c_editorWindows > (
      ::c_editorWindows_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "c_editorWindows" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::c_editorWindows > r (
      ::xsd::cxx::tree::traits< ::c_editorWindows, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "c_editorWindows",
    "");
}

::std::auto_ptr< ::c_editorWindows >
c_editorWindows_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "c_editorWindows" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::c_editorWindows > r (
      ::xsd::cxx::tree::traits< ::c_editorWindows, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "c_editorWindows",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

