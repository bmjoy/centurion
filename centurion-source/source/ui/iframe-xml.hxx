// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef IFRAME_HXX
#define IFRAME_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
	// anyType and anySimpleType.
	//
	typedef ::xsd::cxx::tree::type type;
	typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
	typedef ::xsd::cxx::tree::type container;

	// 8-bit
	//
	typedef signed char byte;
	typedef unsigned char unsigned_byte;

	// 16-bit
	//
	typedef short short_;
	typedef unsigned short unsigned_short;

	// 32-bit
	//
	typedef int int_;
	typedef unsigned int unsigned_int;

	// 64-bit
	//
	typedef long long long_;
	typedef unsigned long long unsigned_long;

	// Supposed to be arbitrary-length integral types.
	//
	typedef long long integer;
	typedef long long non_positive_integer;
	typedef unsigned long long non_negative_integer;
	typedef unsigned long long positive_integer;
	typedef long long negative_integer;

	// Boolean.
	//
	typedef bool boolean;

	// Floating-point types.
	//
	typedef float float_;
	typedef double double_;
	typedef double decimal;

	// String types.
	//
	typedef ::xsd::cxx::tree::string< char, simple_type > string;
	typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
	typedef ::xsd::cxx::tree::token< char, normalized_string > token;
	typedef ::xsd::cxx::tree::name< char, token > name;
	typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
	typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
	typedef ::xsd::cxx::tree::ncname< char, name > ncname;
	typedef ::xsd::cxx::tree::language< char, token > language;

	// ID/IDREF.
	//
	typedef ::xsd::cxx::tree::id< char, ncname > id;
	typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
	typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

	// URI.
	//
	typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

	// Qualified name.
	//
	typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

	// Binary.
	//
	typedef ::xsd::cxx::tree::buffer< char > buffer;
	typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
	typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

	// Date/time.
	//
	typedef ::xsd::cxx::tree::time_zone time_zone;
	typedef ::xsd::cxx::tree::date< char, simple_type > date;
	typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
	typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
	typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
	typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
	typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
	typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
	typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
	typedef ::xsd::cxx::tree::time< char, simple_type > time;

	// Entity.
	//
	typedef ::xsd::cxx::tree::entity< char, ncname > entity;
	typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

	typedef ::xsd::cxx::tree::content_order content_order;
	// Flags and properties.
	//
	typedef ::xsd::cxx::tree::flags flags;
	typedef ::xsd::cxx::tree::properties< char > properties;

	// Parsing/serialization diagnostics.
	//
	typedef ::xsd::cxx::tree::severity severity;
	typedef ::xsd::cxx::tree::error< char > error;
	typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

	// Exceptions.
	//
	typedef ::xsd::cxx::tree::exception< char > exception;
	typedef ::xsd::cxx::tree::bounds< char > bounds;
	typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
	typedef ::xsd::cxx::tree::parsing< char > parsing;
	typedef ::xsd::cxx::tree::expected_element< char > expected_element;
	typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
	typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
	typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
	typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
	typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

	// Error handler callback interface.
	//
	typedef ::xsd::cxx::xml::error_handler< char > error_handler;

	// DOM interaction.
	//
	namespace dom
	{
		// Automatic pointer for DOMDocument.
		//
		using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
		// DOM user data key for back pointers to tree nodes.
		//
		const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
	}
}

// Forward declarations.
//
class c_iframe;
class top_left;
class top_right;
class bottom_right;
class bottom_left;
class top;
class right;
class bottom;
class left;
class background;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class c_iframe : public ::xml_schema::type
{
public:
	// top_left
	//
	typedef ::top_left top_left_type;
	typedef ::xsd::cxx::tree::traits< top_left_type, char > top_left_traits;

	const top_left_type&
		top_left() const;

	top_left_type&
		top_left();

	void
		top_left(const top_left_type& x);

	void
		top_left(::std::auto_ptr< top_left_type > p);

	// top_right
	//
	typedef ::top_right top_right_type;
	typedef ::xsd::cxx::tree::traits< top_right_type, char > top_right_traits;

	const top_right_type&
		top_right() const;

	top_right_type&
		top_right();

	void
		top_right(const top_right_type& x);

	void
		top_right(::std::auto_ptr< top_right_type > p);

	// bottom_right
	//
	typedef ::bottom_right bottom_right_type;
	typedef ::xsd::cxx::tree::traits< bottom_right_type, char > bottom_right_traits;

	const bottom_right_type&
		bottom_right() const;

	bottom_right_type&
		bottom_right();

	void
		bottom_right(const bottom_right_type& x);

	void
		bottom_right(::std::auto_ptr< bottom_right_type > p);

	// bottom_left
	//
	typedef ::bottom_left bottom_left_type;
	typedef ::xsd::cxx::tree::traits< bottom_left_type, char > bottom_left_traits;

	const bottom_left_type&
		bottom_left() const;

	bottom_left_type&
		bottom_left();

	void
		bottom_left(const bottom_left_type& x);

	void
		bottom_left(::std::auto_ptr< bottom_left_type > p);

	// top
	//
	typedef ::top top_type;
	typedef ::xsd::cxx::tree::traits< top_type, char > top_traits;

	const top_type&
		top() const;

	top_type&
		top();

	void
		top(const top_type& x);

	void
		top(::std::auto_ptr< top_type > p);

	// right
	//
	typedef ::right right_type;
	typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

	const right_type&
		right() const;

	right_type&
		right();

	void
		right(const right_type& x);

	void
		right(::std::auto_ptr< right_type > p);

	// bottom
	//
	typedef ::bottom bottom_type;
	typedef ::xsd::cxx::tree::traits< bottom_type, char > bottom_traits;

	const bottom_type&
		bottom() const;

	bottom_type&
		bottom();

	void
		bottom(const bottom_type& x);

	void
		bottom(::std::auto_ptr< bottom_type > p);

	// left
	//
	typedef ::left left_type;
	typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

	const left_type&
		left() const;

	left_type&
		left();

	void
		left(const left_type& x);

	void
		left(::std::auto_ptr< left_type > p);

	// background
	//
	typedef ::background background_type;
	typedef ::xsd::cxx::tree::traits< background_type, char > background_traits;

	const background_type&
		background() const;

	background_type&
		background();

	void
		background(const background_type& x);

	void
		background(::std::auto_ptr< background_type > p);

	// name
	//
	typedef ::xml_schema::string name_type;
	typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

	const name_type&
		name() const;

	name_type&
		name();

	void
		name(const name_type& x);

	void
		name(::std::auto_ptr< name_type > p);

	// Constructors.
	//
	c_iframe(const top_left_type&,
		const top_right_type&,
		const bottom_right_type&,
		const bottom_left_type&,
		const top_type&,
		const right_type&,
		const bottom_type&,
		const left_type&,
		const background_type&,
		const name_type&);

	c_iframe(::std::auto_ptr< top_left_type >,
		::std::auto_ptr< top_right_type >,
		::std::auto_ptr< bottom_right_type >,
		::std::auto_ptr< bottom_left_type >,
		::std::auto_ptr< top_type >,
		::std::auto_ptr< right_type >,
		::std::auto_ptr< bottom_type >,
		::std::auto_ptr< left_type >,
		::std::auto_ptr< background_type >,
		const name_type&);

	c_iframe(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	c_iframe(const c_iframe& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual c_iframe*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	c_iframe&
		operator= (const c_iframe& x);

	virtual
		~c_iframe();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< top_left_type > top_left_;
	::xsd::cxx::tree::one< top_right_type > top_right_;
	::xsd::cxx::tree::one< bottom_right_type > bottom_right_;
	::xsd::cxx::tree::one< bottom_left_type > bottom_left_;
	::xsd::cxx::tree::one< top_type > top_;
	::xsd::cxx::tree::one< right_type > right_;
	::xsd::cxx::tree::one< bottom_type > bottom_;
	::xsd::cxx::tree::one< left_type > left_;
	::xsd::cxx::tree::one< background_type > background_;
	::xsd::cxx::tree::one< name_type > name_;
};

class top_left : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	top_left(const image_name_type&,
		const repeat_type&);

	top_left(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	top_left(const top_left& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual top_left*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	top_left&
		operator= (const top_left& x);

	virtual
		~top_left();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class top_right : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	top_right(const image_name_type&,
		const repeat_type&);

	top_right(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	top_right(const top_right& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual top_right*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	top_right&
		operator= (const top_right& x);

	virtual
		~top_right();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class bottom_right : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	bottom_right(const image_name_type&,
		const repeat_type&);

	bottom_right(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	bottom_right(const bottom_right& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual bottom_right*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	bottom_right&
		operator= (const bottom_right& x);

	virtual
		~bottom_right();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class bottom_left : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	bottom_left(const image_name_type&,
		const repeat_type&);

	bottom_left(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	bottom_left(const bottom_left& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual bottom_left*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	bottom_left&
		operator= (const bottom_left& x);

	virtual
		~bottom_left();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class top : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	top(const image_name_type&,
		const repeat_type&);

	top(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	top(const top& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual top*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	top&
		operator= (const top& x);

	virtual
		~top();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class right : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	right(const image_name_type&,
		const repeat_type&);

	right(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	right(const right& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual right*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	right&
		operator= (const right& x);

	virtual
		~right();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class bottom : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	bottom(const image_name_type&,
		const repeat_type&);

	bottom(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	bottom(const bottom& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual bottom*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	bottom&
		operator= (const bottom& x);

	virtual
		~bottom();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class left : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	left(const image_name_type&,
		const repeat_type&);

	left(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	left(const left& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual left*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	left&
		operator= (const left& x);

	virtual
		~left();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

class background : public ::xml_schema::type
{
public:
	// image_name
	//
	typedef ::xml_schema::string image_name_type;
	typedef ::xsd::cxx::tree::traits< image_name_type, char > image_name_traits;

	const image_name_type&
		image_name() const;

	image_name_type&
		image_name();

	void
		image_name(const image_name_type& x);

	void
		image_name(::std::auto_ptr< image_name_type > p);

	// repeat
	//
	typedef ::xml_schema::string repeat_type;
	typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

	const repeat_type&
		repeat() const;

	repeat_type&
		repeat();

	void
		repeat(const repeat_type& x);

	void
		repeat(::std::auto_ptr< repeat_type > p);

	// Constructors.
	//
	background(const image_name_type&,
		const repeat_type&);

	background(const ::xercesc::DOMElement& e,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	background(const background& x,
		::xml_schema::flags f = 0,
		::xml_schema::container* c = 0);

	virtual background*
		_clone(::xml_schema::flags f = 0,
			::xml_schema::container* c = 0) const;

	background&
		operator= (const background& x);

	virtual
		~background();

	// Implementation.
	//
protected:
	void
		parse(::xsd::cxx::xml::dom::parser< char >&,
			::xml_schema::flags);

protected:
	::xsd::cxx::tree::one< image_name_type > image_name_;
	::xsd::cxx::tree::one< repeat_type > repeat_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::std::string& uri,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::std::string& uri,
	::xml_schema::error_handler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::std::string& uri,
	::xercesc::DOMErrorHandler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse std::istream.
//

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	::xml_schema::error_handler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	::xercesc::DOMErrorHandler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	const ::std::string& id,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	const ::std::string& id,
	::xml_schema::error_handler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	const ::std::string& id,
	::xercesc::DOMErrorHandler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::c_iframe >
c_iframe_(::xercesc::InputSource& is,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::xercesc::InputSource& is,
	::xml_schema::error_handler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::xercesc::InputSource& is,
	::xercesc::DOMErrorHandler& eh,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::xercesc::DOMDocument& d,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::c_iframe >
c_iframe_(::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
	::xml_schema::flags f = 0,
	const ::xml_schema::properties& p = ::xml_schema::properties());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // IFRAME_HXX
