// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "iframe-xml.hxx"

// c_iframe
// 

const c_iframe::top_left_type& c_iframe::
top_left() const
{
	return this->top_left_.get();
}

c_iframe::top_left_type& c_iframe::
top_left()
{
	return this->top_left_.get();
}

void c_iframe::
top_left(const top_left_type& x)
{
	this->top_left_.set(x);
}

void c_iframe::
top_left(::std::auto_ptr< top_left_type > x)
{
	this->top_left_.set(x);
}

const c_iframe::top_right_type& c_iframe::
top_right() const
{
	return this->top_right_.get();
}

c_iframe::top_right_type& c_iframe::
top_right()
{
	return this->top_right_.get();
}

void c_iframe::
top_right(const top_right_type& x)
{
	this->top_right_.set(x);
}

void c_iframe::
top_right(::std::auto_ptr< top_right_type > x)
{
	this->top_right_.set(x);
}

const c_iframe::bottom_right_type& c_iframe::
bottom_right() const
{
	return this->bottom_right_.get();
}

c_iframe::bottom_right_type& c_iframe::
bottom_right()
{
	return this->bottom_right_.get();
}

void c_iframe::
bottom_right(const bottom_right_type& x)
{
	this->bottom_right_.set(x);
}

void c_iframe::
bottom_right(::std::auto_ptr< bottom_right_type > x)
{
	this->bottom_right_.set(x);
}

const c_iframe::bottom_left_type& c_iframe::
bottom_left() const
{
	return this->bottom_left_.get();
}

c_iframe::bottom_left_type& c_iframe::
bottom_left()
{
	return this->bottom_left_.get();
}

void c_iframe::
bottom_left(const bottom_left_type& x)
{
	this->bottom_left_.set(x);
}

void c_iframe::
bottom_left(::std::auto_ptr< bottom_left_type > x)
{
	this->bottom_left_.set(x);
}

const c_iframe::top_type& c_iframe::
top() const
{
	return this->top_.get();
}

c_iframe::top_type& c_iframe::
top()
{
	return this->top_.get();
}

void c_iframe::
top(const top_type& x)
{
	this->top_.set(x);
}

void c_iframe::
top(::std::auto_ptr< top_type > x)
{
	this->top_.set(x);
}

const c_iframe::right_type& c_iframe::
right() const
{
	return this->right_.get();
}

c_iframe::right_type& c_iframe::
right()
{
	return this->right_.get();
}

void c_iframe::
right(const right_type& x)
{
	this->right_.set(x);
}

void c_iframe::
right(::std::auto_ptr< right_type > x)
{
	this->right_.set(x);
}

const c_iframe::bottom_type& c_iframe::
bottom() const
{
	return this->bottom_.get();
}

c_iframe::bottom_type& c_iframe::
bottom()
{
	return this->bottom_.get();
}

void c_iframe::
bottom(const bottom_type& x)
{
	this->bottom_.set(x);
}

void c_iframe::
bottom(::std::auto_ptr< bottom_type > x)
{
	this->bottom_.set(x);
}

const c_iframe::left_type& c_iframe::
left() const
{
	return this->left_.get();
}

c_iframe::left_type& c_iframe::
left()
{
	return this->left_.get();
}

void c_iframe::
left(const left_type& x)
{
	this->left_.set(x);
}

void c_iframe::
left(::std::auto_ptr< left_type > x)
{
	this->left_.set(x);
}

const c_iframe::background_type& c_iframe::
background() const
{
	return this->background_.get();
}

c_iframe::background_type& c_iframe::
background()
{
	return this->background_.get();
}

void c_iframe::
background(const background_type& x)
{
	this->background_.set(x);
}

void c_iframe::
background(::std::auto_ptr< background_type > x)
{
	this->background_.set(x);
}

const c_iframe::name_type& c_iframe::
name() const
{
	return this->name_.get();
}

c_iframe::name_type& c_iframe::
name()
{
	return this->name_.get();
}

void c_iframe::
name(const name_type& x)
{
	this->name_.set(x);
}

void c_iframe::
name(::std::auto_ptr< name_type > x)
{
	this->name_.set(x);
}


// top_left
// 

const top_left::image_name_type& top_left::
image_name() const
{
	return this->image_name_.get();
}

top_left::image_name_type& top_left::
image_name()
{
	return this->image_name_.get();
}

void top_left::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void top_left::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const top_left::repeat_type& top_left::
repeat() const
{
	return this->repeat_.get();
}

top_left::repeat_type& top_left::
repeat()
{
	return this->repeat_.get();
}

void top_left::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void top_left::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// top_right
// 

const top_right::image_name_type& top_right::
image_name() const
{
	return this->image_name_.get();
}

top_right::image_name_type& top_right::
image_name()
{
	return this->image_name_.get();
}

void top_right::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void top_right::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const top_right::repeat_type& top_right::
repeat() const
{
	return this->repeat_.get();
}

top_right::repeat_type& top_right::
repeat()
{
	return this->repeat_.get();
}

void top_right::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void top_right::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// bottom_right
// 

const bottom_right::image_name_type& bottom_right::
image_name() const
{
	return this->image_name_.get();
}

bottom_right::image_name_type& bottom_right::
image_name()
{
	return this->image_name_.get();
}

void bottom_right::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void bottom_right::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const bottom_right::repeat_type& bottom_right::
repeat() const
{
	return this->repeat_.get();
}

bottom_right::repeat_type& bottom_right::
repeat()
{
	return this->repeat_.get();
}

void bottom_right::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void bottom_right::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// bottom_left
// 

const bottom_left::image_name_type& bottom_left::
image_name() const
{
	return this->image_name_.get();
}

bottom_left::image_name_type& bottom_left::
image_name()
{
	return this->image_name_.get();
}

void bottom_left::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void bottom_left::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const bottom_left::repeat_type& bottom_left::
repeat() const
{
	return this->repeat_.get();
}

bottom_left::repeat_type& bottom_left::
repeat()
{
	return this->repeat_.get();
}

void bottom_left::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void bottom_left::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// top
// 

const top::image_name_type& top::
image_name() const
{
	return this->image_name_.get();
}

top::image_name_type& top::
image_name()
{
	return this->image_name_.get();
}

void top::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void top::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const top::repeat_type& top::
repeat() const
{
	return this->repeat_.get();
}

top::repeat_type& top::
repeat()
{
	return this->repeat_.get();
}

void top::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void top::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// right
// 

const right::image_name_type& right::
image_name() const
{
	return this->image_name_.get();
}

right::image_name_type& right::
image_name()
{
	return this->image_name_.get();
}

void right::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void right::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const right::repeat_type& right::
repeat() const
{
	return this->repeat_.get();
}

right::repeat_type& right::
repeat()
{
	return this->repeat_.get();
}

void right::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void right::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// bottom
// 

const bottom::image_name_type& bottom::
image_name() const
{
	return this->image_name_.get();
}

bottom::image_name_type& bottom::
image_name()
{
	return this->image_name_.get();
}

void bottom::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void bottom::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const bottom::repeat_type& bottom::
repeat() const
{
	return this->repeat_.get();
}

bottom::repeat_type& bottom::
repeat()
{
	return this->repeat_.get();
}

void bottom::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void bottom::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// left
// 

const left::image_name_type& left::
image_name() const
{
	return this->image_name_.get();
}

left::image_name_type& left::
image_name()
{
	return this->image_name_.get();
}

void left::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void left::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const left::repeat_type& left::
repeat() const
{
	return this->repeat_.get();
}

left::repeat_type& left::
repeat()
{
	return this->repeat_.get();
}

void left::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void left::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


// background
// 

const background::image_name_type& background::
image_name() const
{
	return this->image_name_.get();
}

background::image_name_type& background::
image_name()
{
	return this->image_name_.get();
}

void background::
image_name(const image_name_type& x)
{
	this->image_name_.set(x);
}

void background::
image_name(::std::auto_ptr< image_name_type > x)
{
	this->image_name_.set(x);
}

const background::repeat_type& background::
repeat() const
{
	return this->repeat_.get();
}

background::repeat_type& background::
repeat()
{
	return this->repeat_.get();
}

void background::
repeat(const repeat_type& x)
{
	this->repeat_.set(x);
}

void background::
repeat(::std::auto_ptr< repeat_type > x)
{
	this->repeat_.set(x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// c_iframe
//

c_iframe::
c_iframe(const top_left_type& top_left,
	const top_right_type& top_right,
	const bottom_right_type& bottom_right,
	const bottom_left_type& bottom_left,
	const top_type& top,
	const right_type& right,
	const bottom_type& bottom,
	const left_type& left,
	const background_type& background,
	const name_type& name)
	: ::xml_schema::type(),
	top_left_(top_left, this),
	top_right_(top_right, this),
	bottom_right_(bottom_right, this),
	bottom_left_(bottom_left, this),
	top_(top, this),
	right_(right, this),
	bottom_(bottom, this),
	left_(left, this),
	background_(background, this),
	name_(name, this)
{
}

c_iframe::
c_iframe(::std::auto_ptr< top_left_type > top_left,
	::std::auto_ptr< top_right_type > top_right,
	::std::auto_ptr< bottom_right_type > bottom_right,
	::std::auto_ptr< bottom_left_type > bottom_left,
	::std::auto_ptr< top_type > top,
	::std::auto_ptr< right_type > right,
	::std::auto_ptr< bottom_type > bottom,
	::std::auto_ptr< left_type > left,
	::std::auto_ptr< background_type > background,
	const name_type& name)
	: ::xml_schema::type(),
	top_left_(top_left, this),
	top_right_(top_right, this),
	bottom_right_(bottom_right, this),
	bottom_left_(bottom_left, this),
	top_(top, this),
	right_(right, this),
	bottom_(bottom, this),
	left_(left, this),
	background_(background, this),
	name_(name, this)
{
}

c_iframe::
c_iframe(const c_iframe& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	top_left_(x.top_left_, f, this),
	top_right_(x.top_right_, f, this),
	bottom_right_(x.bottom_right_, f, this),
	bottom_left_(x.bottom_left_, f, this),
	top_(x.top_, f, this),
	right_(x.right_, f, this),
	bottom_(x.bottom_, f, this),
	left_(x.left_, f, this),
	background_(x.background_, f, this),
	name_(x.name_, f, this)
{
}

c_iframe::
c_iframe(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	top_left_(this),
	top_right_(this),
	bottom_right_(this),
	bottom_left_(this),
	top_(this),
	right_(this),
	bottom_(this),
	left_(this),
	background_(this),
	name_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, true);
		this->parse(p, f);
	}
}

void c_iframe::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// top_left
		//
		if (n.name() == "top_left" && n.namespace_().empty())
		{
			::std::auto_ptr< top_left_type > r(
				top_left_traits::create(i, f, this));

			if (!top_left_.present())
			{
				this->top_left_.set(r);
				continue;
			}
		}

		// top_right
		//
		if (n.name() == "top_right" && n.namespace_().empty())
		{
			::std::auto_ptr< top_right_type > r(
				top_right_traits::create(i, f, this));

			if (!top_right_.present())
			{
				this->top_right_.set(r);
				continue;
			}
		}

		// bottom_right
		//
		if (n.name() == "bottom_right" && n.namespace_().empty())
		{
			::std::auto_ptr< bottom_right_type > r(
				bottom_right_traits::create(i, f, this));

			if (!bottom_right_.present())
			{
				this->bottom_right_.set(r);
				continue;
			}
		}

		// bottom_left
		//
		if (n.name() == "bottom_left" && n.namespace_().empty())
		{
			::std::auto_ptr< bottom_left_type > r(
				bottom_left_traits::create(i, f, this));

			if (!bottom_left_.present())
			{
				this->bottom_left_.set(r);
				continue;
			}
		}

		// top
		//
		if (n.name() == "top" && n.namespace_().empty())
		{
			::std::auto_ptr< top_type > r(
				top_traits::create(i, f, this));

			if (!top_.present())
			{
				this->top_.set(r);
				continue;
			}
		}

		// right
		//
		if (n.name() == "right" && n.namespace_().empty())
		{
			::std::auto_ptr< right_type > r(
				right_traits::create(i, f, this));

			if (!right_.present())
			{
				this->right_.set(r);
				continue;
			}
		}

		// bottom
		//
		if (n.name() == "bottom" && n.namespace_().empty())
		{
			::std::auto_ptr< bottom_type > r(
				bottom_traits::create(i, f, this));

			if (!bottom_.present())
			{
				this->bottom_.set(r);
				continue;
			}
		}

		// left
		//
		if (n.name() == "left" && n.namespace_().empty())
		{
			::std::auto_ptr< left_type > r(
				left_traits::create(i, f, this));

			if (!left_.present())
			{
				this->left_.set(r);
				continue;
			}
		}

		// background
		//
		if (n.name() == "background" && n.namespace_().empty())
		{
			::std::auto_ptr< background_type > r(
				background_traits::create(i, f, this));

			if (!background_.present())
			{
				this->background_.set(r);
				continue;
			}
		}

		break;
	}

	if (!top_left_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"top_left",
			"");
	}

	if (!top_right_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"top_right",
			"");
	}

	if (!bottom_right_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"bottom_right",
			"");
	}

	if (!bottom_left_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"bottom_left",
			"");
	}

	if (!top_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"top",
			"");
	}

	if (!right_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"right",
			"");
	}

	if (!bottom_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"bottom",
			"");
	}

	if (!left_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"left",
			"");
	}

	if (!background_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"background",
			"");
	}

	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}
	}

	if (!name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"name",
			"");
	}
}

c_iframe* c_iframe::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class c_iframe(*this, f, c);
}

c_iframe& c_iframe::
operator= (const c_iframe& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->top_left_ = x.top_left_;
		this->top_right_ = x.top_right_;
		this->bottom_right_ = x.bottom_right_;
		this->bottom_left_ = x.bottom_left_;
		this->top_ = x.top_;
		this->right_ = x.right_;
		this->bottom_ = x.bottom_;
		this->left_ = x.left_;
		this->background_ = x.background_;
		this->name_ = x.name_;
	}

	return *this;
}

c_iframe::
~c_iframe()
{
}

// top_left
//

top_left::
top_left(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

top_left::
top_left(const top_left& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

top_left::
top_left(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void top_left::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

top_left* top_left::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class top_left(*this, f, c);
}

top_left& top_left::
operator= (const top_left& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

top_left::
~top_left()
{
}

// top_right
//

top_right::
top_right(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

top_right::
top_right(const top_right& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

top_right::
top_right(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void top_right::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

top_right* top_right::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class top_right(*this, f, c);
}

top_right& top_right::
operator= (const top_right& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

top_right::
~top_right()
{
}

// bottom_right
//

bottom_right::
bottom_right(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

bottom_right::
bottom_right(const bottom_right& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

bottom_right::
bottom_right(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void bottom_right::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

bottom_right* bottom_right::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class bottom_right(*this, f, c);
}

bottom_right& bottom_right::
operator= (const bottom_right& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

bottom_right::
~bottom_right()
{
}

// bottom_left
//

bottom_left::
bottom_left(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

bottom_left::
bottom_left(const bottom_left& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

bottom_left::
bottom_left(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void bottom_left::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

bottom_left* bottom_left::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class bottom_left(*this, f, c);
}

bottom_left& bottom_left::
operator= (const bottom_left& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

bottom_left::
~bottom_left()
{
}

// top
//

top::
top(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

top::
top(const top& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

top::
top(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void top::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

top* top::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class top(*this, f, c);
}

top& top::
operator= (const top& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

top::
~top()
{
}

// right
//

right::
right(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

right::
right(const right& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

right::
right(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void right::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

right* right::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class right(*this, f, c);
}

right& right::
operator= (const right& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

right::
~right()
{
}

// bottom
//

bottom::
bottom(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

bottom::
bottom(const bottom& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

bottom::
bottom(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void bottom::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

bottom* bottom::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class bottom(*this, f, c);
}

bottom& bottom::
operator= (const bottom& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

bottom::
~bottom()
{
}

// left
//

left::
left(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

left::
left(const left& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

left::
left(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void left::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

left* left::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class left(*this, f, c);
}

left& left::
operator= (const left& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

left::
~left()
{
}

// background
//

background::
background(const image_name_type& image_name,
	const repeat_type& repeat)
	: ::xml_schema::type(),
	image_name_(image_name, this),
	repeat_(repeat, this)
{
}

background::
background(const background& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	image_name_(x.image_name_, f, this),
	repeat_(x.repeat_, f, this)
{
}

background::
background(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	image_name_(this),
	repeat_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void background::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "image_name" && n.namespace_().empty())
		{
			this->image_name_.set(image_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "repeat" && n.namespace_().empty())
		{
			this->repeat_.set(repeat_traits::create(i, f, this));
			continue;
		}
	}

	if (!image_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image_name",
			"");
	}

	if (!repeat_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"repeat",
			"");
	}
}

background* background::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class background(*this, f, c);
}

background& background::
operator= (const background& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->image_name_ = x.image_name_;
		this->repeat_ = x.repeat_;
	}

	return *this;
}

background::
~background()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::std::string& u,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

	return ::std::auto_ptr< ::c_iframe >(
		::c_iframe_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::std::string& u,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_iframe >(
		::c_iframe_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::std::string& u,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_iframe >(
		::c_iframe_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_iframe_(isrc, f, p);
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_iframe_(isrc, h, f, p);
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_iframe_(isrc, h, f, p);
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	const ::std::string& sid,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_iframe_(isrc, f, p);
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	const ::std::string& sid,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_iframe_(isrc, h, f, p);
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::std::istream& is,
	const ::std::string& sid,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_iframe_(isrc, h, f, p);
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::xercesc::InputSource& i,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

	return ::std::auto_ptr< ::c_iframe >(
		::c_iframe_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::xercesc::InputSource& i,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_iframe >(
		::c_iframe_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::xercesc::InputSource& i,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_iframe >(
		::c_iframe_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_iframe >
c_iframe_(const ::xercesc::DOMDocument& doc,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	if (f & ::xml_schema::flags::keep_dom)
	{
		::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
			static_cast<::xercesc::DOMDocument*> (doc.cloneNode(true)));

		return ::std::auto_ptr< ::c_iframe >(
			::c_iframe_(
				d, f | ::xml_schema::flags::own_dom, p));
	}

	const ::xercesc::DOMElement& e(*doc.getDocumentElement());
	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (n.name() == "c_iframe" &&
		n.namespace_() == "")
	{
		::std::auto_ptr< ::c_iframe > r(
			::xsd::cxx::tree::traits< ::c_iframe, char >::create(
				e, f, 0));
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char >(
		n.name(),
		n.namespace_(),
		"c_iframe",
		"");
}

::std::auto_ptr< ::c_iframe >
c_iframe_(::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
	::xml_schema::flags f,
	const ::xml_schema::properties&)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c(
		((f & ::xml_schema::flags::keep_dom) &&
			!(f & ::xml_schema::flags::own_dom))
		? static_cast<::xercesc::DOMDocument*> (d->cloneNode(true))
		: 0);

	::xercesc::DOMDocument& doc(c.get() ? *c : *d);
	const ::xercesc::DOMElement& e(*doc.getDocumentElement());

	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (f & ::xml_schema::flags::keep_dom)
		doc.setUserData(::xml_schema::dom::tree_node_key,
		(c.get() ? &c : &d),
			0);

	if (n.name() == "c_iframe" &&
		n.namespace_() == "")
	{
		::std::auto_ptr< ::c_iframe > r(
			::xsd::cxx::tree::traits< ::c_iframe, char >::create(
				e, f, 0));
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char >(
		n.name(),
		n.namespace_(),
		"c_iframe",
		"");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

