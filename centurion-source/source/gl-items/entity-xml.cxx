// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "entity-xml.hxx"

// c_entity
// 

const c_entity::ent_properties_type& c_entity::
ent_properties() const
{
	return this->ent_properties_.get();
}

c_entity::ent_properties_type& c_entity::
ent_properties()
{
	return this->ent_properties_.get();
}

void c_entity::
ent_properties(const ent_properties_type& x)
{
	this->ent_properties_.set(x);
}

void c_entity::
ent_properties(::std::auto_ptr< ent_properties_type > x)
{
	this->ent_properties_.set(x);
}

const c_entity::ent_points_type& c_entity::
ent_points() const
{
	return this->ent_points_.get();
}

c_entity::ent_points_type& c_entity::
ent_points()
{
	return this->ent_points_.get();
}

void c_entity::
ent_points(const ent_points_type& x)
{
	this->ent_points_.set(x);
}

void c_entity::
ent_points(::std::auto_ptr< ent_points_type > x)
{
	this->ent_points_.set(x);
}

const c_entity::ent_images_type& c_entity::
ent_images() const
{
	return this->ent_images_.get();
}

c_entity::ent_images_type& c_entity::
ent_images()
{
	return this->ent_images_.get();
}

void c_entity::
ent_images(const ent_images_type& x)
{
	this->ent_images_.set(x);
}

void c_entity::
ent_images(::std::auto_ptr< ent_images_type > x)
{
	this->ent_images_.set(x);
}

const c_entity::ent_layers_type& c_entity::
ent_layers() const
{
	return this->ent_layers_.get();
}

c_entity::ent_layers_type& c_entity::
ent_layers()
{
	return this->ent_layers_.get();
}

void c_entity::
ent_layers(const ent_layers_type& x)
{
	this->ent_layers_.set(x);
}

void c_entity::
ent_layers(::std::auto_ptr< ent_layers_type > x)
{
	this->ent_layers_.set(x);
}

const c_entity::ent_animations_type& c_entity::
ent_animations() const
{
	return this->ent_animations_.get();
}

c_entity::ent_animations_type& c_entity::
ent_animations()
{
	return this->ent_animations_.get();
}

void c_entity::
ent_animations(const ent_animations_type& x)
{
	this->ent_animations_.set(x);
}

void c_entity::
ent_animations(::std::auto_ptr< ent_animations_type > x)
{
	this->ent_animations_.set(x);
}

const c_entity::class_name_type& c_entity::
class_name() const
{
	return this->class_name_.get();
}

c_entity::class_name_type& c_entity::
class_name()
{
	return this->class_name_.get();
}

void c_entity::
class_name(const class_name_type& x)
{
	this->class_name_.set(x);
}

void c_entity::
class_name(::std::auto_ptr< class_name_type > x)
{
	this->class_name_.set(x);
}

const c_entity::type_type& c_entity::
type() const
{
	return this->type_.get();
}

c_entity::type_type& c_entity::
type()
{
	return this->type_.get();
}

void c_entity::
type(const type_type& x)
{
	this->type_.set(x);
}

void c_entity::
type(::std::auto_ptr< type_type > x)
{
	this->type_.set(x);
}

const c_entity::directions_type& c_entity::
directions() const
{
	return this->directions_.get();
}

c_entity::directions_type& c_entity::
directions()
{
	return this->directions_.get();
}

void c_entity::
directions(const directions_type& x)
{
	this->directions_.set(x);
}


// ent_properties
// 

const ent_properties::ent_property_sequence& ent_properties::
ent_property() const
{
	return this->ent_property_;
}

ent_properties::ent_property_sequence& ent_properties::
ent_property()
{
	return this->ent_property_;
}

void ent_properties::
ent_property(const ent_property_sequence& s)
{
	this->ent_property_ = s;
}


// ent_points
// 

const ent_points::ent_point_sequence& ent_points::
ent_point() const
{
	return this->ent_point_;
}

ent_points::ent_point_sequence& ent_points::
ent_point()
{
	return this->ent_point_;
}

void ent_points::
ent_point(const ent_point_sequence& s)
{
	this->ent_point_ = s;
}


// ent_images
// 

const ent_images::ent_image_sequence& ent_images::
ent_image() const
{
	return this->ent_image_;
}

ent_images::ent_image_sequence& ent_images::
ent_image()
{
	return this->ent_image_;
}

void ent_images::
ent_image(const ent_image_sequence& s)
{
	this->ent_image_ = s;
}


// ent_layers
// 

const ent_layers::ent_layer_sequence& ent_layers::
ent_layer() const
{
	return this->ent_layer_;
}

ent_layers::ent_layer_sequence& ent_layers::
ent_layer()
{
	return this->ent_layer_;
}

void ent_layers::
ent_layer(const ent_layer_sequence& s)
{
	this->ent_layer_ = s;
}


// ent_animations
// 

const ent_animations::ent_animation_sequence& ent_animations::
ent_animation() const
{
	return this->ent_animation_;
}

ent_animations::ent_animation_sequence& ent_animations::
ent_animation()
{
	return this->ent_animation_;
}

void ent_animations::
ent_animation(const ent_animation_sequence& s)
{
	this->ent_animation_ = s;
}


// ent_property
// 

const ent_property::name_type& ent_property::
name() const
{
	return this->name_.get();
}

ent_property::name_type& ent_property::
name()
{
	return this->name_.get();
}

void ent_property::
name(const name_type& x)
{
	this->name_.set(x);
}

const ent_property::value_type& ent_property::
value() const
{
	return this->value_.get();
}

ent_property::value_type& ent_property::
value()
{
	return this->value_.get();
}

void ent_property::
value(const value_type& x)
{
	this->value_.set(x);
}


// ent_point
// 

const ent_point::id_type& ent_point::
id() const
{
	return this->id_.get();
}

ent_point::id_type& ent_point::
id()
{
	return this->id_.get();
}

void ent_point::
id(const id_type& x)
{
	this->id_.set(x);
}

const ent_point::type_type& ent_point::
type() const
{
	return this->type_.get();
}

ent_point::type_type& ent_point::
type()
{
	return this->type_.get();
}

void ent_point::
type(const type_type& x)
{
	this->type_.set(x);
}

const ent_point::x_type& ent_point::
x() const
{
	return this->x_.get();
}

ent_point::x_type& ent_point::
x()
{
	return this->x_.get();
}

void ent_point::
x(const x_type& x)
{
	this->x_.set(x);
}

const ent_point::y_type& ent_point::
y() const
{
	return this->y_.get();
}

ent_point::y_type& ent_point::
y()
{
	return this->y_.get();
}

void ent_point::
y(const y_type& x)
{
	this->y_.set(x);
}


// ent_image
// 

const ent_image::id_type& ent_image::
id() const
{
	return this->id_.get();
}

ent_image::id_type& ent_image::
id()
{
	return this->id_.get();
}

void ent_image::
id(const id_type& x)
{
	this->id_.set(x);
}

const ent_image::file_type& ent_image::
file() const
{
	return this->file_.get();
}

ent_image::file_type& ent_image::
file()
{
	return this->file_.get();
}

void ent_image::
file(const file_type& x)
{
	this->file_.set(x);
}

void ent_image::
file(::std::auto_ptr< file_type > x)
{
	this->file_.set(x);
}

const ent_image::drawmode_type& ent_image::
drawmode() const
{
	return this->drawmode_.get();
}

ent_image::drawmode_type& ent_image::
drawmode()
{
	return this->drawmode_.get();
}

void ent_image::
drawmode(const drawmode_type& x)
{
	this->drawmode_.set(x);
}

void ent_image::
drawmode(::std::auto_ptr< drawmode_type > x)
{
	this->drawmode_.set(x);
}

const ent_image::reverse_type& ent_image::
reverse() const
{
	return this->reverse_.get();
}

ent_image::reverse_type& ent_image::
reverse()
{
	return this->reverse_.get();
}

void ent_image::
reverse(const reverse_type& x)
{
	this->reverse_.set(x);
}

const ent_image::frames_type& ent_image::
frames() const
{
	return this->frames_.get();
}

ent_image::frames_type& ent_image::
frames()
{
	return this->frames_.get();
}

void ent_image::
frames(const frames_type& x)
{
	this->frames_.set(x);
}


// ent_layer
// 

const ent_layer::id_type& ent_layer::
id() const
{
	return this->id_.get();
}

ent_layer::id_type& ent_layer::
id()
{
	return this->id_.get();
}

void ent_layer::
id(const id_type& x)
{
	this->id_.set(x);
}

const ent_layer::name_type& ent_layer::
name() const
{
	return this->name_.get();
}

ent_layer::name_type& ent_layer::
name()
{
	return this->name_.get();
}

void ent_layer::
name(const name_type& x)
{
	this->name_.set(x);
}

void ent_layer::
name(::std::auto_ptr< name_type > x)
{
	this->name_.set(x);
}

const ent_layer::image_type& ent_layer::
image() const
{
	return this->image_.get();
}

ent_layer::image_type& ent_layer::
image()
{
	return this->image_.get();
}

void ent_layer::
image(const image_type& x)
{
	this->image_.set(x);
}

const ent_layer::x_type& ent_layer::
x() const
{
	return this->x_.get();
}

ent_layer::x_type& ent_layer::
x()
{
	return this->x_.get();
}

void ent_layer::
x(const x_type& x)
{
	this->x_.set(x);
}

const ent_layer::y_type& ent_layer::
y() const
{
	return this->y_.get();
}

ent_layer::y_type& ent_layer::
y()
{
	return this->y_.get();
}

void ent_layer::
y(const y_type& x)
{
	this->y_.set(x);
}


// ent_animation
// 

const ent_animation::replace_sequence& ent_animation::
replace() const
{
	return this->replace_;
}

ent_animation::replace_sequence& ent_animation::
replace()
{
	return this->replace_;
}

void ent_animation::
replace(const replace_sequence& s)
{
	this->replace_ = s;
}

const ent_animation::frame_sequence& ent_animation::
frame() const
{
	return this->frame_;
}

ent_animation::frame_sequence& ent_animation::
frame()
{
	return this->frame_;
}

void ent_animation::
frame(const frame_sequence& s)
{
	this->frame_ = s;
}

const ent_animation::id_type& ent_animation::
id() const
{
	return this->id_.get();
}

ent_animation::id_type& ent_animation::
id()
{
	return this->id_.get();
}

void ent_animation::
id(const id_type& x)
{
	this->id_.set(x);
}

const ent_animation::name_type& ent_animation::
name() const
{
	return this->name_.get();
}

ent_animation::name_type& ent_animation::
name()
{
	return this->name_.get();
}

void ent_animation::
name(const name_type& x)
{
	this->name_.set(x);
}

void ent_animation::
name(::std::auto_ptr< name_type > x)
{
	this->name_.set(x);
}

const ent_animation::startstate_type& ent_animation::
startstate() const
{
	return this->startstate_.get();
}

ent_animation::startstate_type& ent_animation::
startstate()
{
	return this->startstate_.get();
}

void ent_animation::
startstate(const startstate_type& x)
{
	this->startstate_.set(x);
}

const ent_animation::endstate_type& ent_animation::
endstate() const
{
	return this->endstate_.get();
}

ent_animation::endstate_type& ent_animation::
endstate()
{
	return this->endstate_.get();
}

void ent_animation::
endstate(const endstate_type& x)
{
	this->endstate_.set(x);
}

const ent_animation::frames_type& ent_animation::
frames() const
{
	return this->frames_.get();
}

ent_animation::frames_type& ent_animation::
frames()
{
	return this->frames_.get();
}

void ent_animation::
frames(const frames_type& x)
{
	this->frames_.set(x);
}

const ent_animation::speedMultiplier_type& ent_animation::
speedMultiplier() const
{
	return this->speedMultiplier_.get();
}

ent_animation::speedMultiplier_type& ent_animation::
speedMultiplier()
{
	return this->speedMultiplier_.get();
}

void ent_animation::
speedMultiplier(const speedMultiplier_type& x)
{
	this->speedMultiplier_.set(x);
}


// replace
// 

const replace::layer_type& replace::
layer() const
{
	return this->layer_.get();
}

replace::layer_type& replace::
layer()
{
	return this->layer_.get();
}

void replace::
layer(const layer_type& x)
{
	this->layer_.set(x);
}

const replace::image_type& replace::
image() const
{
	return this->image_.get();
}

replace::image_type& replace::
image()
{
	return this->image_.get();
}

void replace::
image(const image_type& x)
{
	this->image_.set(x);
}

const replace::x_type& replace::
x() const
{
	return this->x_.get();
}

replace::x_type& replace::
x()
{
	return this->x_.get();
}

void replace::
x(const x_type& x)
{
	this->x_.set(x);
}

const replace::y_type& replace::
y() const
{
	return this->y_.get();
}

replace::y_type& replace::
y()
{
	return this->y_.get();
}

void replace::
y(const y_type& x)
{
	this->y_.set(x);
}


// frame
// 

const frame::id_type& frame::
id() const
{
	return this->id_.get();
}

frame::id_type& frame::
id()
{
	return this->id_.get();
}

void frame::
id(const id_type& x)
{
	this->id_.set(x);
}

const frame::milliseconds_type& frame::
milliseconds() const
{
	return this->milliseconds_.get();
}

frame::milliseconds_type& frame::
milliseconds()
{
	return this->milliseconds_.get();
}

void frame::
milliseconds(const milliseconds_type& x)
{
	this->milliseconds_.set(x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// c_entity
//

c_entity::
c_entity(const ent_properties_type& ent_properties,
	const ent_points_type& ent_points,
	const ent_images_type& ent_images,
	const ent_layers_type& ent_layers,
	const ent_animations_type& ent_animations,
	const class_name_type& class_name,
	const type_type& type,
	const directions_type& directions)
	: ::xml_schema::type(),
	ent_properties_(ent_properties, this),
	ent_points_(ent_points, this),
	ent_images_(ent_images, this),
	ent_layers_(ent_layers, this),
	ent_animations_(ent_animations, this),
	class_name_(class_name, this),
	type_(type, this),
	directions_(directions, this)
{
}

c_entity::
c_entity(::std::auto_ptr< ent_properties_type > ent_properties,
	::std::auto_ptr< ent_points_type > ent_points,
	::std::auto_ptr< ent_images_type > ent_images,
	::std::auto_ptr< ent_layers_type > ent_layers,
	::std::auto_ptr< ent_animations_type > ent_animations,
	const class_name_type& class_name,
	const type_type& type,
	const directions_type& directions)
	: ::xml_schema::type(),
	ent_properties_(ent_properties, this),
	ent_points_(ent_points, this),
	ent_images_(ent_images, this),
	ent_layers_(ent_layers, this),
	ent_animations_(ent_animations, this),
	class_name_(class_name, this),
	type_(type, this),
	directions_(directions, this)
{
}

c_entity::
c_entity(const c_entity& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	ent_properties_(x.ent_properties_, f, this),
	ent_points_(x.ent_points_, f, this),
	ent_images_(x.ent_images_, f, this),
	ent_layers_(x.ent_layers_, f, this),
	ent_animations_(x.ent_animations_, f, this),
	class_name_(x.class_name_, f, this),
	type_(x.type_, f, this),
	directions_(x.directions_, f, this)
{
}

c_entity::
c_entity(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	ent_properties_(this),
	ent_points_(this),
	ent_images_(this),
	ent_layers_(this),
	ent_animations_(this),
	class_name_(this),
	type_(this),
	directions_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, true);
		this->parse(p, f);
	}
}

void c_entity::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// ent_properties
		//
		if (n.name() == "ent_properties" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_properties_type > r(
				ent_properties_traits::create(i, f, this));

			if (!ent_properties_.present())
			{
				this->ent_properties_.set(r);
				continue;
			}
		}

		// ent_points
		//
		if (n.name() == "ent_points" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_points_type > r(
				ent_points_traits::create(i, f, this));

			if (!ent_points_.present())
			{
				this->ent_points_.set(r);
				continue;
			}
		}

		// ent_images
		//
		if (n.name() == "ent_images" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_images_type > r(
				ent_images_traits::create(i, f, this));

			if (!ent_images_.present())
			{
				this->ent_images_.set(r);
				continue;
			}
		}

		// ent_layers
		//
		if (n.name() == "ent_layers" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_layers_type > r(
				ent_layers_traits::create(i, f, this));

			if (!ent_layers_.present())
			{
				this->ent_layers_.set(r);
				continue;
			}
		}

		// ent_animations
		//
		if (n.name() == "ent_animations" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_animations_type > r(
				ent_animations_traits::create(i, f, this));

			if (!ent_animations_.present())
			{
				this->ent_animations_.set(r);
				continue;
			}
		}

		break;
	}

	if (!ent_properties_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"ent_properties",
			"");
	}

	if (!ent_points_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"ent_points",
			"");
	}

	if (!ent_images_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"ent_images",
			"");
	}

	if (!ent_layers_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"ent_layers",
			"");
	}

	if (!ent_animations_.present())
	{
		throw ::xsd::cxx::tree::expected_element< char >(
			"ent_animations",
			"");
	}

	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "class_name" && n.namespace_().empty())
		{
			this->class_name_.set(class_name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "type" && n.namespace_().empty())
		{
			this->type_.set(type_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "directions" && n.namespace_().empty())
		{
			this->directions_.set(directions_traits::create(i, f, this));
			continue;
		}
	}

	if (!class_name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"class_name",
			"");
	}

	if (!type_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"type",
			"");
	}

	if (!directions_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"directions",
			"");
	}
}

c_entity* c_entity::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class c_entity(*this, f, c);
}

c_entity& c_entity::
operator= (const c_entity& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->ent_properties_ = x.ent_properties_;
		this->ent_points_ = x.ent_points_;
		this->ent_images_ = x.ent_images_;
		this->ent_layers_ = x.ent_layers_;
		this->ent_animations_ = x.ent_animations_;
		this->class_name_ = x.class_name_;
		this->type_ = x.type_;
		this->directions_ = x.directions_;
	}

	return *this;
}

c_entity::
~c_entity()
{
}

// ent_properties
//

ent_properties::
ent_properties()
	: ::xml_schema::type(),
	ent_property_(this)
{
}

ent_properties::
ent_properties(const ent_properties& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	ent_property_(x.ent_property_, f, this)
{
}

ent_properties::
ent_properties(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	ent_property_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
		this->parse(p, f);
	}
}

void ent_properties::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// ent_property
		//
		if (n.name() == "ent_property" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_property_type > r(
				ent_property_traits::create(i, f, this));

			this->ent_property_.push_back(r);
			continue;
		}

		break;
	}
}

ent_properties* ent_properties::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_properties(*this, f, c);
}

ent_properties& ent_properties::
operator= (const ent_properties& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->ent_property_ = x.ent_property_;
	}

	return *this;
}

ent_properties::
~ent_properties()
{
}

// ent_points
//

ent_points::
ent_points()
	: ::xml_schema::type(),
	ent_point_(this)
{
}

ent_points::
ent_points(const ent_points& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	ent_point_(x.ent_point_, f, this)
{
}

ent_points::
ent_points(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	ent_point_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
		this->parse(p, f);
	}
}

void ent_points::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// ent_point
		//
		if (n.name() == "ent_point" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_point_type > r(
				ent_point_traits::create(i, f, this));

			this->ent_point_.push_back(r);
			continue;
		}

		break;
	}
}

ent_points* ent_points::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_points(*this, f, c);
}

ent_points& ent_points::
operator= (const ent_points& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->ent_point_ = x.ent_point_;
	}

	return *this;
}

ent_points::
~ent_points()
{
}

// ent_images
//

ent_images::
ent_images()
	: ::xml_schema::type(),
	ent_image_(this)
{
}

ent_images::
ent_images(const ent_images& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	ent_image_(x.ent_image_, f, this)
{
}

ent_images::
ent_images(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	ent_image_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
		this->parse(p, f);
	}
}

void ent_images::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// ent_image
		//
		if (n.name() == "ent_image" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_image_type > r(
				ent_image_traits::create(i, f, this));

			this->ent_image_.push_back(r);
			continue;
		}

		break;
	}
}

ent_images* ent_images::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_images(*this, f, c);
}

ent_images& ent_images::
operator= (const ent_images& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->ent_image_ = x.ent_image_;
	}

	return *this;
}

ent_images::
~ent_images()
{
}

// ent_layers
//

ent_layers::
ent_layers()
	: ::xml_schema::type(),
	ent_layer_(this)
{
}

ent_layers::
ent_layers(const ent_layers& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	ent_layer_(x.ent_layer_, f, this)
{
}

ent_layers::
ent_layers(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	ent_layer_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
		this->parse(p, f);
	}
}

void ent_layers::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// ent_layer
		//
		if (n.name() == "ent_layer" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_layer_type > r(
				ent_layer_traits::create(i, f, this));

			this->ent_layer_.push_back(r);
			continue;
		}

		break;
	}
}

ent_layers* ent_layers::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_layers(*this, f, c);
}

ent_layers& ent_layers::
operator= (const ent_layers& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->ent_layer_ = x.ent_layer_;
	}

	return *this;
}

ent_layers::
~ent_layers()
{
}

// ent_animations
//

ent_animations::
ent_animations()
	: ::xml_schema::type(),
	ent_animation_(this)
{
}

ent_animations::
ent_animations(const ent_animations& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	ent_animation_(x.ent_animation_, f, this)
{
}

ent_animations::
ent_animations(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	ent_animation_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
		this->parse(p, f);
	}
}

void ent_animations::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// ent_animation
		//
		if (n.name() == "ent_animation" && n.namespace_().empty())
		{
			::std::auto_ptr< ent_animation_type > r(
				ent_animation_traits::create(i, f, this));

			this->ent_animation_.push_back(r);
			continue;
		}

		break;
	}
}

ent_animations* ent_animations::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_animations(*this, f, c);
}

ent_animations& ent_animations::
operator= (const ent_animations& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->ent_animation_ = x.ent_animation_;
	}

	return *this;
}

ent_animations::
~ent_animations()
{
}

// ent_property
//

ent_property::
ent_property(const name_type& name,
	const value_type& value)
	: ::xml_schema::type(),
	name_(name, this),
	value_(value, this)
{
}

ent_property::
ent_property(const ent_property& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	name_(x.name_, f, this),
	value_(x.value_, f, this)
{
}

ent_property::
ent_property(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	name_(this),
	value_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void ent_property::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "value" && n.namespace_().empty())
		{
			this->value_.set(value_traits::create(i, f, this));
			continue;
		}
	}

	if (!name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"name",
			"");
	}

	if (!value_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"value",
			"");
	}
}

ent_property* ent_property::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_property(*this, f, c);
}

ent_property& ent_property::
operator= (const ent_property& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->name_ = x.name_;
		this->value_ = x.value_;
	}

	return *this;
}

ent_property::
~ent_property()
{
}

// ent_point
//

ent_point::
ent_point(const id_type& id,
	const type_type& type,
	const x_type& x,
	const y_type& y)
	: ::xml_schema::type(),
	id_(id, this),
	type_(type, this),
	x_(x, this),
	y_(y, this)
{
}

ent_point::
ent_point(const ent_point& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	id_(x.id_, f, this),
	type_(x.type_, f, this),
	x_(x.x_, f, this),
	y_(x.y_, f, this)
{
}

ent_point::
ent_point(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	id_(this),
	type_(this),
	x_(this),
	y_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void ent_point::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "type" && n.namespace_().empty())
		{
			this->type_.set(type_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "x" && n.namespace_().empty())
		{
			this->x_.set(x_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "y" && n.namespace_().empty())
		{
			this->y_.set(y_traits::create(i, f, this));
			continue;
		}
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!type_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"type",
			"");
	}

	if (!x_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"x",
			"");
	}

	if (!y_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"y",
			"");
	}
}

ent_point* ent_point::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_point(*this, f, c);
}

ent_point& ent_point::
operator= (const ent_point& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->id_ = x.id_;
		this->type_ = x.type_;
		this->x_ = x.x_;
		this->y_ = x.y_;
	}

	return *this;
}

ent_point::
~ent_point()
{
}

// ent_image
//

ent_image::
ent_image(const id_type& id,
	const file_type& file,
	const drawmode_type& drawmode,
	const reverse_type& reverse,
	const frames_type& frames)
	: ::xml_schema::type(),
	id_(id, this),
	file_(file, this),
	drawmode_(drawmode, this),
	reverse_(reverse, this),
	frames_(frames, this)
{
}

ent_image::
ent_image(const ent_image& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	id_(x.id_, f, this),
	file_(x.file_, f, this),
	drawmode_(x.drawmode_, f, this),
	reverse_(x.reverse_, f, this),
	frames_(x.frames_, f, this)
{
}

ent_image::
ent_image(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	id_(this),
	file_(this),
	drawmode_(this),
	reverse_(this),
	frames_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void ent_image::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "file" && n.namespace_().empty())
		{
			this->file_.set(file_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "drawmode" && n.namespace_().empty())
		{
			this->drawmode_.set(drawmode_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "reverse" && n.namespace_().empty())
		{
			this->reverse_.set(reverse_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "frames" && n.namespace_().empty())
		{
			this->frames_.set(frames_traits::create(i, f, this));
			continue;
		}
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!file_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"file",
			"");
	}

	if (!drawmode_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"drawmode",
			"");
	}

	if (!reverse_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"reverse",
			"");
	}

	if (!frames_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"frames",
			"");
	}
}

ent_image* ent_image::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_image(*this, f, c);
}

ent_image& ent_image::
operator= (const ent_image& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->id_ = x.id_;
		this->file_ = x.file_;
		this->drawmode_ = x.drawmode_;
		this->reverse_ = x.reverse_;
		this->frames_ = x.frames_;
	}

	return *this;
}

ent_image::
~ent_image()
{
}

// ent_layer
//

ent_layer::
ent_layer(const id_type& id,
	const name_type& name,
	const image_type& image,
	const x_type& x,
	const y_type& y)
	: ::xml_schema::type(),
	id_(id, this),
	name_(name, this),
	image_(image, this),
	x_(x, this),
	y_(y, this)
{
}

ent_layer::
ent_layer(const ent_layer& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	id_(x.id_, f, this),
	name_(x.name_, f, this),
	image_(x.image_, f, this),
	x_(x.x_, f, this),
	y_(x.y_, f, this)
{
}

ent_layer::
ent_layer(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	id_(this),
	name_(this),
	image_(this),
	x_(this),
	y_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void ent_layer::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "image" && n.namespace_().empty())
		{
			this->image_.set(image_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "x" && n.namespace_().empty())
		{
			this->x_.set(x_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "y" && n.namespace_().empty())
		{
			this->y_.set(y_traits::create(i, f, this));
			continue;
		}
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"name",
			"");
	}

	if (!image_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image",
			"");
	}

	if (!x_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"x",
			"");
	}

	if (!y_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"y",
			"");
	}
}

ent_layer* ent_layer::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_layer(*this, f, c);
}

ent_layer& ent_layer::
operator= (const ent_layer& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->id_ = x.id_;
		this->name_ = x.name_;
		this->image_ = x.image_;
		this->x_ = x.x_;
		this->y_ = x.y_;
	}

	return *this;
}

ent_layer::
~ent_layer()
{
}

// ent_animation
//

ent_animation::
ent_animation(const id_type& id,
	const name_type& name,
	const startstate_type& startstate,
	const endstate_type& endstate,
	const frames_type& frames,
	const speedMultiplier_type& speedMultiplier)
	: ::xml_schema::type(),
	replace_(this),
	frame_(this),
	id_(id, this),
	name_(name, this),
	startstate_(startstate, this),
	endstate_(endstate, this),
	frames_(frames, this),
	speedMultiplier_(speedMultiplier, this)
{
}

ent_animation::
ent_animation(const ent_animation& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	replace_(x.replace_, f, this),
	frame_(x.frame_, f, this),
	id_(x.id_, f, this),
	name_(x.name_, f, this),
	startstate_(x.startstate_, f, this),
	endstate_(x.endstate_, f, this),
	frames_(x.frames_, f, this),
	speedMultiplier_(x.speedMultiplier_, f, this)
{
}

ent_animation::
ent_animation(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	replace_(this),
	frame_(this),
	id_(this),
	name_(this),
	startstate_(this),
	endstate_(this),
	frames_(this),
	speedMultiplier_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, true);
		this->parse(p, f);
	}
}

void ent_animation::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// replace
		//
		if (n.name() == "replace" && n.namespace_().empty())
		{
			::std::auto_ptr< replace_type > r(
				replace_traits::create(i, f, this));

			this->replace_.push_back(r);
			continue;
		}

		// frame
		//
		if (n.name() == "frame" && n.namespace_().empty())
		{
			::std::auto_ptr< frame_type > r(
				frame_traits::create(i, f, this));

			this->frame_.push_back(r);
			continue;
		}

		break;
	}

	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "startstate" && n.namespace_().empty())
		{
			this->startstate_.set(startstate_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "endstate" && n.namespace_().empty())
		{
			this->endstate_.set(endstate_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "frames" && n.namespace_().empty())
		{
			this->frames_.set(frames_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "speedMultiplier" && n.namespace_().empty())
		{
			this->speedMultiplier_.set(speedMultiplier_traits::create(i, f, this));
			continue;
		}
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!name_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"name",
			"");
	}

	if (!startstate_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"startstate",
			"");
	}

	if (!endstate_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"endstate",
			"");
	}

	if (!frames_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"frames",
			"");
	}

	if (!speedMultiplier_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"speedMultiplier",
			"");
	}
}

ent_animation* ent_animation::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class ent_animation(*this, f, c);
}

ent_animation& ent_animation::
operator= (const ent_animation& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->replace_ = x.replace_;
		this->frame_ = x.frame_;
		this->id_ = x.id_;
		this->name_ = x.name_;
		this->startstate_ = x.startstate_;
		this->endstate_ = x.endstate_;
		this->frames_ = x.frames_;
		this->speedMultiplier_ = x.speedMultiplier_;
	}

	return *this;
}

ent_animation::
~ent_animation()
{
}

// replace
//

replace::
replace(const layer_type& layer,
	const image_type& image,
	const x_type& x,
	const y_type& y)
	: ::xml_schema::type(),
	layer_(layer, this),
	image_(image, this),
	x_(x, this),
	y_(y, this)
{
}

replace::
replace(const replace& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	layer_(x.layer_, f, this),
	image_(x.image_, f, this),
	x_(x.x_, f, this),
	y_(x.y_, f, this)
{
}

replace::
replace(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	layer_(this),
	image_(this),
	x_(this),
	y_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void replace::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "layer" && n.namespace_().empty())
		{
			this->layer_.set(layer_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "image" && n.namespace_().empty())
		{
			this->image_.set(image_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "x" && n.namespace_().empty())
		{
			this->x_.set(x_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "y" && n.namespace_().empty())
		{
			this->y_.set(y_traits::create(i, f, this));
			continue;
		}
	}

	if (!layer_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"layer",
			"");
	}

	if (!image_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"image",
			"");
	}

	if (!x_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"x",
			"");
	}

	if (!y_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"y",
			"");
	}
}

replace* replace::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class replace(*this, f, c);
}

replace& replace::
operator= (const replace& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->layer_ = x.layer_;
		this->image_ = x.image_;
		this->x_ = x.x_;
		this->y_ = x.y_;
	}

	return *this;
}

replace::
~replace()
{
}

// frame
//

frame::
frame(const id_type& id,
	const milliseconds_type& milliseconds)
	: ::xml_schema::type(),
	id_(id, this),
	milliseconds_(milliseconds, this)
{
}

frame::
frame(const frame& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	id_(x.id_, f, this),
	milliseconds_(x.milliseconds_, f, this)
{
}

frame::
frame(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	id_(this),
	milliseconds_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void frame::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "milliseconds" && n.namespace_().empty())
		{
			this->milliseconds_.set(milliseconds_traits::create(i, f, this));
			continue;
		}
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!milliseconds_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"milliseconds",
			"");
	}
}

frame* frame::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class frame(*this, f, c);
}

frame& frame::
operator= (const frame& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->id_ = x.id_;
		this->milliseconds_ = x.milliseconds_;
	}

	return *this;
}

frame::
~frame()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::c_entity >
c_entity_(const ::std::string& u,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

	return ::std::auto_ptr< ::c_entity >(
		::c_entity_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_entity >
c_entity_(const ::std::string& u,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_entity >(
		::c_entity_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_entity >
c_entity_(const ::std::string& u,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_entity >(
		::c_entity_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_entity >
c_entity_(::std::istream& is,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_entity_(isrc, f, p);
}

::std::auto_ptr< ::c_entity >
c_entity_(::std::istream& is,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_entity_(isrc, h, f, p);
}

::std::auto_ptr< ::c_entity >
c_entity_(::std::istream& is,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_entity_(isrc, h, f, p);
}

::std::auto_ptr< ::c_entity >
c_entity_(::std::istream& is,
	const ::std::string& sid,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_entity_(isrc, f, p);
}

::std::auto_ptr< ::c_entity >
c_entity_(::std::istream& is,
	const ::std::string& sid,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_entity_(isrc, h, f, p);
}

::std::auto_ptr< ::c_entity >
c_entity_(::std::istream& is,
	const ::std::string& sid,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_entity_(isrc, h, f, p);
}

::std::auto_ptr< ::c_entity >
c_entity_(::xercesc::InputSource& i,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

	return ::std::auto_ptr< ::c_entity >(
		::c_entity_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_entity >
c_entity_(::xercesc::InputSource& i,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_entity >(
		::c_entity_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_entity >
c_entity_(::xercesc::InputSource& i,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_entity >(
		::c_entity_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_entity >
c_entity_(const ::xercesc::DOMDocument& doc,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	if (f & ::xml_schema::flags::keep_dom)
	{
		::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
			static_cast<::xercesc::DOMDocument*> (doc.cloneNode(true)));

		return ::std::auto_ptr< ::c_entity >(
			::c_entity_(
				d, f | ::xml_schema::flags::own_dom, p));
	}

	const ::xercesc::DOMElement& e(*doc.getDocumentElement());
	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (n.name() == "c_entity" &&
		n.namespace_() == "")
	{
		::std::auto_ptr< ::c_entity > r(
			::xsd::cxx::tree::traits< ::c_entity, char >::create(
				e, f, 0));
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char >(
		n.name(),
		n.namespace_(),
		"c_entity",
		"");
}

::std::auto_ptr< ::c_entity >
c_entity_(::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
	::xml_schema::flags f,
	const ::xml_schema::properties&)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c(
		((f & ::xml_schema::flags::keep_dom) &&
			!(f & ::xml_schema::flags::own_dom))
		? static_cast<::xercesc::DOMDocument*> (d->cloneNode(true))
		: 0);

	::xercesc::DOMDocument& doc(c.get() ? *c : *d);
	const ::xercesc::DOMElement& e(*doc.getDocumentElement());

	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (f & ::xml_schema::flags::keep_dom)
		doc.setUserData(::xml_schema::dom::tree_node_key,
		(c.get() ? &c : &d),
			0);

	if (n.name() == "c_entity" &&
		n.namespace_() == "")
	{
		::std::auto_ptr< ::c_entity > r(
			::xsd::cxx::tree::traits< ::c_entity, char >::create(
				e, f, 0));
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char >(
		n.name(),
		n.namespace_(),
		"c_entity",
		"");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

