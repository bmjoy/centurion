#include <header.h>
#include <ui.h>

using namespace std;
using namespace glm;

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

/*
	---- DEBUG UI ----
	It shows some useful informations about the engine
	For example FPS, selected units, mouse position, etc.
*/

class Building;
class Unit;

namespace debug {

	class DebugUI {
	public:
		DebugUI();
		void setStatus(bool b) { debuguiIsActive = b; }
		bool getStatus() { return debuguiIsActive; }
		void create();
		void render(int fps, int mpfs, int selUnits);
		~DebugUI();
	private:
		// text
		array<string, 10> staticTextList;
		array<string, 10> dynamicTextList;
		vector<gui::SimpleText> staticText;
		gui::SimpleText dynamicText;
		gui::SimpleText debugText[2];
		float startX, startY, deltaY;
		int n;
		bool debuguiIsActive;
		// background
		gui::Rectangle back;
		string currentLan;
	};

	static DebugUI mydebugui;
	DebugUI *DEBUG_UI();

};

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

/*
	---- MENU UI  ----
	Most of the menu UI comes from the JSON files contained in assets/data/interface/
	But some parts are implemented here, e.g. the player list
*/

namespace menu {

	//
	//	PLAYERS LIST
	//

	class PlayersList {
	public:
		PlayersList();
		void create(int startX, int startY, vector<int> *players_color);
		void close();
		void picking(int *numPlayers, vector<int> *players_color, int clickId);
		void render(int numPlayers, vector<int> players_color, bool picking);
		string get_race(int i);
		~PlayersList();
	private:
		vector<gui::Select> colors_Form;
		vector<gui::Select> players_Form;
		vector<gui::Select> civiliz_Form;
		gui::SimpleText dynamicText;
		gui::Image arrowDown, arrowUp;
		gui::Rectangle background;
		float textWidth;
		int x, y, deltaY, w, h;
	};

	//
	//	GLOBAL OPTIONS 
	//

	class GlobalOptions {
	public:
		GlobalOptions();
		void create();		
		void render(bool pick);
		string currentLan;
		~GlobalOptions();
	private:
		gui::Rectangle back;
		gui::SimpleText text[10];
		gui::Select languages;	
		float startX, startY;
		void picking();
	};
};

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------


/*
	---- OBJECT UI (GAME) ----
*/

namespace game {
	class ObjectUI {
	public:
		ObjectUI();
		void create(string className);
		void render();
		~ObjectUI();
	private:
		gui::SimpleText objectName;
	};
}

/*
	---- GAME UI ----
*/

namespace game {

	//
	//	GAME MENU
	//

	class GameMenu {
	public:
		GameMenu();
		static bool IsActive() { return isActive; }
		static void Enable() { isActive = true; }
		static void Disable() { isActive = false; }
		void create();
		void render(bool picking);
		~GameMenu();
	private:
		gui::Button btn;
		gui::Rectangle background;
		vector<gui::Button> buttons;
		string s;
		float w, h, x, y;
		static bool isActive;
	};

	//
	//	GAME UI (Container class)
	//

	class UIGame {
	public:
		UIGame();
		void create(string race);
		void set_ui(ObjectUI* obj_ui);
		void render(bool pick);
		~UIGame();
	private:
		struct Time {
			double lastTime;
			string seconds_str, minutes_str, hours_str;
			int seconds, minutes, hours;
			gui::SimpleText text;
			float x;
			float y;
		} time;
		gui::Image top_bar;
		gui::Image bottom_bar;
		gui::Rectangle minimapRectangle;
		GameMenu gameMenu;

		ObjectUI objectUI;
		ObjectUI* objectUIptr;


		void picking(); // this function is here: source/picking/gameui_picking.cpp
		void calculateTime();
	};

	static UIGame myuigame;
	UIGame* GAME_UI();
};

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------


/*
	---- EDITOR UI ----
	It consists of:
	1) Editor menu (on the top bar);
	2) Editor tools 
*/


namespace editor {

	//
	//	EDITOR MENU
	//
	
	// extern editor variables 
	// all the definitions are in source/editor/editor_functions.cpp

	extern bool IsWindowOpened;
	extern bool QuestionWindowIsOpen;
	extern bool NewMapWindowIsOpen;
	extern bool NewMapResetText;
	extern bool PropertiesWindowIsOpen;
	extern bool PropertiesWindowResetText;
	extern string currentMapName;
	extern bool OpenMapWindowIsOpen;
	extern bool OpenMapWindowUpdate;
	extern vector<string> availableScenarios;
	extern bool AddObjectWindowIsOpen;
	extern bool AddObjectWindowUpdateForm1and2;
	extern bool AddObjectWindowUpdateForm2;
	extern bool TerrainBrushWindowIsOpen;
	extern bool TerrainBrushIsActive;
	extern bool menuIsOpened;
	extern bool addingObject;
	extern gui::SimpleText textInfo;

	static const int NumberOfObjects = 100;
	extern string EditorObjectStringListForm0[NumberOfObjects];
	extern string EditorObjectStringListForm1[NumberOfObjects];
	extern string EditorObjectStringListForm2[NumberOfObjects];

	extern vector<string> EditorAddObjectBuildingOptions;
	extern vector<string> EditorAddObjectUnitOptions;
	extern vector<string> EditorAddObjectDecorationOptions;

	//---------------------------------------------------

	struct menuData {
		vector<string> options;
		vector<string> hotkeys;
		vector<gui::Rectangle> optionsBack;
		vector<gui::SimpleText> optionsText;
		vector<gui::SimpleText> optionsHotKeysText;
		vector<ivec2> optionsPosition;
		gui::Rectangle titleBack;
		gui::SimpleText titleText;
		vec4 color;
		vec4 hoverColor;
		vec4 pickingColor;
		ivec2 titlePosition;
		string title;
		int titleWidth, titleHeight;
		int optionsWidth, optionsHeight, optionsHotKeysWidth;
		int optionsOffsetX;	
		int pickingID;
		bool isOpened;
	};

	class EditorMenu {
	public:
		EditorMenu();
		void create();
		void render(bool pick);
		void closeMenu();
		~EditorMenu();
	private:
		gui::Rectangle topBar;
		vec4 barColor;
		map<string, menuData> titles;
		array<string, 3> titlesList;
		map<string, int>pickingList;
		int barHeight;
		unsigned int minPickingID, maxPickingID;	

		void picking(); // this function is here: source/picking/editormenu_picking.cpp
		bool isHover(vec2 pos, int w, int h); // idem
	};

	//
	//  OPEN MAP WINDOW
	//

	struct MapList {
		vector<gui::Rectangle> back_options;
		vector<gui::SimpleText> text_options;
		gui::Rectangle back_picking;
		float padding_left, padding_top;
		float option_height;
		int pickingID;
	};

	class OpenMapWindow {
	public:
		OpenMapWindow();
		void create();
		void update();
		void render(bool pick);
		~OpenMapWindow();
	private:
		gui::Image back_image;
		gui::Image buttons[2];
		gui::SimpleText buttons_text[2];
		vec4 back_color;
		float startX, startY;
		MapList map_list;
		void picking();
		int selectedID;
	};

	//
	//	NEW MAP WINDOW
	//

	class NewMapWindow {
	public:
		NewMapWindow();
		void create();
		void render(bool pick);
		~NewMapWindow();
	private:
		gui::TextInput text_input;
		gui::Image back_image;
		gui::Image buttons[2];
		gui::Image textinput_back;
		gui::SimpleText buttons_text[2];
		gui::SimpleText text[2];
		float startX, startY;
		void picking();
	};

	//
	//	EDITOR QUESTION WINDOW
	//

	class QuestionWindow {
	public:
		QuestionWindow();
		void create();
		void render(bool pick);
		void setQuestion(string Question);
		~QuestionWindow();
	private:
		gui::TextInput text_input;
		gui::Image back_image;
		gui::Image buttons[2];
		gui::SimpleText buttons_text[2];
		gui::TextBox questionText;
		float startX, startY;
		string question;
		void picking();
	};

	static QuestionWindow myquestionwindow;
	QuestionWindow *Q_WINDOW();

	//
	//	EDITOR ADD OBJECT WINDOW
	//

	class AddObjectWindow {
	public:
		AddObjectWindow();
		void create();
		void render(bool pick);
		~AddObjectWindow();
	private:
		gui::Image back_image;	
		gui::Image object_thumbnail;
		gui::Image arrows[2];
		gui::Image buttons[2];
		gui::SimpleText buttons_text[2];
		gui::Select objectForms[3];
		float startX, startY;
		int pickingIDs[3];
		string formSelectedTexts[3];
		string selectedObject;
		ivec2 back_size;
		void picking();
		void update();
	};

	//
	//	PROPERTIES WINDOW
	//

	class PropertiesWindow {
	public:
		PropertiesWindow();
		void create();
		void render(bool pick);
		~PropertiesWindow();
	private:
		gui::TextInput text_input[2];
		gui::Image back_image;
		gui::Image buttons[2];
		gui::Image textinput_back[2];
		gui::SimpleText buttons_text[2];
		gui::SimpleText text[3];
		float startX, startY;
		void picking();
		Building *building_pointer;
		Unit *unit_pointer;
		string type;
	};

	//
	//	TERRAIN BRUSH WINDOW
	//

	class TerrainBrushWindow {
	public:
		TerrainBrushWindow();
		void create();
		void render(bool pick);
		~TerrainBrushWindow();
	private:
		string selBrush;
		gui::Rectangle back;
		vector<gui::Select> forms;
		gui::Circle circle;
		float startX, startY;
		void picking();
	};

	//
	//  EDITOR UI (CONTAINER)
	//

	class EditorUI {
	public:
		EditorUI();
		void create();
		void render(bool picking);
		void close_menu() { editor_menu.closeMenu(); }
		~EditorUI();
	private:
		EditorMenu editor_menu;
		OpenMapWindow open_map_window;
		NewMapWindow new_map_window;
		AddObjectWindow add_object_window;
		PropertiesWindow properties_window;
		TerrainBrushWindow terrainbrush_window;
		gui::Rectangle minimapRectangle;
	};

	static EditorUI myeditorUI;
	EditorUI *EDITOR_UI();
};

