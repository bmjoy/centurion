#pragma once

#include <headers>
#include "../audio/music.h"

using namespace std;
using namespace glm;

/*
	AUDIO MANAGER --> source/primitives/audio_manager.cpp
*/

class AudioManager {
public:
	AudioManager();
	void MusicStop();
	void MusicPause();
	void MusicRewind();
	void MusicLoop(bool loop);
	void MusicPlay(string name, bool looping = true);
	void MusicVolume(int value);
	void Playlist();
	bool IsMusicPlaying();
	bool IsMusicLooping();
	~AudioManager();
private:
	IMusic *music;
	AudioDevice *device;
};

/* 
	SHADER --> source/primitives/shader.cpp
*/

class Shader{
public:
    Shader();
    void compile();
    void apply_projection_matrix(mat4 mat = mat4(1.0f));
    void apply_view_matrix(mat4 mat = mat4(1.0f));
    void apply_model_matrix(mat4 mat = mat4(1.0f));
    ~Shader();

protected:
    const char* vPath;
    const char* fPath;
    int shaderId;
    GLuint VAO, VBO, IBO;
    vector<GLuint> textureIdList;
    map<string, GLuint> textureIdMap;
    vector<ivec3> textureInfoList; // width, height, nrChannels

private:
    int success;
    char infoLog[512];
    int vertexShader, fragmentShader;
    const GLchar* vShaderCode;
    const GLchar* fShaderCode;
};

/*
	BITMAP FONT --> source/primitives/bitmap_font.cpp
*/

namespace txt {
	bool isArabic(int codepoint);

	struct CharData {
		int charWidth[256];
		float fontHeight;
		float fontWidth;
		int startChar;
	};

	struct Character {
		int x, y, width, height, xoffset, yoffset, xadvance, line_height, base_width;
	};

	struct StaticData {
		vector<float> X;
		vector<float> Y;
		vector<Character> charList;
		vector<int> charsWidth;
		GLint textureID;
		vec4 color;
		float y;
		int textSize;
		int totalWidth;
		int startChar;
		int fontHeight;
		bool shadow;
	};
};


class BitmapFont : public Shader
{
public:
	BitmapFont();
	void set_align(string hAlign = "left", string vAlign = "normal");
	void create();
	void render_dynamic(string &font, float xPos, float yPos, string &text, vec4 &color, bool shadow, bool bold = false);
	txt::StaticData create_static(string &font, string &text, float x, float y, bool bold = false, int line_number = 0);
	void render_static(txt::StaticData &data);
	int getShaderId() { return shaderId; }
	~BitmapFont();

private:
	map<int, txt::Character> fontData[10];
	map<string, int> fontIdMap;
	string h_align, v_align, path;
	int total_width;
	int offset_x;
	map<string, int> hAlignMap;
	map<string, int> vAlignMap;
};

/*
	BUILDING SPRITE --> source/primitives/building_sprite.cpp
*/

class BuildingSprite : public Shader
{
public:
	BuildingSprite();
	BuildingSprite(int shaderID);
	void addPath(string Path) { entPathList.push_back(Path); }
	GLuint getTextureId(string className);
	void create();
	void render(GLuint texID, bool clickable, float x, float y, float w, float h, bool picking, int pickingId, bool selected, vec3 *playerColor, bool not_placeable = false);
	~BuildingSprite();

private:
	vector<string> entPathList;
	string texturePath;       // texture path

	unsigned char *data;
	unsigned int indices[6] = {
		0, 1, 3,   // first triangle
		1, 2, 3    // second triangle
	};
	GLfloat vertices[20] = {
		// positions				// uv coords		
		-0.5f,		-0.5f,		0.0f,		0.0f, 1.0,   // in basso a sx
		0.5f,		-0.5f,		0.0f,		1.0, 1.0,    // in basso a dx
		0.5f,		0.5f,		0.0f,		1.0, 0.0f,   // in alto a dx
		-0.5f,		0.5f,		0.0f,		0.0f, 0.0f   // in alto a sx
	};

	int r, g, b;

	void genBuffers();
};

/*
	CURSOR IMAGE --> source/primitives/cursor_image.cpp
*/

class CursorImage : public Shader
{
public:
	CursorImage();
	void create();
	void render(float x, float y, string &currentState);
	~CursorImage();
private:
	float w, h;
	/* texture variables */
	string initPath;
	array<string, 3> texturePaths;
	array<string, 3> textureNames;
};

/*
	EMPTY CIRCLE --> source/primitives/empty_circle.cpp
*/

struct CircleData {
	vec4 borderColor, backColor;
	string type;
	float x, y, w, h;
	float borderWidth;
	int origin;
};

class EmptyCircle : public Shader
{
public:
	EmptyCircle();
	void create();
	void render(CircleData &data);
	~EmptyCircle();
};

/*
	EMPTY RECTANGLE --> source/primitives/empty_rectangle.cpp
*/

struct RectangleData {
	vec4 borderColor, backColor, pickingColor;
	string type;
	float x, y, w, h;
	int origin;
};

class EmptyRectangle : public Shader
{
public:
	EmptyRectangle();
	void create();
	void render(RectangleData &data);
	~EmptyRectangle();
private:
	float vertices[24];
};

/*
	FILLED RECTANGLE --> source/primitives/filled_rectangle.cpp
*/

class FilledRectangle : public Shader
{
public:
	FilledRectangle();
	void create();
	void render(RectangleData &data, bool picking);
	~FilledRectangle();
};

/*
	GRID --> source/primitives/grid.cpp
*/ 

class Grid : public Shader
{
public:
	Grid();
	void create();
	void reset();
	void update();
	void render();
	~Grid();
};

/*
	MINIMAP PRERENDER --> source/primitives/minimap_rectangle.cpp
*/

class MinimapRectangle : public Shader
{
public:
	MinimapRectangle();
	void create();
	void update();
	void render();
	~MinimapRectangle();
};


/*
	IMAGE SPRITE --> source/primitives/image_sprite.cpp
*/

struct ImageData {
	vec3 pickingColor;
	string imageName;
	float x, y, w, h;
	int pickingID;
	int origin;
	GLuint textureID;
};

class ImageSprite : public Shader
{
public:
	ImageSprite();
	void addPath(string imageName, string path) { imagesPathMap[imageName] = path; }
	void create();
	void getImageData(ImageData *d);
	void render(ImageData &imageData, bool picking = false);
	~ImageSprite();

private:
	map<string, string> imagesPathMap;
	map<GLuint, int[2]> imageSize;

	unsigned char *data;
	unsigned int indices[6] = {
		0, 1, 3,   // first triangle
		1, 2, 3    // second triangle
	};
	GLfloat vertices[20] = {
		// positions			// uv coords		
		0.f,	0.f,	0.f,	0.f, 1.f,	// in basso a sx
		1.f,	0.f,	0.f,	1.f, 1.f,	// in basso a dx
		1.f,	1.f,	0.f,	1.f, 0.f,	// in alto a dx
		0.f,	1.f,	0.f,	0.f, 0.f	// in alto a sx
	};

	void genBuffers();
};

/*
	LIGHT --> source/primitives/light.cpp
*/

class Light
{
public:
	Light();
	Light(GLfloat red, GLfloat green, GLfloat blue, GLfloat aIntensity,  //ambient
		GLfloat xDir, GLfloat yDir, GLfloat zDir, GLfloat dIntensity); //diffuse

	void use_light(GLfloat ambientIntensityLocation, GLfloat ambientColorLocation,  //ambient
		GLfloat diffuseIntensityLocation, GLfloat directionLocation);    //diffuse
	~Light();
private:
	// ambient light
	vec3 colour;
	GLfloat ambientIntensity;

	// diffuse light
	vec3 direction;
	GLfloat diffuseIntensity;
};

/*
	TERRAIN --> source/primitives/terrain.cpp
*/

struct terrainTexture {
	vector<string> zones;
	vector<float> frequencies;
	string name;
	int id;
};

class Terrain : public Shader
{
public:
	Terrain();
	void addPath(string terrainID, string path) { terrainPathMap[terrainID] = path; }
	vector<string> getTerrainList() { return texturesName; }
	void create();
	void updateHeightsBuffer();
	void updateTextureBuffer();
	void render(bool tracing);
	~Terrain();

private:
	map<string, string> terrainPathMap;
	float randomX, randomY;
	GLuint VerticesVBO, HeightsVBO, TexturesVBO;
	int randomPos;
	void genBuffers();

	vector<string> texturesName;
	float width, height;

	// light 
	Light light = Light(1.0f, 1.0f, 1.0f, 0.0f,   // ambient light
		0.0f, 0.0f, 1.0f, 1.0f);  // diffuse light (important for pseudo shadows)
};

/*
	UNIT SPRITE --> source/primitives/unit_sprite.cpp
*/

struct UnitData {
	map<int, int[2]> spriteSize;
	map<int, int> Frames;
	map<int, int> Durations;
	map<string, int> States;
	vec3 playerColor;
	vec3 pickingColor;
	string className;
	int hitBox[2];
	GLint currentState;
	int currentFrame;
	int currentDir;
	int yOffset;
	int maxDirections;
	GLuint textureID;
};

class UnitSprite : public Shader
{
public:
	UnitSprite();
	UnitSprite(int shaderID);
	void addPath(string Path) { entPathList.push_back(Path); }
	void create();
	void getTextureInfo(UnitData *uData);
	void render(UnitData d, vec3 &pos, bool picking);
	~UnitSprite();

private:
	vector<string> entPathList;
	map<string, int[2]> spriteSize;

	unsigned char *data;
	unsigned int indices[6] = {
		0, 1, 3,   // first triangle
		1, 2, 3    // second triangle
	};
	GLfloat vertices[20] = {
		// positions				// uv coords		
		-0.5f,		-0.5f,		0.0f,		0.0f, 1.0,   // in basso a sx
		0.5f,		-0.5f,		0.0f,		1.0, 1.0,    // in basso a dx
		0.5f,		0.5f,		0.0f,		1.0, 0.0f,   // in alto a dx
		-0.5f,		0.5f,		0.0f,		0.0f, 0.0f   // in alto a sx
	};

	void genBuffers();
};

struct DecorationData {
	string className;
	vec2 position;
	int width;
	int height;
	GLuint textureID;
};

class DecorationSprite : public Shader
{
public:
	DecorationSprite();
	void addPath(string Path) { entPathList.push_back(Path); }
	GLuint getTextureID(string classname);
	void create();
	void render(DecorationData d, bool not_placeable = false);
	~DecorationSprite();

private:
	vector<string> entPathList;
	map<string, int[2]> spriteSize;

	unsigned char *data;
	unsigned int indices[6] = {
		0, 1, 3,   // first triangle
		1, 2, 3    // second triangle
	};
	GLfloat vertices[20] = {
		// positions				// uv coords		
		-0.5f,		-0.5f,		0.0f,		0.0f, 1.0,   // in basso a sx
		0.5f,		-0.5f,		0.0f,		1.0, 1.0,    // in basso a dx
		0.5f,		0.5f,		0.0f,		1.0, 0.0f,   // in alto a dx
		-0.5f,		0.5f,		0.0f,		0.0f, 0.0f   // in alto a sx
	};

	void genBuffers();
};
