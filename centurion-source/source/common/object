#pragma once

#include <gui>
#include <json.hpp>

using namespace std;
using namespace glm;

namespace unit { class Unit; };
namespace building { class Building; };

class Player;

//
//	GAME OBJECT --> source/object.cpp
//

class GObject {
public:
	GObject();
	void set_position(vec3 pos);
	vec3 get_position() { return position; }
	void set_class(string class_name);
	void set_player(int player_id);
	int get_playerID() { return playerID; }
	void set_id(int pickingId);
	int get_id() { return picking_id; }
	bool isSelected() { return selected; }
	int get_xPos() { return (int)position.x; }
	int get_yPos() { return (int)position.y; }
	string get_class() { return className; }
	string get_name() { return name; }
	void set_name(string Name) { name = Name; }
	string get_type() { return type; }
	void set_type(string Type) { type = Type; }
	~GObject();
protected:
	Player *player;
	int playerID;
	vec3 pickingColor;
	bool selected;
	json data;
	vec3 position;
	string className;
	int picking_id;
	string name, type;
};

//
//	BUILDING --> source/building/building.cpp
//

namespace building {
	class Building : public GObject
	{
	public:
		Building();
		void prepare();
		void create(string Name = "");
		void render(bool picking, int clickID, bool not_placeable = false);
		bool is_placeable();
		void set_placeable(bool b) { isPlaceable = b; }
		void update_pass();
		void clear_pass();
		void set_status(bool b) { isCreated = b; }
		bool is_central_building() { return isCentralBuilding; }
		void set_settlement_name(string s) { settl_name = s; }
		string get_settlement_name() { return settl_name; }
		void set_settlement_building(Building *b) { central_building = b; }
		Building *get_settlement_building() { return central_building; }
		bool is_near_to_central_building();
		int UnitsInBuilding();
		vector<unit::Unit> UnitsInHolder();
		vector<int> buildingsInSettlementIds();
		int buildingsInSettlementCount() { return (int)subs_buildings.size(); }
		void setWaitingToBeErased(bool b) { waitingToBeErased = b; }
		bool getWaitingToBeErased() { return waitingToBeErased; }
		~Building();

	private:
		vector<vector<int>> building_grid;
		vector<unit::Unit> unitsInside;
		map<int, Building*> subs_buildings; // not central buildings connected to central one
		int w, h, nrChannels;
		GLuint textureID;
		bool clickableInMinimap;
		bool isCentralBuilding;
		string settl_name;
		Building *central_building;
		bool waitingToBeErased;
		bool isCreated;
		size_t buildingListSize;
		bool isPlaceable;
		gui::Circle circle[2];
		//sound selectionSound; TODO
	};
};

//
//	UNIT  
//

namespace unit {

	// UNIT CLASS  --> source/unit/unit.cpp

	class Unit : public GObject
	{
	public:
		Unit();
		void create();
		void set_position(float x, float y);
		void render(bool picking, int clickID);
		~Unit();
	private:
		UnitData unitData;

		/* unit properties & data */
		string currentStateStr;
		json entityData;
		float creationTime;

		/* unit position */
		vec3 position2D, position3D;
		bool clickSelection, rectangleSelection;

		/* unit circle if selected */
		gui::Circle selectionCircle;

		/* unit movement & pathfinding */
		bool is_Moving;
		int pathCount;
		float angle, delta, distance, res_distance;
		vector<ivec2> path;
		vec2 startPoint, endPoint;
		void position_update();
		void walk_behaviour();

		/* debug objects */
		vector<gui::Rectangle> pathQuadsList;
		struct HitBox {
			gui::Rectangle rectangle;
			array<float, 8> coords;
		} hitbox;
		gui::Image circlePos;
	};


	// UNIT FUNCTIONS --> source/unit/functions.cpp

	void updateZ(vec3 &pos2d, vec3 *pos3d);
	void updateFrame(float *creationTime, int *frame, int max_frames, int duration);
	bool isInSelectionRect(array<float, 8> &coords);
	float getAngle(vector<ivec2> &path, int &n);
	float getDistance(vector<ivec2> &path, int &n);
	float getResDistance(vector<ivec2> &path, int &n, vec3 &pos2d);
	vector<ivec2> getPath(vec2 &start, vec2 &end);
};