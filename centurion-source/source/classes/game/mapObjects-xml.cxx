// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mapObjects-xml.hxx"

// c_mapObjects
// 

const c_mapObjects::object_sequence& c_mapObjects::
object() const
{
	return this->object_;
}

c_mapObjects::object_sequence& c_mapObjects::
object()
{
	return this->object_;
}

void c_mapObjects::
object(const object_sequence& s)
{
	this->object_ = s;
}

const c_mapObjects::settlement_sequence& c_mapObjects::
settlement() const
{
	return this->settlement_;
}

c_mapObjects::settlement_sequence& c_mapObjects::
settlement()
{
	return this->settlement_;
}

void c_mapObjects::
settlement(const settlement_sequence& s)
{
	this->settlement_ = s;
}


// object
// 

const object::class_type& object::
class_() const
{
	return this->class__.get();
}

object::class_type& object::
class_()
{
	return this->class__.get();
}

void object::
class_(const class_type& x)
{
	this->class__.set(x);
}

void object::
class_(::std::auto_ptr< class_type > x)
{
	this->class__.set(x);
}

const object::id_type& object::
id() const
{
	return this->id_.get();
}

object::id_type& object::
id()
{
	return this->id_.get();
}

void object::
id(const id_type& x)
{
	this->id_.set(x);
}

const object::healthperc_optional& object::
healthperc() const
{
	return this->healthperc_;
}

object::healthperc_optional& object::
healthperc()
{
	return this->healthperc_;
}

void object::
healthperc(const healthperc_type& x)
{
	this->healthperc_.set(x);
}

void object::
healthperc(const healthperc_optional& x)
{
	this->healthperc_ = x;
}

const object::player_type& object::
player() const
{
	return this->player_.get();
}

object::player_type& object::
player()
{
	return this->player_.get();
}

void object::
player(const player_type& x)
{
	this->player_.set(x);
}

const object::x_type& object::
x() const
{
	return this->x_.get();
}

object::x_type& object::
x()
{
	return this->x_.get();
}

void object::
x(const x_type& x)
{
	this->x_.set(x);
}

const object::y_type& object::
y() const
{
	return this->y_.get();
}

object::y_type& object::
y()
{
	return this->y_.get();
}

void object::
y(const y_type& x)
{
	this->y_.set(x);
}

const object::name_optional& object::
name() const
{
	return this->name_;
}

object::name_optional& object::
name()
{
	return this->name_;
}

void object::
name(const name_type& x)
{
	this->name_.set(x);
}

void object::
name(const name_optional& x)
{
	this->name_ = x;
}

void object::
name(::std::auto_ptr< name_type > x)
{
	this->name_.set(x);
}

const object::icon_optional& object::
icon() const
{
	return this->icon_;
}

object::icon_optional& object::
icon()
{
	return this->icon_;
}

void object::
icon(const icon_type& x)
{
	this->icon_.set(x);
}

void object::
icon(const icon_optional& x)
{
	this->icon_ = x;
}

void object::
icon(::std::auto_ptr< icon_type > x)
{
	this->icon_.set(x);
}


// settlement
// 

const settlement::object_sequence& settlement::
object() const
{
	return this->object_;
}

settlement::object_sequence& settlement::
object()
{
	return this->object_;
}

void settlement::
object(const object_sequence& s)
{
	this->object_ = s;
}

const settlement::class_type& settlement::
class_() const
{
	return this->class__.get();
}

settlement::class_type& settlement::
class_()
{
	return this->class__.get();
}

void settlement::
class_(const class_type& x)
{
	this->class__.set(x);
}

void settlement::
class_(::std::auto_ptr< class_type > x)
{
	this->class__.set(x);
}

const settlement::id_type& settlement::
id() const
{
	return this->id_.get();
}

settlement::id_type& settlement::
id()
{
	return this->id_.get();
}

void settlement::
id(const id_type& x)
{
	this->id_.set(x);
}

const settlement::player_type& settlement::
player() const
{
	return this->player_.get();
}

settlement::player_type& settlement::
player()
{
	return this->player_.get();
}

void settlement::
player(const player_type& x)
{
	this->player_.set(x);
}

const settlement::x_type& settlement::
x() const
{
	return this->x_.get();
}

settlement::x_type& settlement::
x()
{
	return this->x_.get();
}

void settlement::
x(const x_type& x)
{
	this->x_.set(x);
}

const settlement::y_type& settlement::
y() const
{
	return this->y_.get();
}

settlement::y_type& settlement::
y()
{
	return this->y_.get();
}

void settlement::
y(const y_type& x)
{
	this->y_.set(x);
}

const settlement::name_optional& settlement::
name() const
{
	return this->name_;
}

settlement::name_optional& settlement::
name()
{
	return this->name_;
}

void settlement::
name(const name_type& x)
{
	this->name_.set(x);
}

void settlement::
name(const name_optional& x)
{
	this->name_ = x;
}

void settlement::
name(::std::auto_ptr< name_type > x)
{
	this->name_.set(x);
}

const settlement::gold_type& settlement::
gold() const
{
	return this->gold_.get();
}

settlement::gold_type& settlement::
gold()
{
	return this->gold_.get();
}

void settlement::
gold(const gold_type& x)
{
	this->gold_.set(x);
}

settlement::gold_type settlement::
gold_default_value()
{
	return gold_type(0LL);
}

const settlement::food_type& settlement::
food() const
{
	return this->food_.get();
}

settlement::food_type& settlement::
food()
{
	return this->food_.get();
}

void settlement::
food(const food_type& x)
{
	this->food_.set(x);
}

settlement::food_type settlement::
food_default_value()
{
	return food_type(0LL);
}

const settlement::population_optional& settlement::
population() const
{
	return this->population_;
}

settlement::population_optional& settlement::
population()
{
	return this->population_;
}

void settlement::
population(const population_type& x)
{
	this->population_.set(x);
}

void settlement::
population(const population_optional& x)
{
	this->population_ = x;
}

const settlement::maxpopulation_optional& settlement::
maxpopulation() const
{
	return this->maxpopulation_;
}

settlement::maxpopulation_optional& settlement::
maxpopulation()
{
	return this->maxpopulation_;
}

void settlement::
maxpopulation(const maxpopulation_type& x)
{
	this->maxpopulation_.set(x);
}

void settlement::
maxpopulation(const maxpopulation_optional& x)
{
	this->maxpopulation_ = x;
}

const settlement::healthperc_type& settlement::
healthperc() const
{
	return this->healthperc_.get();
}

settlement::healthperc_type& settlement::
healthperc()
{
	return this->healthperc_.get();
}

void settlement::
healthperc(const healthperc_type& x)
{
	this->healthperc_.set(x);
}

settlement::healthperc_type settlement::
healthperc_default_value()
{
	return healthperc_type(100LL);
}

const settlement::icon_optional& settlement::
icon() const
{
	return this->icon_;
}

settlement::icon_optional& settlement::
icon()
{
	return this->icon_;
}

void settlement::
icon(const icon_type& x)
{
	this->icon_.set(x);
}

void settlement::
icon(const icon_optional& x)
{
	this->icon_ = x;
}

void settlement::
icon(::std::auto_ptr< icon_type > x)
{
	this->icon_.set(x);
}


// object1
// 

const object1::class_type& object1::
class_() const
{
	return this->class__.get();
}

object1::class_type& object1::
class_()
{
	return this->class__.get();
}

void object1::
class_(const class_type& x)
{
	this->class__.set(x);
}

void object1::
class_(::std::auto_ptr< class_type > x)
{
	this->class__.set(x);
}

const object1::id_type& object1::
id() const
{
	return this->id_.get();
}

object1::id_type& object1::
id()
{
	return this->id_.get();
}

void object1::
id(const id_type& x)
{
	this->id_.set(x);
}

const object1::healthperc_type& object1::
healthperc() const
{
	return this->healthperc_.get();
}

object1::healthperc_type& object1::
healthperc()
{
	return this->healthperc_.get();
}

void object1::
healthperc(const healthperc_type& x)
{
	this->healthperc_.set(x);
}

object1::healthperc_type object1::
healthperc_default_value()
{
	return healthperc_type(100LL);
}

const object1::player_type& object1::
player() const
{
	return this->player_.get();
}

object1::player_type& object1::
player()
{
	return this->player_.get();
}

void object1::
player(const player_type& x)
{
	this->player_.set(x);
}

const object1::x_type& object1::
x() const
{
	return this->x_.get();
}

object1::x_type& object1::
x()
{
	return this->x_.get();
}

void object1::
x(const x_type& x)
{
	this->x_.set(x);
}

const object1::y_type& object1::
y() const
{
	return this->y_.get();
}

object1::y_type& object1::
y()
{
	return this->y_.get();
}

void object1::
y(const y_type& x)
{
	this->y_.set(x);
}

const object1::name_optional& object1::
name() const
{
	return this->name_;
}

object1::name_optional& object1::
name()
{
	return this->name_;
}

void object1::
name(const name_type& x)
{
	this->name_.set(x);
}

void object1::
name(const name_optional& x)
{
	this->name_ = x;
}

void object1::
name(::std::auto_ptr< name_type > x)
{
	this->name_.set(x);
}

const object1::icon_optional& object1::
icon() const
{
	return this->icon_;
}

object1::icon_optional& object1::
icon()
{
	return this->icon_;
}

void object1::
icon(const icon_type& x)
{
	this->icon_.set(x);
}

void object1::
icon(const icon_optional& x)
{
	this->icon_ = x;
}

void object1::
icon(::std::auto_ptr< icon_type > x)
{
	this->icon_.set(x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// c_mapObjects
//

c_mapObjects::
c_mapObjects()
	: ::xml_schema::type(),
	object_(this),
	settlement_(this)
{
}

c_mapObjects::
c_mapObjects(const c_mapObjects& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	object_(x.object_, f, this),
	settlement_(x.settlement_, f, this)
{
}

c_mapObjects::
c_mapObjects(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	object_(this),
	settlement_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
		this->parse(p, f);
	}
}

void c_mapObjects::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// object
		//
		if (n.name() == "object" && n.namespace_().empty())
		{
			::std::auto_ptr< object_type > r(
				object_traits::create(i, f, this));

			this->object_.push_back(r);
			continue;
		}

		// settlement
		//
		if (n.name() == "settlement" && n.namespace_().empty())
		{
			::std::auto_ptr< settlement_type > r(
				settlement_traits::create(i, f, this));

			this->settlement_.push_back(r);
			continue;
		}

		break;
	}
}

c_mapObjects* c_mapObjects::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class c_mapObjects(*this, f, c);
}

c_mapObjects& c_mapObjects::
operator= (const c_mapObjects& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->object_ = x.object_;
		this->settlement_ = x.settlement_;
	}

	return *this;
}

c_mapObjects::
~c_mapObjects()
{
}

// object
//

object::
object(const class_type& class_,
	const id_type& id,
	const player_type& player,
	const x_type& x,
	const y_type& y)
	: ::xml_schema::type(),
	class__(class_, this),
	id_(id, this),
	healthperc_(this),
	player_(player, this),
	x_(x, this),
	y_(y, this),
	name_(this),
	icon_(this)
{
}

object::
object(const object& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	class__(x.class__, f, this),
	id_(x.id_, f, this),
	healthperc_(x.healthperc_, f, this),
	player_(x.player_, f, this),
	x_(x.x_, f, this),
	y_(x.y_, f, this),
	name_(x.name_, f, this),
	icon_(x.icon_, f, this)
{
}

object::
object(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	class__(this),
	id_(this),
	healthperc_(this),
	player_(this),
	x_(this),
	y_(this),
	name_(this),
	icon_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void object::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "class" && n.namespace_().empty())
		{
			this->class__.set(class_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "healthperc" && n.namespace_().empty())
		{
			this->healthperc_.set(healthperc_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "player" && n.namespace_().empty())
		{
			this->player_.set(player_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "x" && n.namespace_().empty())
		{
			this->x_.set(x_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "y" && n.namespace_().empty())
		{
			this->y_.set(y_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "icon" && n.namespace_().empty())
		{
			this->icon_.set(icon_traits::create(i, f, this));
			continue;
		}
	}

	if (!class__.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"class",
			"");
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!player_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"player",
			"");
	}

	if (!x_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"x",
			"");
	}

	if (!y_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"y",
			"");
	}
}

object* object::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class object(*this, f, c);
}

object& object::
operator= (const object& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->class__ = x.class__;
		this->id_ = x.id_;
		this->healthperc_ = x.healthperc_;
		this->player_ = x.player_;
		this->x_ = x.x_;
		this->y_ = x.y_;
		this->name_ = x.name_;
		this->icon_ = x.icon_;
	}

	return *this;
}

object::
~object()
{
}

// settlement
//

settlement::
settlement(const class_type& class_,
	const id_type& id,
	const player_type& player,
	const x_type& x,
	const y_type& y)
	: ::xml_schema::type(),
	object_(this),
	class__(class_, this),
	id_(id, this),
	player_(player, this),
	x_(x, this),
	y_(y, this),
	name_(this),
	gold_(gold_default_value(), this),
	food_(food_default_value(), this),
	population_(this),
	maxpopulation_(this),
	healthperc_(healthperc_default_value(), this),
	icon_(this)
{
}

settlement::
settlement(const settlement& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	object_(x.object_, f, this),
	class__(x.class__, f, this),
	id_(x.id_, f, this),
	player_(x.player_, f, this),
	x_(x.x_, f, this),
	y_(x.y_, f, this),
	name_(x.name_, f, this),
	gold_(x.gold_, f, this),
	food_(x.food_, f, this),
	population_(x.population_, f, this),
	maxpopulation_(x.maxpopulation_, f, this),
	healthperc_(x.healthperc_, f, this),
	icon_(x.icon_, f, this)
{
}

settlement::
settlement(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	object_(this),
	class__(this),
	id_(this),
	player_(this),
	x_(this),
	y_(this),
	name_(this),
	gold_(this),
	food_(this),
	population_(this),
	maxpopulation_(this),
	healthperc_(this),
	icon_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, true, false, true);
		this->parse(p, f);
	}
}

void settlement::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	for (; p.more_content(); p.next_content(false))
	{
		const ::xercesc::DOMElement& i(p.cur_element());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		// object
		//
		if (n.name() == "object" && n.namespace_().empty())
		{
			::std::auto_ptr< object_type > r(
				object_traits::create(i, f, this));

			this->object_.push_back(r);
			continue;
		}

		break;
	}

	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "class" && n.namespace_().empty())
		{
			this->class__.set(class_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "player" && n.namespace_().empty())
		{
			this->player_.set(player_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "x" && n.namespace_().empty())
		{
			this->x_.set(x_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "y" && n.namespace_().empty())
		{
			this->y_.set(y_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "gold" && n.namespace_().empty())
		{
			this->gold_.set(gold_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "food" && n.namespace_().empty())
		{
			this->food_.set(food_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "population" && n.namespace_().empty())
		{
			this->population_.set(population_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "maxpopulation" && n.namespace_().empty())
		{
			this->maxpopulation_.set(maxpopulation_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "healthperc" && n.namespace_().empty())
		{
			this->healthperc_.set(healthperc_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "icon" && n.namespace_().empty())
		{
			this->icon_.set(icon_traits::create(i, f, this));
			continue;
		}
	}

	if (!class__.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"class",
			"");
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!player_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"player",
			"");
	}

	if (!x_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"x",
			"");
	}

	if (!y_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"y",
			"");
	}

	if (!gold_.present())
	{
		this->gold_.set(gold_default_value());
	}

	if (!food_.present())
	{
		this->food_.set(food_default_value());
	}

	if (!healthperc_.present())
	{
		this->healthperc_.set(healthperc_default_value());
	}
}

settlement* settlement::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class settlement(*this, f, c);
}

settlement& settlement::
operator= (const settlement& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->object_ = x.object_;
		this->class__ = x.class__;
		this->id_ = x.id_;
		this->player_ = x.player_;
		this->x_ = x.x_;
		this->y_ = x.y_;
		this->name_ = x.name_;
		this->gold_ = x.gold_;
		this->food_ = x.food_;
		this->population_ = x.population_;
		this->maxpopulation_ = x.maxpopulation_;
		this->healthperc_ = x.healthperc_;
		this->icon_ = x.icon_;
	}

	return *this;
}

settlement::
~settlement()
{
}

// object1
//

object1::
object1(const class_type& class_,
	const id_type& id,
	const player_type& player,
	const x_type& x,
	const y_type& y)
	: ::xml_schema::type(),
	class__(class_, this),
	id_(id, this),
	healthperc_(healthperc_default_value(), this),
	player_(player, this),
	x_(x, this),
	y_(y, this),
	name_(this),
	icon_(this)
{
}

object1::
object1(const object1& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	class__(x.class__, f, this),
	id_(x.id_, f, this),
	healthperc_(x.healthperc_, f, this),
	player_(x.player_, f, this),
	x_(x.x_, f, this),
	y_(x.y_, f, this),
	name_(x.name_, f, this),
	icon_(x.icon_, f, this)
{
}

object1::
object1(const ::xercesc::DOMElement& e,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
	class__(this),
	id_(this),
	healthperc_(this),
	player_(this),
	x_(this),
	y_(this),
	name_(this),
	icon_(this)
{
	if ((f & ::xml_schema::flags::base) == 0)
	{
		::xsd::cxx::xml::dom::parser< char > p(e, false, false, true);
		this->parse(p, f);
	}
}

void object1::
parse(::xsd::cxx::xml::dom::parser< char >& p,
	::xml_schema::flags f)
{
	while (p.more_attributes())
	{
		const ::xercesc::DOMAttr& i(p.next_attribute());
		const ::xsd::cxx::xml::qualified_name< char > n(
			::xsd::cxx::xml::dom::name< char >(i));

		if (n.name() == "class" && n.namespace_().empty())
		{
			this->class__.set(class_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "id" && n.namespace_().empty())
		{
			this->id_.set(id_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "healthperc" && n.namespace_().empty())
		{
			this->healthperc_.set(healthperc_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "player" && n.namespace_().empty())
		{
			this->player_.set(player_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "x" && n.namespace_().empty())
		{
			this->x_.set(x_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "y" && n.namespace_().empty())
		{
			this->y_.set(y_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "name" && n.namespace_().empty())
		{
			this->name_.set(name_traits::create(i, f, this));
			continue;
		}

		if (n.name() == "icon" && n.namespace_().empty())
		{
			this->icon_.set(icon_traits::create(i, f, this));
			continue;
		}
	}

	if (!class__.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"class",
			"");
	}

	if (!id_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"id",
			"");
	}

	if (!healthperc_.present())
	{
		this->healthperc_.set(healthperc_default_value());
	}

	if (!player_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"player",
			"");
	}

	if (!x_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"x",
			"");
	}

	if (!y_.present())
	{
		throw ::xsd::cxx::tree::expected_attribute< char >(
			"y",
			"");
	}
}

object1* object1::
_clone(::xml_schema::flags f,
	::xml_schema::container* c) const
{
	return new class object1(*this, f, c);
}

object1& object1::
operator= (const object1& x)
{
	if (this != &x)
	{
		static_cast<::xml_schema::type&> (*this) = x;
		this->class__ = x.class__;
		this->id_ = x.id_;
		this->healthperc_ = x.healthperc_;
		this->player_ = x.player_;
		this->x_ = x.x_;
		this->y_ = x.y_;
		this->name_ = x.name_;
		this->icon_ = x.icon_;
	}

	return *this;
}

object1::
~object1()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(const ::std::string& u,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

	return ::std::auto_ptr< ::c_mapObjects >(
		::c_mapObjects_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(const ::std::string& u,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_mapObjects >(
		::c_mapObjects_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(const ::std::string& u,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			u, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_mapObjects >(
		::c_mapObjects_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::std::istream& is,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_mapObjects_(isrc, f, p);
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::std::istream& is,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_mapObjects_(isrc, h, f, p);
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::std::istream& is,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::sax::std_input_source isrc(is);
	return ::c_mapObjects_(isrc, h, f, p);
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::std::istream& is,
	const ::std::string& sid,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_mapObjects_(isrc, f, p);
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::std::istream& is,
	const ::std::string& sid,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0,
		(f & ::xml_schema::flags::keep_dom) == 0);

	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_mapObjects_(isrc, h, f, p);
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::std::istream& is,
	const ::std::string& sid,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
	return ::c_mapObjects_(isrc, h, f, p);
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::xercesc::InputSource& i,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

	return ::std::auto_ptr< ::c_mapObjects >(
		::c_mapObjects_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::xercesc::InputSource& i,
	::xml_schema::error_handler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_mapObjects >(
		::c_mapObjects_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::xercesc::InputSource& i,
	::xercesc::DOMErrorHandler& h,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::parse< char >(
			i, h, p, f));

	if (!d.get())
		throw ::xsd::cxx::tree::parsing< char >();

	return ::std::auto_ptr< ::c_mapObjects >(
		::c_mapObjects_(
			d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(const ::xercesc::DOMDocument& doc,
	::xml_schema::flags f,
	const ::xml_schema::properties& p)
{
	if (f & ::xml_schema::flags::keep_dom)
	{
		::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
			static_cast<::xercesc::DOMDocument*> (doc.cloneNode(true)));

		return ::std::auto_ptr< ::c_mapObjects >(
			::c_mapObjects_(
				d, f | ::xml_schema::flags::own_dom, p));
	}

	const ::xercesc::DOMElement& e(*doc.getDocumentElement());
	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (n.name() == "c_mapObjects" &&
		n.namespace_() == "")
	{
		::std::auto_ptr< ::c_mapObjects > r(
			::xsd::cxx::tree::traits< ::c_mapObjects, char >::create(
				e, f, 0));
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char >(
		n.name(),
		n.namespace_(),
		"c_mapObjects",
		"");
}

::std::auto_ptr< ::c_mapObjects >
c_mapObjects_(::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
	::xml_schema::flags f,
	const ::xml_schema::properties&)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c(
		((f & ::xml_schema::flags::keep_dom) &&
			!(f & ::xml_schema::flags::own_dom))
		? static_cast<::xercesc::DOMDocument*> (d->cloneNode(true))
		: 0);

	::xercesc::DOMDocument& doc(c.get() ? *c : *d);
	const ::xercesc::DOMElement& e(*doc.getDocumentElement());

	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (f & ::xml_schema::flags::keep_dom)
		doc.setUserData(::xml_schema::dom::tree_node_key,
		(c.get() ? &c : &d),
			0);

	if (n.name() == "c_mapObjects" &&
		n.namespace_() == "")
	{
		::std::auto_ptr< ::c_mapObjects > r(
			::xsd::cxx::tree::traits< ::c_mapObjects, char >::create(
				e, f, 0));
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char >(
		n.name(),
		n.namespace_(),
		"c_mapObjects",
		"");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
c_mapObjects_(::std::ostream& o,
	const ::c_mapObjects& s,
	const ::xml_schema::namespace_infomap& m,
	const ::std::string& e,
	::xml_schema::flags f)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0);

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::c_mapObjects_(s, m, f));

	::xsd::cxx::tree::error_handler< char > h;

	::xsd::cxx::xml::dom::ostream_format_target t(o);
	if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f))
	{
		h.throw_if_failed< ::xsd::cxx::tree::serialization< char > >();
	}
}

void
c_mapObjects_(::std::ostream& o,
	const ::c_mapObjects& s,
	::xml_schema::error_handler& h,
	const ::xml_schema::namespace_infomap& m,
	const ::std::string& e,
	::xml_schema::flags f)
{
	::xsd::cxx::xml::auto_initializer i(
		(f & ::xml_schema::flags::dont_initialize) == 0);

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::c_mapObjects_(s, m, f));
	::xsd::cxx::xml::dom::ostream_format_target t(o);
	if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f))
	{
		throw ::xsd::cxx::tree::serialization< char >();
	}
}

void
c_mapObjects_(::std::ostream& o,
	const ::c_mapObjects& s,
	::xercesc::DOMErrorHandler& h,
	const ::xml_schema::namespace_infomap& m,
	const ::std::string& e,
	::xml_schema::flags f)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::c_mapObjects_(s, m, f));
	::xsd::cxx::xml::dom::ostream_format_target t(o);
	if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f))
	{
		throw ::xsd::cxx::tree::serialization< char >();
	}
}

void
c_mapObjects_(::xercesc::XMLFormatTarget& t,
	const ::c_mapObjects& s,
	const ::xml_schema::namespace_infomap& m,
	const ::std::string& e,
	::xml_schema::flags f)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::c_mapObjects_(s, m, f));

	::xsd::cxx::tree::error_handler< char > h;

	if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f))
	{
		h.throw_if_failed< ::xsd::cxx::tree::serialization< char > >();
	}
}

void
c_mapObjects_(::xercesc::XMLFormatTarget& t,
	const ::c_mapObjects& s,
	::xml_schema::error_handler& h,
	const ::xml_schema::namespace_infomap& m,
	const ::std::string& e,
	::xml_schema::flags f)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::c_mapObjects_(s, m, f));
	if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f))
	{
		throw ::xsd::cxx::tree::serialization< char >();
	}
}

void
c_mapObjects_(::xercesc::XMLFormatTarget& t,
	const ::c_mapObjects& s,
	::xercesc::DOMErrorHandler& h,
	const ::xml_schema::namespace_infomap& m,
	const ::std::string& e,
	::xml_schema::flags f)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::c_mapObjects_(s, m, f));
	if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f))
	{
		throw ::xsd::cxx::tree::serialization< char >();
	}
}

void
c_mapObjects_(::xercesc::DOMDocument& d,
	const ::c_mapObjects& s,
	::xml_schema::flags)
{
	::xercesc::DOMElement& e(*d.getDocumentElement());
	const ::xsd::cxx::xml::qualified_name< char > n(
		::xsd::cxx::xml::dom::name< char >(e));

	if (n.name() == "c_mapObjects" &&
		n.namespace_() == "")
	{
		e << s;
	}
	else
	{
		throw ::xsd::cxx::tree::unexpected_element < char >(
			n.name(),
			n.namespace_(),
			"c_mapObjects",
			"");
	}
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
c_mapObjects_(const ::c_mapObjects& s,
	const ::xml_schema::namespace_infomap& m,
	::xml_schema::flags f)
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
		::xsd::cxx::xml::dom::serialize< char >(
			"c_mapObjects",
			"",
			m, f));

	::c_mapObjects_(*d, s, f);
	return d;
}

void
operator<< (::xercesc::DOMElement& e, const c_mapObjects& i)
{
	e << static_cast<const ::xml_schema::type&> (i);

	// object
	//
	for (c_mapObjects::object_const_iterator
		b(i.object().begin()), n(i.object().end());
		b != n; ++b)
	{
		::xercesc::DOMElement& s(
			::xsd::cxx::xml::dom::create_element(
				"object",
				e));

		s << *b;
	}

	// settlement
	//
	for (c_mapObjects::settlement_const_iterator
		b(i.settlement().begin()), n(i.settlement().end());
		b != n; ++b)
	{
		::xercesc::DOMElement& s(
			::xsd::cxx::xml::dom::create_element(
				"settlement",
				e));

		s << *b;
	}
}

void
operator<< (::xercesc::DOMElement& e, const object& i)
{
	e << static_cast<const ::xml_schema::type&> (i);

	// class
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"class",
				e));

		a << i.class_();
	}

	// id
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"id",
				e));

		a << i.id();
	}

	// healthperc
	//
	if (i.healthperc())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"healthperc",
				e));

		a << *i.healthperc();
	}

	// player
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"player",
				e));

		a << i.player();
	}

	// x
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"x",
				e));

		a << i.x();
	}

	// y
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"y",
				e));

		a << i.y();
	}

	// name
	//
	if (i.name())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"name",
				e));

		a << *i.name();
	}

	// icon
	//
	if (i.icon())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"icon",
				e));

		a << *i.icon();
	}
}

void
operator<< (::xercesc::DOMElement& e, const settlement& i)
{
	e << static_cast<const ::xml_schema::type&> (i);

	// object
	//
	for (settlement::object_const_iterator
		b(i.object().begin()), n(i.object().end());
		b != n; ++b)
	{
		::xercesc::DOMElement& s(
			::xsd::cxx::xml::dom::create_element(
				"object",
				e));

		s << *b;
	}

	// class
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"class",
				e));

		a << i.class_();
	}

	// id
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"id",
				e));

		a << i.id();
	}

	// player
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"player",
				e));

		a << i.player();
	}

	// x
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"x",
				e));

		a << i.x();
	}

	// y
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"y",
				e));

		a << i.y();
	}

	// name
	//
	if (i.name())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"name",
				e));

		a << *i.name();
	}

	// gold
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"gold",
				e));

		a << i.gold();
	}

	// food
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"food",
				e));

		a << i.food();
	}

	// population
	//
	if (i.population())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"population",
				e));

		a << *i.population();
	}

	// maxpopulation
	//
	if (i.maxpopulation())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"maxpopulation",
				e));

		a << *i.maxpopulation();
	}

	// healthperc
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"healthperc",
				e));

		a << i.healthperc();
	}

	// icon
	//
	if (i.icon())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"icon",
				e));

		a << *i.icon();
	}
}

void
operator<< (::xercesc::DOMElement& e, const object1& i)
{
	e << static_cast<const ::xml_schema::type&> (i);

	// class
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"class",
				e));

		a << i.class_();
	}

	// id
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"id",
				e));

		a << i.id();
	}

	// healthperc
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"healthperc",
				e));

		a << i.healthperc();
	}

	// player
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"player",
				e));

		a << i.player();
	}

	// x
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"x",
				e));

		a << i.x();
	}

	// y
	//
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"y",
				e));

		a << i.y();
	}

	// name
	//
	if (i.name())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"name",
				e));

		a << *i.name();
	}

	// icon
	//
	if (i.icon())
	{
		::xercesc::DOMAttr& a(
			::xsd::cxx::xml::dom::create_attribute(
				"icon",
				e));

		a << *i.icon();
	}
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

